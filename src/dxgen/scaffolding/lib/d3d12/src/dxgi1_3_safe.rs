// This file is autogenerated

use utils::*;

use dxgi_safe::*;
use dxgi1_2_safe::*;
#[derive(Default, Debug)]
pub struct DSize {
  pub height : UINT,
  pub width : UINT,
}

pub trait TDXGIDecodeSwapChain: TUnknown {
  //  Method PresentBuffer
  
  #[allow(non_snake_case)]
  fn present_buffer(&self, buffer_to_present: UINT, sync_interval: UINT, flags: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).PresentBuffer(buffer_to_present, sync_interval, flags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetSourceRect
  
  #[allow(non_snake_case)]
  fn set_source_rect(&self, rect: &RECT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).SetSourceRect(rect) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTargetRect
  
  #[allow(non_snake_case)]
  fn set_target_rect(&self, rect: &RECT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).SetTargetRect(rect) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetDestSize
  
  #[allow(non_snake_case)]
  fn set_dest_size(&self, width: UINT, height: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).SetDestSize(width, height) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSourceRect
  
  #[allow(non_snake_case)]
  fn get_source_rect(&self) -> HResult<RECT> {
    let mut lv1: RECT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).GetSourceRect(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetTargetRect
  
  #[allow(non_snake_case)]
  fn get_target_rect(&self) -> HResult<RECT> {
    let mut lv1: RECT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).GetTargetRect(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDestSize
  
  #[allow(non_snake_case)]
  fn get_dest_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).GetDestSize(&mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetColorSpace
  
  #[allow(non_snake_case)]
  fn set_color_space(&self, color_space: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).SetColorSpace(color_space) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColorSpace
  
  #[allow(non_snake_case)]
  fn get_color_space(&self) -> DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDecodeSwapChain)).GetColorSpace() };
    _hr
  }
  
  
}

impl TUnknown for DXGIDecodeSwapChain {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIDecodeSwapChain(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIDecodeSwapChain {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIDecodeSwapChain {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIDecodeSwapChain for DXGIDecodeSwapChain {}

pub struct DXGIDecodeSwapChain(*mut IDXGIDecodeSwapChain);

impl HasIID for DXGIDecodeSwapChain {
  fn iid() -> REFGUID { &IID_IDXGIDecodeSwapChain }
}

pub trait TDXGIDevice3: TDXGIDevice2 {
  //  Method Trim
  
  #[allow(non_snake_case)]
  fn trim(&self) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDevice3)).Trim() };
    ()
  }
  
  
}

impl TUnknown for DXGIDevice3 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIDevice3(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIDevice3 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIDevice3 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIDevice3 {}
impl TDXGIDevice for DXGIDevice3 {}
impl TDXGIDevice1 for DXGIDevice3 {}
impl TDXGIDevice2 for DXGIDevice3 {}
impl TDXGIDevice3 for DXGIDevice3 {}

pub struct DXGIDevice3(*mut IDXGIDevice3);

impl HasIID for DXGIDevice3 {
  fn iid() -> REFGUID { &IID_IDXGIDevice3 }
}

pub trait TDXGIFactory3: TDXGIFactory2 {
  //  Method GetCreationFlags
  
  #[allow(non_snake_case)]
  fn get_creation_flags(&self) -> UINT {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory3)).GetCreationFlags() };
    _hr
  }
  
  
}

impl TUnknown for DXGIFactory3 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIFactory3(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIFactory3 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIFactory3 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIFactory3 {}
impl TDXGIFactory for DXGIFactory3 {}
impl TDXGIFactory1 for DXGIFactory3 {}
impl TDXGIFactory2 for DXGIFactory3 {}
impl TDXGIFactory3 for DXGIFactory3 {}

pub struct DXGIFactory3(*mut IDXGIFactory3);

impl HasIID for DXGIFactory3 {
  fn iid() -> REFGUID { &IID_IDXGIFactory3 }
}

pub trait TDXGIFactoryMedia: TUnknown {
  //  Method CreateSwapChainForCompositionSurfaceHandle
  //  Error: ppSwapChain parameter: Unexpected type Ptr (Ptr (TypedefRef "IDXGISwapChain1"))
  //  Method CreateDecodeSwapChainForCompositionSurfaceHandle
  
  #[allow(non_snake_case)]
  fn create_decode_swap_chain_for_composition_surface_handle<T: TUnknown, T1: TDXGIResource>(&self, device: &T, hSurface: HANDLE, desc: &mut DXGI_DECODE_SWAP_CHAIN_DESC, yuv_decode_buffers: &T1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGIDecodeSwapChain> {
    let mut lv1: *mut IDXGIDecodeSwapChain = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactoryMedia)).CreateDecodeSwapChainForCompositionSurfaceHandle(device.iptr() as *mut _ as *mut _ , hSurface, desc, yuv_decode_buffers.iptr() as *mut _ as *mut _ , restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIDecodeSwapChain::new(lv1 as *mut _))
  }
  
  
}

impl TUnknown for DXGIFactoryMedia {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIFactoryMedia(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIFactoryMedia {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIFactoryMedia {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIFactoryMedia for DXGIFactoryMedia {}

pub struct DXGIFactoryMedia(*mut IDXGIFactoryMedia);

impl HasIID for DXGIFactoryMedia {
  fn iid() -> REFGUID { &IID_IDXGIFactoryMedia }
}

pub trait TDXGIOutput2: TDXGIOutput1 {
  //  Method SupportsOverlays
  
  #[allow(non_snake_case)]
  fn supports_overlays(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutput2)).SupportsOverlays() };
    _hr
  }
  
  
}

impl TUnknown for DXGIOutput2 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIOutput2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIOutput2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIOutput2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIOutput2 {}
impl TDXGIOutput for DXGIOutput2 {}
impl TDXGIOutput1 for DXGIOutput2 {}
impl TDXGIOutput2 for DXGIOutput2 {}

pub struct DXGIOutput2(*mut IDXGIOutput2);

impl HasIID for DXGIOutput2 {
  fn iid() -> REFGUID { &IID_IDXGIOutput2 }
}

pub trait TDXGIOutput3: TDXGIOutput2 {
  //  Method CheckOverlaySupport
  
  #[allow(non_snake_case)]
  fn check_overlay_support<T: TUnknown>(&self, enum_format: DXGI_FORMAT, concerned_device: &T) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutput3)).CheckOverlaySupport(enum_format, concerned_device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  
}

impl TUnknown for DXGIOutput3 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIOutput3(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIOutput3 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIOutput3 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIOutput3 {}
impl TDXGIOutput for DXGIOutput3 {}
impl TDXGIOutput1 for DXGIOutput3 {}
impl TDXGIOutput2 for DXGIOutput3 {}
impl TDXGIOutput3 for DXGIOutput3 {}

pub struct DXGIOutput3(*mut IDXGIOutput3);

impl HasIID for DXGIOutput3 {
  fn iid() -> REFGUID { &IID_IDXGIOutput3 }
}

pub trait TDXGISwapChain2: TDXGISwapChain1 {
  //  Method SetSourceSize
  
  #[allow(non_snake_case)]
  fn set_source_size(&self, width: UINT, height: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).SetSourceSize(width, height) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSourceSize
  
  #[allow(non_snake_case)]
  fn get_source_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).GetSourceSize(&mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  #[allow(non_snake_case)]
  fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).SetMaximumFrameLatency(max_latency) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMaximumFrameLatency
  
  #[allow(non_snake_case)]
  fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).GetMaximumFrameLatency(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetFrameLatencyWaitableObject
  
  #[allow(non_snake_case)]
  fn get_frame_latency_waitable_object(&self) -> HANDLE {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).GetFrameLatencyWaitableObject() };
    _hr
  }
  
  //  Method SetMatrixTransform
  
  #[allow(non_snake_case)]
  fn set_matrix_transform(&self, matrix: &DXGI_MATRIX_3X2_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).SetMatrixTransform(matrix) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMatrixTransform
  
  #[allow(non_snake_case)]
  fn get_matrix_transform(&self) -> HResult<DXGI_MATRIX_3X2_F> {
    let mut lv1: DXGI_MATRIX_3X2_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain2)).GetMatrixTransform(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  
}

impl TUnknown for DXGISwapChain2 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGISwapChain2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGISwapChain2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGISwapChain2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGISwapChain2 {}
impl TDXGIDeviceSubObject for DXGISwapChain2 {}
impl TDXGISwapChain for DXGISwapChain2 {}
impl TDXGISwapChain1 for DXGISwapChain2 {}
impl TDXGISwapChain2 for DXGISwapChain2 {}

pub struct DXGISwapChain2(*mut IDXGISwapChain2);

impl HasIID for DXGISwapChain2 {
  fn iid() -> REFGUID { &IID_IDXGISwapChain2 }
}

pub trait TDXGISwapChainMedia: TUnknown {
  //  Method GetFrameStatisticsMedia
  
  #[allow(non_snake_case)]
  fn get_frame_statistics_media(&self) -> HResult<DXGI_FRAME_STATISTICS_MEDIA> {
    let mut lv1: DXGI_FRAME_STATISTICS_MEDIA = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChainMedia)).GetFrameStatisticsMedia(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetPresentDuration
  
  #[allow(non_snake_case)]
  fn set_present_duration(&self, duration: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChainMedia)).SetPresentDuration(duration) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CheckPresentDurationSupport
  
  #[allow(non_snake_case)]
  fn check_present_duration_support(&self, desired_present_duration: UINT, closest_smaller_present_duration: &mut UINT, closest_larger_present_duration: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChainMedia)).CheckPresentDurationSupport(desired_present_duration, closest_smaller_present_duration, closest_larger_present_duration) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for DXGISwapChainMedia {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGISwapChainMedia(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGISwapChainMedia {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGISwapChainMedia {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGISwapChainMedia for DXGISwapChainMedia {}

pub struct DXGISwapChainMedia(*mut IDXGISwapChainMedia);

impl HasIID for DXGISwapChainMedia {
  fn iid() -> REFGUID { &IID_IDXGISwapChainMedia }
}

