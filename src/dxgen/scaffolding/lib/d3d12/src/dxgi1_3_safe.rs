// This file is autogenerated

use utils::*;

use dxgi_safe::*;
use dxgi1_2_safe::*;
#[derive(Default, Debug)]
pub struct DSize {
  pub height : UINT,
  pub width : UINT,
}


pub struct DXGIDecodeSwapChain(*mut IDXGIDecodeSwapChain);

impl HasIID for DXGIDecodeSwapChain {
  fn iid() -> REFGUID { &IID_IDXGIDecodeSwapChain }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDecodeSwapChain(pp_vtbl as *mut _ as *mut IDXGIDecodeSwapChain) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGIDecodeSwapChain {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDecodeSwapChain {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGIDecodeSwapChain {
  //  Method PresentBuffer
  
  #[allow(non_snake_case)]
  pub fn present_buffer(&self, buffer_to_present: UINT, sync_interval: UINT, flags: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).PresentBuffer(buffer_to_present, sync_interval, flags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetSourceRect
  
  #[allow(non_snake_case)]
  pub fn set_source_rect(&self, rect: &RECT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).SetSourceRect(rect) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTargetRect
  
  #[allow(non_snake_case)]
  pub fn set_target_rect(&self, rect: &RECT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).SetTargetRect(rect) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetDestSize
  
  #[allow(non_snake_case)]
  pub fn set_dest_size(&self, width: UINT, height: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).SetDestSize(width, height) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSourceRect
  
  #[allow(non_snake_case)]
  pub fn get_source_rect(&self) -> HResult<RECT> {
    let mut lv1: RECT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).GetSourceRect(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetTargetRect
  
  #[allow(non_snake_case)]
  pub fn get_target_rect(&self) -> HResult<RECT> {
    let mut lv1: RECT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).GetTargetRect(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDestSize
  
  #[allow(non_snake_case)]
  pub fn get_dest_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).GetDestSize(&mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetColorSpace
  
  #[allow(non_snake_case)]
  pub fn set_color_space(&self, color_space: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).SetColorSpace(color_space) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColorSpace
  
  #[allow(non_snake_case)]
  pub fn get_color_space(&self) -> DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDecodeSwapChain)).GetColorSpace() };
    _hr
  }
  
  
}

pub struct DXGIDevice3(*mut IDXGIDevice3);

impl HasIID for DXGIDevice3 {
  fn iid() -> REFGUID { &IID_IDXGIDevice3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDevice3(pp_vtbl as *mut _ as *mut IDXGIDevice3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGIDevice3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDevice3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGIDevice3 {
  //  Method SetPrivateData
  
  #[allow(non_snake_case)]
  pub fn set_private_data<T>(&self, name: &GUID, data: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).SetPrivateData(name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPrivateData
  
  #[allow(non_snake_case)]
  pub fn get_private_data<T>(&self, name: &GUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetPrivateData(name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetParent
  
  #[allow(non_snake_case)]
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetParent(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method GetAdapter
  
  #[allow(non_snake_case)]
  pub fn get_adapter(&self) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice)).GetAdapter(&mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method QueryResourceResidency
  
  #[allow(non_snake_case)]
  pub fn query_resource_residency<T: HasIID>(&self, resources: &[&T], residency_status: &mut [DXGI_RESIDENCY]) -> HResult<HRESULT> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice)).QueryResourceResidency(lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, slice_as_mut_ptr(residency_status),  same_length(&[Some(resources.len()),Some(residency_status.len())]).expect("Arrays must have equal sizes") as UINT) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetGPUThreadPriority
  
  #[allow(non_snake_case)]
  pub fn set_gpu_thread_priority(&self, priority: INT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice)).SetGPUThreadPriority(priority) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetGPUThreadPriority
  
  #[allow(non_snake_case)]
  pub fn get_gpu_thread_priority(&self) -> HResult<INT> {
    let mut lv1: INT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice)).GetGPUThreadPriority(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  #[allow(non_snake_case)]
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice1)).SetMaximumFrameLatency(max_latency) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMaximumFrameLatency
  
  #[allow(non_snake_case)]
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice1)).GetMaximumFrameLatency(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method OfferResources
  
  #[allow(non_snake_case)]
  pub fn offer_resources<T: HasIID>(&self, resources: &[&T], priority: DXGI_OFFER_RESOURCE_PRIORITY) -> HResult<HRESULT> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice2)).OfferResources(resources.len() as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, priority) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ReclaimResources
  
  #[allow(non_snake_case)]
  pub fn reclaim_resources<T: HasIID>(&self, resources: &[&T], discarded: Option<&mut [BOOL]>) -> HResult<HRESULT> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice2)).ReclaimResources( same_length(&[Some(resources.len()),discarded.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, opt_arr_as_mut_ptr(&discarded) as *mut _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method EnqueueSetEvent
  
  #[allow(non_snake_case)]
  pub fn enqueue_set_event(&self, hEvent: HANDLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice2)).EnqueueSetEvent(hEvent) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Trim
  
  #[allow(non_snake_case)]
  pub fn trim(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIDevice3)).Trim() };
    ()
  }
  
  
}

pub struct DXGIFactory3(*mut IDXGIFactory3);

impl HasIID for DXGIFactory3 {
  fn iid() -> REFGUID { &IID_IDXGIFactory3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactory3(pp_vtbl as *mut _ as *mut IDXGIFactory3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGIFactory3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactory3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGIFactory3 {
  //  Method SetPrivateData
  
  #[allow(non_snake_case)]
  pub fn set_private_data<T>(&self, name: &GUID, data: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).SetPrivateData(name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPrivateData
  
  #[allow(non_snake_case)]
  pub fn get_private_data<T>(&self, name: &GUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetPrivateData(name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetParent
  
  #[allow(non_snake_case)]
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetParent(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method EnumAdapters
  
  #[allow(non_snake_case)]
  pub fn enum_adapters(&self, adapter: UINT) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory)).EnumAdapters(adapter, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method MakeWindowAssociation
  
  #[allow(non_snake_case)]
  pub fn make_window_association(&self, window_handle: HWND, flags: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory)).MakeWindowAssociation(window_handle, flags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetWindowAssociation
  
  #[allow(non_snake_case)]
  pub fn get_window_association(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory)).GetWindowAssociation(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method CreateSwapChain
  
  #[allow(non_snake_case)]
  pub fn create_swap_chain<T: HasIID>(&self, device: &T, desc: &mut DXGI_SWAP_CHAIN_DESC) -> HResult<DXGISwapChain> {
    let mut lv1: *mut IDXGISwapChain = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory)).CreateSwapChain(device.iptr() as *mut _ as *mut _ , desc, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain::new(lv1 as *mut _))
  }
  
  //  Method CreateSoftwareAdapter
  
  #[allow(non_snake_case)]
  pub fn create_software_adapter(&self, module: HMODULE) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory)).CreateSoftwareAdapter(module, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method EnumAdapters1
  
  #[allow(non_snake_case)]
  pub fn enum_adapters1(&self, adapter: UINT) -> HResult<DXGIAdapter1> {
    let mut lv1: *mut IDXGIAdapter1 = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory1)).EnumAdapters1(adapter, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIAdapter1::new(lv1 as *mut _))
  }
  
  //  Method IsCurrent
  
  #[allow(non_snake_case)]
  pub fn is_current(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory1)).IsCurrent() };
    _hr
  }
  
  //  Method IsWindowedStereoEnabled
  
  #[allow(non_snake_case)]
  pub fn is_windowed_stereo_enabled(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).IsWindowedStereoEnabled() };
    _hr
  }
  
  //  Method CreateSwapChainForHwnd
  
  #[allow(non_snake_case)]
  pub fn create_swap_chain_for_hwnd<T: HasIID>(&self, device: &T, hWnd: HWND, desc: &DXGI_SWAP_CHAIN_DESC1, fullscreen_desc: Option<&DXGI_SWAP_CHAIN_FULLSCREEN_DESC>, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).CreateSwapChainForHwnd(device.iptr() as *mut _ as *mut _ , hWnd, desc, fullscreen_desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method CreateSwapChainForCoreWindow
  
  #[allow(non_snake_case)]
  pub fn create_swap_chain_for_core_window<T: HasIID, T1: HasIID>(&self, device: &T, window: &T1, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).CreateSwapChainForCoreWindow(device.iptr() as *mut _ as *mut _ , window.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetSharedResourceAdapterLuid
  
  #[allow(non_snake_case)]
  pub fn get_shared_resource_adapter_luid(&self, hResource: HANDLE) -> HResult<LUID> {
    let mut lv1: LUID = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).GetSharedResourceAdapterLuid(hResource, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method RegisterStereoStatusWindow
  
  #[allow(non_snake_case)]
  pub fn register_stereo_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).RegisterStereoStatusWindow(window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method RegisterStereoStatusEvent
  
  #[allow(non_snake_case)]
  pub fn register_stereo_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).RegisterStereoStatusEvent(hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method UnregisterStereoStatus
  
  #[allow(non_snake_case)]
  pub fn unregister_stereo_status(&self, cookie: DWORD) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).UnregisterStereoStatus(cookie) };
    ()
  }
  
  //  Method RegisterOcclusionStatusWindow
  
  #[allow(non_snake_case)]
  pub fn register_occlusion_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).RegisterOcclusionStatusWindow(window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method RegisterOcclusionStatusEvent
  
  #[allow(non_snake_case)]
  pub fn register_occlusion_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).RegisterOcclusionStatusEvent(hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method UnregisterOcclusionStatus
  
  #[allow(non_snake_case)]
  pub fn unregister_occlusion_status(&self, cookie: DWORD) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).UnregisterOcclusionStatus(cookie) };
    ()
  }
  
  //  Method CreateSwapChainForComposition
  
  #[allow(non_snake_case)]
  pub fn create_swap_chain_for_composition<T: HasIID>(&self, device: &T, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory2)).CreateSwapChainForComposition(device.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetCreationFlags
  
  #[allow(non_snake_case)]
  pub fn get_creation_flags(&self) -> UINT {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactory3)).GetCreationFlags() };
    _hr
  }
  
  
}

pub struct DXGIFactoryMedia(*mut IDXGIFactoryMedia);

impl HasIID for DXGIFactoryMedia {
  fn iid() -> REFGUID { &IID_IDXGIFactoryMedia }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactoryMedia(pp_vtbl as *mut _ as *mut IDXGIFactoryMedia) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGIFactoryMedia {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactoryMedia {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGIFactoryMedia {
  //  Method CreateSwapChainForCompositionSurfaceHandle
  //  Error: ppSwapChain parameter: Unexpected type Ptr (Ptr (TypedefRef "IDXGISwapChain1"))
  //  Method CreateDecodeSwapChainForCompositionSurfaceHandle
  
  #[allow(non_snake_case)]
  pub fn create_decode_swap_chain_for_composition_surface_handle<T: HasIID, T1: HasIID>(&self, device: &T, hSurface: HANDLE, desc: &mut DXGI_DECODE_SWAP_CHAIN_DESC, yuv_decode_buffers: &T1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGIDecodeSwapChain> {
    let mut lv1: *mut IDXGIDecodeSwapChain = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIFactoryMedia)).CreateDecodeSwapChainForCompositionSurfaceHandle(device.iptr() as *mut _ as *mut _ , hSurface, desc, yuv_decode_buffers.iptr() as *mut _ as *mut _ , restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIDecodeSwapChain::new(lv1 as *mut _))
  }
  
  
}

pub struct DXGIOutput2(*mut IDXGIOutput2);

impl HasIID for DXGIOutput2 {
  fn iid() -> REFGUID { &IID_IDXGIOutput2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput2(pp_vtbl as *mut _ as *mut IDXGIOutput2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGIOutput2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGIOutput2 {
  //  Method SetPrivateData
  
  #[allow(non_snake_case)]
  pub fn set_private_data<T>(&self, name: &GUID, data: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).SetPrivateData(name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPrivateData
  
  #[allow(non_snake_case)]
  pub fn get_private_data<T>(&self, name: &GUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetPrivateData(name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetParent
  
  #[allow(non_snake_case)]
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetParent(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  #[allow(non_snake_case)]
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetDesc(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  #[allow(non_snake_case)]
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetDisplayModeList(enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  #[allow(non_snake_case)]
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).FindClosestMatchingMode(mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  #[allow(non_snake_case)]
  pub fn wait_for_v_blank(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).WaitForVBlank() };
    hr2ret(_hr,_hr)
  }
  
  //  Method TakeOwnership
  
  #[allow(non_snake_case)]
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).TakeOwnership(device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ReleaseOwnership
  
  #[allow(non_snake_case)]
  pub fn release_ownership(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).ReleaseOwnership() };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  #[allow(non_snake_case)]
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetGammaControlCapabilities(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetGammaControl
  
  #[allow(non_snake_case)]
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).SetGammaControl(array) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetGammaControl
  
  #[allow(non_snake_case)]
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetGammaControl(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  #[allow(non_snake_case)]
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).SetDisplaySurface(scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDisplaySurfaceData
  
  #[allow(non_snake_case)]
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetDisplaySurfaceData(destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFrameStatistics
  
  #[allow(non_snake_case)]
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetFrameStatistics(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDisplayModeList1
  
  #[allow(non_snake_case)]
  pub fn get_display_mode_list1(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC1]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).GetDisplayModeList1(enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method FindClosestMatchingMode1
  
  #[allow(non_snake_case)]
  pub fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).FindClosestMatchingMode1(mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDisplaySurfaceData1
  
  #[allow(non_snake_case)]
  pub fn get_display_surface_data1<T: HasIID>(&self, destination: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).GetDisplaySurfaceData1(destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DuplicateOutput
  
  #[allow(non_snake_case)]
  pub fn duplicate_output<T: HasIID>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).DuplicateOutput(device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  //  Method SupportsOverlays
  
  #[allow(non_snake_case)]
  pub fn supports_overlays(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput2)).SupportsOverlays() };
    _hr
  }
  
  
}

pub struct DXGIOutput3(*mut IDXGIOutput3);

impl HasIID for DXGIOutput3 {
  fn iid() -> REFGUID { &IID_IDXGIOutput3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput3(pp_vtbl as *mut _ as *mut IDXGIOutput3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGIOutput3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGIOutput3 {
  //  Method SetPrivateData
  
  #[allow(non_snake_case)]
  pub fn set_private_data<T>(&self, name: &GUID, data: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).SetPrivateData(name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPrivateData
  
  #[allow(non_snake_case)]
  pub fn get_private_data<T>(&self, name: &GUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetPrivateData(name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetParent
  
  #[allow(non_snake_case)]
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetParent(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  #[allow(non_snake_case)]
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetDesc(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  #[allow(non_snake_case)]
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetDisplayModeList(enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  #[allow(non_snake_case)]
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).FindClosestMatchingMode(mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  #[allow(non_snake_case)]
  pub fn wait_for_v_blank(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).WaitForVBlank() };
    hr2ret(_hr,_hr)
  }
  
  //  Method TakeOwnership
  
  #[allow(non_snake_case)]
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).TakeOwnership(device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ReleaseOwnership
  
  #[allow(non_snake_case)]
  pub fn release_ownership(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).ReleaseOwnership() };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  #[allow(non_snake_case)]
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetGammaControlCapabilities(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetGammaControl
  
  #[allow(non_snake_case)]
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).SetGammaControl(array) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetGammaControl
  
  #[allow(non_snake_case)]
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetGammaControl(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  #[allow(non_snake_case)]
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).SetDisplaySurface(scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDisplaySurfaceData
  
  #[allow(non_snake_case)]
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetDisplaySurfaceData(destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFrameStatistics
  
  #[allow(non_snake_case)]
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput)).GetFrameStatistics(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDisplayModeList1
  
  #[allow(non_snake_case)]
  pub fn get_display_mode_list1(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC1]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).GetDisplayModeList1(enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method FindClosestMatchingMode1
  
  #[allow(non_snake_case)]
  pub fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).FindClosestMatchingMode1(mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDisplaySurfaceData1
  
  #[allow(non_snake_case)]
  pub fn get_display_surface_data1<T: HasIID>(&self, destination: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).GetDisplaySurfaceData1(destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DuplicateOutput
  
  #[allow(non_snake_case)]
  pub fn duplicate_output<T: HasIID>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput1)).DuplicateOutput(device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  //  Method SupportsOverlays
  
  #[allow(non_snake_case)]
  pub fn supports_overlays(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput2)).SupportsOverlays() };
    _hr
  }
  
  //  Method CheckOverlaySupport
  
  #[allow(non_snake_case)]
  pub fn check_overlay_support<T: HasIID>(&self, enum_format: DXGI_FORMAT, concerned_device: &T) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGIOutput3)).CheckOverlaySupport(enum_format, concerned_device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  
}

pub struct DXGISwapChain2(*mut IDXGISwapChain2);

impl HasIID for DXGISwapChain2 {
  fn iid() -> REFGUID { &IID_IDXGISwapChain2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChain2(pp_vtbl as *mut _ as *mut IDXGISwapChain2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGISwapChain2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChain2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGISwapChain2 {
  //  Method SetPrivateData
  
  #[allow(non_snake_case)]
  pub fn set_private_data<T>(&self, name: &GUID, data: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).SetPrivateData(name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPrivateData
  
  #[allow(non_snake_case)]
  pub fn get_private_data<T>(&self, name: &GUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetPrivateData(name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetParent
  
  #[allow(non_snake_case)]
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGIObject)).GetParent(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method Present
  
  #[allow(non_snake_case)]
  pub fn present(&self, sync_interval: UINT, flags: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).Present(sync_interval, flags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetBuffer
  
  #[allow(non_snake_case)]
  pub fn get_buffer<T: HasIID>(&self, buffer: UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).GetBuffer(buffer, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method SetFullscreenState
  
  #[allow(non_snake_case)]
  pub fn set_fullscreen_state(&self, fullscreen: BOOL, target: Option<&DXGIOutput>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).SetFullscreenState(fullscreen, target.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFullscreenState
  
  #[allow(non_snake_case)]
  pub fn get_fullscreen_state(&self, fullscreen: Option<&mut BOOL>) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).GetFullscreenState(opt_as_mut_ptr(&fullscreen), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetDesc
  
  #[allow(non_snake_case)]
  pub fn get_desc(&self) -> HResult<DXGI_SWAP_CHAIN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).GetDesc(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method ResizeBuffers
  
  #[allow(non_snake_case)]
  pub fn resize_buffers(&self, buffer_count: UINT, width: UINT, height: UINT, new_format: DXGI_FORMAT, swap_chain_flags: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).ResizeBuffers(buffer_count, width, height, new_format, swap_chain_flags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ResizeTarget
  
  #[allow(non_snake_case)]
  pub fn resize_target(&self, new_target_parameters: &DXGI_MODE_DESC) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).ResizeTarget(new_target_parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetContainingOutput
  
  #[allow(non_snake_case)]
  pub fn get_containing_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).GetContainingOutput(&mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetFrameStatistics
  
  #[allow(non_snake_case)]
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).GetFrameStatistics(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetLastPresentCount
  
  #[allow(non_snake_case)]
  pub fn get_last_present_count(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain)).GetLastPresentCount(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetDesc1
  
  #[allow(non_snake_case)]
  pub fn get_desc1(&self) -> HResult<DXGI_SWAP_CHAIN_DESC1> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC1 = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).GetDesc1(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetFullscreenDesc
  
  #[allow(non_snake_case)]
  pub fn get_fullscreen_desc(&self) -> HResult<DXGI_SWAP_CHAIN_FULLSCREEN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_FULLSCREEN_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).GetFullscreenDesc(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetHwnd
  
  #[allow(non_snake_case)]
  pub fn get_hwnd(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).GetHwnd(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetCoreWindow
  
  #[allow(non_snake_case)]
  pub fn get_core_window<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).GetCoreWindow(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method Present1
  
  #[allow(non_snake_case)]
  pub fn present1(&self, sync_interval: UINT, present_flags: UINT, present_parameters: &DXGI_PRESENT_PARAMETERS) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).Present1(sync_interval, present_flags, present_parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method IsTemporaryMonoSupported
  
  #[allow(non_snake_case)]
  pub fn is_temporary_mono_supported(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).IsTemporaryMonoSupported() };
    _hr
  }
  
  //  Method GetRestrictToOutput
  //  Error: ppRestrictToOutput parameter: Unexpected type Ptr (Ptr (TypedefRef "IDXGIOutput"))
  //  Method SetBackgroundColor
  
  #[allow(non_snake_case)]
  pub fn set_background_color(&self, color: &DXGI_RGBA) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).SetBackgroundColor(color) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetBackgroundColor
  
  #[allow(non_snake_case)]
  pub fn get_background_color(&self) -> HResult<DXGI_RGBA> {
    let mut lv1: DXGI_RGBA = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).GetBackgroundColor(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetRotation
  
  #[allow(non_snake_case)]
  pub fn set_rotation(&self, rotation: DXGI_MODE_ROTATION) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).SetRotation(rotation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetRotation
  
  #[allow(non_snake_case)]
  pub fn get_rotation(&self) -> HResult<DXGI_MODE_ROTATION> {
    let mut lv1: DXGI_MODE_ROTATION = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain1)).GetRotation(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetSourceSize
  
  #[allow(non_snake_case)]
  pub fn set_source_size(&self, width: UINT, height: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).SetSourceSize(width, height) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSourceSize
  
  #[allow(non_snake_case)]
  pub fn get_source_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).GetSourceSize(&mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  #[allow(non_snake_case)]
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).SetMaximumFrameLatency(max_latency) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMaximumFrameLatency
  
  #[allow(non_snake_case)]
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).GetMaximumFrameLatency(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetFrameLatencyWaitableObject
  
  #[allow(non_snake_case)]
  pub fn get_frame_latency_waitable_object(&self) -> HANDLE {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).GetFrameLatencyWaitableObject() };
    _hr
  }
  
  //  Method SetMatrixTransform
  
  #[allow(non_snake_case)]
  pub fn set_matrix_transform(&self, matrix: &DXGI_MATRIX_3X2_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).SetMatrixTransform(matrix) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMatrixTransform
  
  #[allow(non_snake_case)]
  pub fn get_matrix_transform(&self) -> HResult<DXGI_MATRIX_3X2_F> {
    let mut lv1: DXGI_MATRIX_3X2_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChain2)).GetMatrixTransform(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  
}

pub struct DXGISwapChainMedia(*mut IDXGISwapChainMedia);

impl HasIID for DXGISwapChainMedia {
  fn iid() -> REFGUID { &IID_IDXGISwapChainMedia }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChainMedia(pp_vtbl as *mut _ as *mut IDXGISwapChainMedia) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for DXGISwapChainMedia {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChainMedia {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl DXGISwapChainMedia {
  //  Method GetFrameStatisticsMedia
  
  #[allow(non_snake_case)]
  pub fn get_frame_statistics_media(&self) -> HResult<DXGI_FRAME_STATISTICS_MEDIA> {
    let mut lv1: DXGI_FRAME_STATISTICS_MEDIA = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChainMedia)).GetFrameStatisticsMedia(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetPresentDuration
  
  #[allow(non_snake_case)]
  pub fn set_present_duration(&self, duration: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChainMedia)).SetPresentDuration(duration) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CheckPresentDurationSupport
  
  #[allow(non_snake_case)]
  pub fn check_present_duration_support(&self, desired_present_duration: UINT, closest_smaller_present_duration: &mut UINT, closest_larger_present_duration: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut IDXGISwapChainMedia)).CheckPresentDurationSupport(desired_present_duration, closest_smaller_present_duration, closest_larger_present_duration) };
    hr2ret(_hr,_hr)
  }
  
  
}
