// This file is autogenerated

use utils::*;

use dxgi_safe::*;
pub trait TDXGIAdapter2: TDXGIAdapter1 {
  //  Method GetDesc2
  
  #[allow(non_snake_case)]
  fn get_desc2(&self) -> HResult<DXGI_ADAPTER_DESC2> {
    let mut lv1: DXGI_ADAPTER_DESC2 = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIAdapter2)).GetDesc2(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  
}

impl TUnknown for DXGIAdapter2 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIAdapter2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIAdapter2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIAdapter2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIAdapter2 {}
impl TDXGIAdapter for DXGIAdapter2 {}
impl TDXGIAdapter1 for DXGIAdapter2 {}
impl TDXGIAdapter2 for DXGIAdapter2 {}

pub struct DXGIAdapter2(*mut IDXGIAdapter2);

impl HasIID for DXGIAdapter2 {
  fn iid() -> REFGUID { &IID_IDXGIAdapter2 }
}

pub trait TDXGIDevice2: TDXGIDevice1 {
  //  Method OfferResources
  
  #[allow(non_snake_case)]
  fn offer_resources<T: TDXGIResource>(&self, resources: &[&T], priority: DXGI_OFFER_RESOURCE_PRIORITY) -> HResult<HRESULT> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDevice2)).OfferResources(resources.len() as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, priority) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ReclaimResources
  
  #[allow(non_snake_case)]
  fn reclaim_resources<T: TDXGIResource>(&self, resources: &[&T], discarded: Option<&mut [BOOL]>) -> HResult<HRESULT> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDevice2)).ReclaimResources( same_length(&[Some(resources.len()),discarded.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, opt_arr_as_mut_ptr(&discarded) as *mut _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method EnqueueSetEvent
  
  #[allow(non_snake_case)]
  fn enqueue_set_event(&self, hEvent: HANDLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDevice2)).EnqueueSetEvent(hEvent) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for DXGIDevice2 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIDevice2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIDevice2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIDevice2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIDevice2 {}
impl TDXGIDevice for DXGIDevice2 {}
impl TDXGIDevice1 for DXGIDevice2 {}
impl TDXGIDevice2 for DXGIDevice2 {}

pub struct DXGIDevice2(*mut IDXGIDevice2);

impl HasIID for DXGIDevice2 {
  fn iid() -> REFGUID { &IID_IDXGIDevice2 }
}

pub trait TDXGIDisplayControl: TUnknown {
  //  Method IsStereoEnabled
  
  #[allow(non_snake_case)]
  fn is_stereo_enabled(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDisplayControl)).IsStereoEnabled() };
    _hr
  }
  
  //  Method SetStereoEnabled
  
  #[allow(non_snake_case)]
  fn set_stereo_enabled(&self, enabled: BOOL) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIDisplayControl)).SetStereoEnabled(enabled) };
    ()
  }
  
  
}

impl TUnknown for DXGIDisplayControl {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIDisplayControl(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIDisplayControl {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIDisplayControl {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIDisplayControl for DXGIDisplayControl {}

pub struct DXGIDisplayControl(*mut IDXGIDisplayControl);

impl HasIID for DXGIDisplayControl {
  fn iid() -> REFGUID { &IID_IDXGIDisplayControl }
}

pub trait TDXGIFactory2: TDXGIFactory1 {
  //  Method IsWindowedStereoEnabled
  
  #[allow(non_snake_case)]
  fn is_windowed_stereo_enabled(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).IsWindowedStereoEnabled() };
    _hr
  }
  
  //  Method CreateSwapChainForHwnd
  
  #[allow(non_snake_case)]
  fn create_swap_chain_for_hwnd<T: TUnknown>(&self, device: &T, hWnd: HWND, desc: &DXGI_SWAP_CHAIN_DESC1, fullscreen_desc: Option<&DXGI_SWAP_CHAIN_FULLSCREEN_DESC>, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).CreateSwapChainForHwnd(device.iptr() as *mut _ as *mut _ , hWnd, desc, fullscreen_desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method CreateSwapChainForCoreWindow
  
  #[allow(non_snake_case)]
  fn create_swap_chain_for_core_window<T: TUnknown, T1: TUnknown>(&self, device: &T, window: &T1, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).CreateSwapChainForCoreWindow(device.iptr() as *mut _ as *mut _ , window.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetSharedResourceAdapterLuid
  
  #[allow(non_snake_case)]
  fn get_shared_resource_adapter_luid(&self, hResource: HANDLE) -> HResult<LUID> {
    let mut lv1: LUID = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).GetSharedResourceAdapterLuid(hResource, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method RegisterStereoStatusWindow
  
  #[allow(non_snake_case)]
  fn register_stereo_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).RegisterStereoStatusWindow(window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method RegisterStereoStatusEvent
  
  #[allow(non_snake_case)]
  fn register_stereo_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).RegisterStereoStatusEvent(hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method UnregisterStereoStatus
  
  #[allow(non_snake_case)]
  fn unregister_stereo_status(&self, cookie: DWORD) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).UnregisterStereoStatus(cookie) };
    ()
  }
  
  //  Method RegisterOcclusionStatusWindow
  
  #[allow(non_snake_case)]
  fn register_occlusion_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).RegisterOcclusionStatusWindow(window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method RegisterOcclusionStatusEvent
  
  #[allow(non_snake_case)]
  fn register_occlusion_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).RegisterOcclusionStatusEvent(hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method UnregisterOcclusionStatus
  
  #[allow(non_snake_case)]
  fn unregister_occlusion_status(&self, cookie: DWORD) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).UnregisterOcclusionStatus(cookie) };
    ()
  }
  
  //  Method CreateSwapChainForComposition
  
  #[allow(non_snake_case)]
  fn create_swap_chain_for_composition<T: TUnknown>(&self, device: &T, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIFactory2)).CreateSwapChainForComposition(device.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  
}

impl TUnknown for DXGIFactory2 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIFactory2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIFactory2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIFactory2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIFactory2 {}
impl TDXGIFactory for DXGIFactory2 {}
impl TDXGIFactory1 for DXGIFactory2 {}
impl TDXGIFactory2 for DXGIFactory2 {}

pub struct DXGIFactory2(*mut IDXGIFactory2);

impl HasIID for DXGIFactory2 {
  fn iid() -> REFGUID { &IID_IDXGIFactory2 }
}

pub trait TDXGIOutput1: TDXGIOutput {
  //  Method GetDisplayModeList1
  
  #[allow(non_snake_case)]
  fn get_display_mode_list1(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC1]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutput1)).GetDisplayModeList1(enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method FindClosestMatchingMode1
  
  #[allow(non_snake_case)]
  fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutput1)).FindClosestMatchingMode1(mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDisplaySurfaceData1
  
  #[allow(non_snake_case)]
  fn get_display_surface_data1<T: TDXGIResource>(&self, destination: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutput1)).GetDisplaySurfaceData1(destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DuplicateOutput
  
  #[allow(non_snake_case)]
  fn duplicate_output<T: TUnknown>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutput1)).DuplicateOutput(device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  
}

impl TUnknown for DXGIOutput1 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIOutput1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIOutput1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIOutput1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIOutput1 {}
impl TDXGIOutput for DXGIOutput1 {}
impl TDXGIOutput1 for DXGIOutput1 {}

pub struct DXGIOutput1(*mut IDXGIOutput1);

impl HasIID for DXGIOutput1 {
  fn iid() -> REFGUID { &IID_IDXGIOutput1 }
}

pub trait TDXGIOutputDuplication: TDXGIObject {
  //  Method GetDesc
  
  #[allow(non_snake_case)]
  fn get_desc(&self) -> DXGI_OUTDUPL_DESC {
    let mut lv1: DXGI_OUTDUPL_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).GetDesc(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method AcquireNextFrame
  //  Error: ppDesktopResource parameter: Unexpected type Ptr (Ptr (TypedefRef "IDXGIResource"))
  //  Method GetFrameDirtyRects
  
  #[allow(non_snake_case)]
  fn get_frame_dirty_rects(&self, dirty_rects_buffer: &mut [RECT], dirty_rects_buffer_size_required: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).GetFrameDirtyRects((mem::size_of_val(dirty_rects_buffer)/1) as UINT, dirty_rects_buffer.as_mut_ptr() as *mut _, dirty_rects_buffer_size_required) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFrameMoveRects
  
  #[allow(non_snake_case)]
  fn get_frame_move_rects(&self, move_rect_buffer: &mut [DXGI_OUTDUPL_MOVE_RECT], move_rects_buffer_size_required: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).GetFrameMoveRects((mem::size_of_val(move_rect_buffer)/1) as UINT, move_rect_buffer.as_mut_ptr() as *mut _, move_rects_buffer_size_required) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFramePointerShape
  
  #[allow(non_snake_case)]
  fn get_frame_pointer_shape<T>(&self, pointer_shape_buffer: &mut [T], pointer_shape_buffer_size_required: &mut UINT, pointer_shape_info: &mut DXGI_OUTDUPL_POINTER_SHAPE_INFO) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).GetFramePointerShape((mem::size_of_val(pointer_shape_buffer)/1) as UINT, pointer_shape_buffer.as_mut_ptr() as *mut _, pointer_shape_buffer_size_required, pointer_shape_info) };
    hr2ret(_hr,_hr)
  }
  
  //  Method MapDesktopSurface
  
  #[allow(non_snake_case)]
  fn map_desktop_surface(&self) -> HResult<DXGI_MAPPED_RECT> {
    let mut lv1: DXGI_MAPPED_RECT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).MapDesktopSurface(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method UnMapDesktopSurface
  
  #[allow(non_snake_case)]
  fn un_map_desktop_surface(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).UnMapDesktopSurface() };
    hr2ret(_hr,_hr)
  }
  
  //  Method ReleaseFrame
  
  #[allow(non_snake_case)]
  fn release_frame(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIOutputDuplication)).ReleaseFrame() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for DXGIOutputDuplication {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIOutputDuplication(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIOutputDuplication {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIOutputDuplication {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIOutputDuplication {}
impl TDXGIOutputDuplication for DXGIOutputDuplication {}

pub struct DXGIOutputDuplication(*mut IDXGIOutputDuplication);

impl HasIID for DXGIOutputDuplication {
  fn iid() -> REFGUID { &IID_IDXGIOutputDuplication }
}

pub trait TDXGIResource1: TDXGIResource {
  //  Method CreateSubresourceSurface
  
  #[allow(non_snake_case)]
  fn create_subresource_surface(&self, index: UINT) -> HResult<DXGISurface2> {
    let mut lv1: *mut IDXGISurface2 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIResource1)).CreateSubresourceSurface(index, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,DXGISurface2::new(lv1 as *mut _))
  }
  
  //  Method CreateSharedHandle
  
  #[allow(non_snake_case)]
  fn create_shared_handle(&self, attributes: Option<&SECURITY_ATTRIBUTES>, access: DWORD, lpName: Cow<str>) -> HResult<HANDLE> {
    let lv1: Vec<u16> = str_to_vec_u16(lpName);
    let mut lv2: HANDLE = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGIResource1)).CreateSharedHandle(attributes.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), access, lv1.as_ptr() as LPCWSTR, &mut lv2 as *mut _ as *mut _) };
    hr2ret(_hr,lv2)
  }
  
  
}

impl TUnknown for DXGIResource1 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGIResource1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGIResource1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGIResource1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGIResource1 {}
impl TDXGIDeviceSubObject for DXGIResource1 {}
impl TDXGIResource for DXGIResource1 {}
impl TDXGIResource1 for DXGIResource1 {}

pub struct DXGIResource1(*mut IDXGIResource1);

impl HasIID for DXGIResource1 {
  fn iid() -> REFGUID { &IID_IDXGIResource1 }
}

pub trait TDXGISurface2: TDXGISurface1 {
  //  Method GetResource
  
  #[allow(non_snake_case)]
  fn get_resource<T: TUnknown+HasIID>(&self, subresource_index: &mut UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISurface2)).GetResource(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void, subresource_index) };
    hr2ret(_hr,T::new(lv1))
  }
  
  
}

impl TUnknown for DXGISurface2 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGISurface2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGISurface2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGISurface2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGISurface2 {}
impl TDXGIDeviceSubObject for DXGISurface2 {}
impl TDXGISurface for DXGISurface2 {}
impl TDXGISurface1 for DXGISurface2 {}
impl TDXGISurface2 for DXGISurface2 {}

pub struct DXGISurface2(*mut IDXGISurface2);

impl HasIID for DXGISurface2 {
  fn iid() -> REFGUID { &IID_IDXGISurface2 }
}

pub trait TDXGISwapChain1: TDXGISwapChain {
  //  Method GetDesc1
  
  #[allow(non_snake_case)]
  fn get_desc1(&self) -> HResult<DXGI_SWAP_CHAIN_DESC1> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC1 = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).GetDesc1(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetFullscreenDesc
  
  #[allow(non_snake_case)]
  fn get_fullscreen_desc(&self) -> HResult<DXGI_SWAP_CHAIN_FULLSCREEN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_FULLSCREEN_DESC = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).GetFullscreenDesc(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetHwnd
  
  #[allow(non_snake_case)]
  fn get_hwnd(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).GetHwnd(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetCoreWindow
  
  #[allow(non_snake_case)]
  fn get_core_window<T: TUnknown+HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).GetCoreWindow(T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(_hr,T::new(lv1))
  }
  
  //  Method Present1
  
  #[allow(non_snake_case)]
  fn present1(&self, sync_interval: UINT, present_flags: UINT, present_parameters: &DXGI_PRESENT_PARAMETERS) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).Present1(sync_interval, present_flags, present_parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method IsTemporaryMonoSupported
  
  #[allow(non_snake_case)]
  fn is_temporary_mono_supported(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).IsTemporaryMonoSupported() };
    _hr
  }
  
  //  Method GetRestrictToOutput
  //  Error: ppRestrictToOutput parameter: Unexpected type Ptr (Ptr (TypedefRef "IDXGIOutput"))
  //  Method SetBackgroundColor
  
  #[allow(non_snake_case)]
  fn set_background_color(&self, color: &DXGI_RGBA) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).SetBackgroundColor(color) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetBackgroundColor
  
  #[allow(non_snake_case)]
  fn get_background_color(&self) -> HResult<DXGI_RGBA> {
    let mut lv1: DXGI_RGBA = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).GetBackgroundColor(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method SetRotation
  
  #[allow(non_snake_case)]
  fn set_rotation(&self, rotation: DXGI_MODE_ROTATION) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).SetRotation(rotation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetRotation
  
  #[allow(non_snake_case)]
  fn get_rotation(&self) -> HResult<DXGI_MODE_ROTATION> {
    let mut lv1: DXGI_MODE_ROTATION = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.iptr() as *mut IDXGISwapChain1)).GetRotation(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  
}

impl TUnknown for DXGISwapChain1 {
  fn new(ptr: *mut IUnknown) -> Self {
    DXGISwapChain1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for DXGISwapChain1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for DXGISwapChain1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TDXGIObject for DXGISwapChain1 {}
impl TDXGIDeviceSubObject for DXGISwapChain1 {}
impl TDXGISwapChain for DXGISwapChain1 {}
impl TDXGISwapChain1 for DXGISwapChain1 {}

pub struct DXGISwapChain1(*mut IDXGISwapChain1);

impl HasIID for DXGISwapChain1 {
  fn iid() -> REFGUID { &IID_IDXGISwapChain1 }
}

