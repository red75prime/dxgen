// This file is autogenerated

extern crate d3d12_sys;
extern crate libc;

//extern crate dxgi_sys;
//extern crate winapi;

//use self::dxgi_sys::*;
//use self::winapi::*;

use d3d12_sys::iids::*;
use d3d12_sys::*;
use std::ptr;
use std::mem;
use std::borrow::Cow;
use libc::*;
use std::ffi::{OsStr,OsString};
use std::os::windows::ffi::OsStrExt;

fn os_str_to_vec_u16(s : &OsStr) -> Vec<u16> {
  s.encode_wide().chain(Some(0).into_iter()).collect::<Vec<_>>()
}

fn opt_arr_as_mut_ptr<T>(opt: &Option<&mut [T]>) -> *mut T {
  opt.as_ref().map(|v|(*v).as_ptr() as *mut _).unwrap_or(ptr::null_mut())
}

fn opt_as_mut_ptr<T>(opt: &Option<&mut T>) -> *mut T {
  opt.as_ref().map(|v|*v as *const _ as *mut _).unwrap_or(ptr::null_mut())
}

fn str_to_vec_u16(s : Cow<str>) -> Vec<u16> {
  let osstr = OsString::from(s.into_owned());
  osstr.encode_wide().chain(Some(0).into_iter()).collect::<Vec<_>>()
}

// Utility function. 
// Compares optional numbers
// returns Some(len) if all inputs are Some(len) or None (or Some(0) if all inputs are None), 
//         None otherwise
fn same_length(lens:&[Option<usize>]) -> Option<usize> {
    let res=lens.iter().fold(Ok(None), 
        |sz, mlen| { 
            match sz { 
                Err(_) => sz, 
                Ok(None) => Ok(mlen.map(|l1|l1)), 
                Ok(Some(l)) => 
                    match *mlen {
                        None => sz, 
                        Some(l1) => 
                            if l1==l {
                                sz
                            } else {
                                Err(())
                            }
                    }
            }
        });
    res.map(|ms|{ms.unwrap_or(0)}).ok()
}

fn hr2ret<T>(hr : HRESULT, res:T) -> HResult<T> {
  if hr==0 { // TODO: mimic what SUCCESS macro does.
    Ok(res)
  } else {
    Err(hr)
  }
}

unsafe fn zeroinit_com_wrapper<T: HasIID>() -> T {
  T::new(ptr::null_mut())
}

fn opt_slice_to_mut_ptr<T>(os: Option<&mut [T]>) -> *mut T {
  os.map(|s|s.as_mut_ptr()).unwrap_or(::std::ptr::null_mut())
}

fn opt_slice_to_ptr<T>(os: Option<&[T]>) -> *const T {
  os.map(|s|s.as_ptr()).unwrap_or(::std::ptr::null())
}


#[derive(Default, Debug)]
pub struct DSize {
  height : UINT,
  width : UINT,
}

#[derive(Default, Debug)]
pub struct GPUCPUTimestamp {
  cpu_timestamp : UINT64,
  gpu_timestamp : UINT64,
}

pub struct D3D10Blob(*mut ID3D10Blob);

impl HasIID for D3D10Blob {
  fn iid() -> &'static IID { &IID_ID3D10Blob }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D10Blob(pp_vtbl as *mut _ as *mut ID3D10Blob) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D10Blob {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D10Blob {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D10Blob {
  //  Method GetBufferPointer
  
  pub fn get_buffer_pointer(&self) -> LPVOID {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBufferPointer)(self.0) };
    hr
  }
  
  //  Method GetBufferSize
  
  pub fn get_buffer_size(&self) -> SIZE_T {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBufferSize)(self.0) };
    hr
  }
  
  
}

pub struct D3D12CommandAllocator(*mut ID3D12CommandAllocator);

impl HasIID for D3D12CommandAllocator {
  fn iid() -> &'static IID { &IID_ID3D12CommandAllocator }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12CommandAllocator(pp_vtbl as *mut _ as *mut ID3D12CommandAllocator) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12CommandAllocator {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12CommandAllocator {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12CommandAllocator {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Reset
  
  pub fn reset(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Reset)(self.0) };
    hr2ret(hr,())
  }
  
  
}

pub struct D3D12CommandList(*mut ID3D12CommandList);

impl HasIID for D3D12CommandList {
  fn iid() -> &'static IID { &IID_ID3D12CommandList }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12CommandList(pp_vtbl as *mut _ as *mut ID3D12CommandList) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12CommandList {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12CommandList {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12CommandList {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetType
  
  pub fn get_type(&self) -> D3D12_COMMAND_LIST_TYPE {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetType)(self.0) };
    hr
  }
  
  
}

pub struct D3D12CommandQueue(*mut ID3D12CommandQueue);

impl HasIID for D3D12CommandQueue {
  fn iid() -> &'static IID { &IID_ID3D12CommandQueue }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12CommandQueue(pp_vtbl as *mut _ as *mut ID3D12CommandQueue) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12CommandQueue {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12CommandQueue {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12CommandQueue {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method UpdateTileMappings
  
  pub fn update_tile_mappings<T: HasIID>(&self, resource: &T, resource_region_start_coordinates: Option<&mut [D3D12_TILED_RESOURCE_COORDINATE]>, resource_region_sizes: Option<&mut [D3D12_TILE_REGION_SIZE]>, heap: Option<&mut ID3D12Heap>, range_flags: Option<&mut [D3D12_TILE_RANGE_FLAGS]>, heap_range_start_offsets: Option<&mut [UINT]>, range_tile_counts: Option<&mut [UINT]>, flags: D3D12_TILE_MAPPING_FLAGS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UpdateTileMappings)(self.0, resource.iptr() as *mut _ as *mut _ ,  same_length(&[resource_region_start_coordinates.as_ref().map(|a|a.len()),resource_region_sizes.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, opt_arr_as_mut_ptr(&resource_region_start_coordinates) as *mut _, opt_arr_as_mut_ptr(&resource_region_sizes) as *mut _, opt_as_mut_ptr(&heap),  same_length(&[range_flags.as_ref().map(|a|a.len()),heap_range_start_offsets.as_ref().map(|a|a.len()),range_tile_counts.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, opt_arr_as_mut_ptr(&range_flags) as *mut _, opt_arr_as_mut_ptr(&heap_range_start_offsets) as *mut _, opt_arr_as_mut_ptr(&range_tile_counts) as *mut _, flags) };
    ()
  }
  
  //  Method CopyTileMappings
  
  pub fn copy_tile_mappings<T: HasIID, T1: HasIID>(&self, dst_resource: &T, dst_region_start_coordinate: &D3D12_TILED_RESOURCE_COORDINATE, src_resource: &T1, src_region_start_coordinate: &D3D12_TILED_RESOURCE_COORDINATE, region_size: &D3D12_TILE_REGION_SIZE, flags: D3D12_TILE_MAPPING_FLAGS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyTileMappings)(self.0, dst_resource.iptr() as *mut _ as *mut _ , dst_region_start_coordinate, src_resource.iptr() as *mut _ as *mut _ , src_region_start_coordinate, region_size, flags) };
    ()
  }
  
  //  Method ExecuteCommandLists
  
  pub fn execute_command_lists<T: HasIID>(&self, command_lists: &[&T]) -> () {
    let mut lv1: Vec<*mut IUnknown> = command_lists.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).ExecuteCommandLists)(self.0,  same_length(&[Some(command_lists.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _) };
    ()
  }
  
  //  Method Signal
  
  pub fn signal(&self, fence: &mut ID3D12Fence, value: UINT64) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Signal)(self.0, fence, value) };
    hr2ret(hr,())
  }
  
  //  Method Wait
  
  pub fn wait(&self, fence: &mut ID3D12Fence, value: UINT64) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Wait)(self.0, fence, value) };
    hr2ret(hr,())
  }
  
  //  Method GetTimestampFrequency
  
  pub fn get_timestamp_frequency(&self) -> HResult<UINT64> {
    let mut lv1: UINT64 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetTimestampFrequency)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetClockCalibration
  
  pub fn get_clock_calibration(&self) -> HResult<GPUCPUTimestamp> {
    let mut lv1: GPUCPUTimestamp = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetClockCalibration)(self.0, &mut (lv1.gpu_timestamp) as *mut _ as *mut _, &mut (lv1.cpu_timestamp) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> D3D12_COMMAND_QUEUE_DESC {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0) };
    hr
  }
  
  
}

pub struct D3D12CommandSignature(*mut ID3D12CommandSignature);

impl HasIID for D3D12CommandSignature {
  fn iid() -> &'static IID { &IID_ID3D12CommandSignature }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12CommandSignature(pp_vtbl as *mut _ as *mut ID3D12CommandSignature) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12CommandSignature {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12CommandSignature {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12CommandSignature {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct D3D12Debug(*mut ID3D12Debug);

impl HasIID for D3D12Debug {
  fn iid() -> &'static IID { &IID_ID3D12Debug }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Debug(pp_vtbl as *mut _ as *mut ID3D12Debug) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Debug {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Debug {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Debug {
  //  Method EnableDebugLayer
  
  pub fn enable_debug_layer(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).EnableDebugLayer)(self.0) };
    ()
  }
  
  
}

pub struct D3D12DescriptorHeap(*mut ID3D12DescriptorHeap);

impl HasIID for D3D12DescriptorHeap {
  fn iid() -> &'static IID { &IID_ID3D12DescriptorHeap }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12DescriptorHeap(pp_vtbl as *mut _ as *mut ID3D12DescriptorHeap) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12DescriptorHeap {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12DescriptorHeap {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12DescriptorHeap {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> D3D12_DESCRIPTOR_HEAP_DESC {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0) };
    hr
  }
  
  //  Method GetCPUDescriptorHandleForHeapStart
  
  pub fn get_cpu_descriptor_handle_for_heap_start(&self) -> D3D12_CPU_DESCRIPTOR_HANDLE {
    let mut lv1: D3D12_CPU_DESCRIPTOR_HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCPUDescriptorHandleForHeapStart)(self.0, &mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetGPUDescriptorHandleForHeapStart
  
  pub fn get_gpu_descriptor_handle_for_heap_start(&self) -> D3D12_GPU_DESCRIPTOR_HANDLE {
    let mut lv1: D3D12_GPU_DESCRIPTOR_HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGPUDescriptorHandleForHeapStart)(self.0, &mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  
}

pub struct D3D12DeviceChild(*mut ID3D12DeviceChild);

impl HasIID for D3D12DeviceChild {
  fn iid() -> &'static IID { &IID_ID3D12DeviceChild }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12DeviceChild(pp_vtbl as *mut _ as *mut ID3D12DeviceChild) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12DeviceChild {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12DeviceChild {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12DeviceChild {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct D3D12Device(*mut ID3D12Device);

impl HasIID for D3D12Device {
  fn iid() -> &'static IID { &IID_ID3D12Device }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Device(pp_vtbl as *mut _ as *mut ID3D12Device) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Device {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Device {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Device {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetNodeCount
  
  pub fn get_node_count(&self) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetNodeCount)(self.0) };
    hr
  }
  
  //  Method CreateCommandQueue
  
  pub fn create_command_queue(&self, desc: &D3D12_COMMAND_QUEUE_DESC) -> HResult<D3D12CommandQueue> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateCommandQueue)(self.0, desc, D3D12CommandQueue::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12CommandQueue::new(lv1))
  }
  
  //  Method CreateCommandAllocator
  
  pub fn create_command_allocator(&self, type_: D3D12_COMMAND_LIST_TYPE) -> HResult<D3D12CommandAllocator> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateCommandAllocator)(self.0, type_, D3D12CommandAllocator::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12CommandAllocator::new(lv1))
  }
  
  //  Method CreateGraphicsPipelineState
  
  pub fn create_graphics_pipeline_state(&self, desc: &D3D12_GRAPHICS_PIPELINE_STATE_DESC) -> HResult<D3D12PipelineState> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateGraphicsPipelineState)(self.0, desc, D3D12PipelineState::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12PipelineState::new(lv1))
  }
  
  //  Method CreateComputePipelineState
  
  pub fn create_compute_pipeline_state(&self, desc: &D3D12_COMPUTE_PIPELINE_STATE_DESC) -> HResult<D3D12PipelineState> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateComputePipelineState)(self.0, desc, D3D12PipelineState::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12PipelineState::new(lv1))
  }
  
  //  Method CreateCommandList
  
  pub fn create_command_list<T: HasIID, T1: HasIID>(&self, nodeMask: UINT, type_: D3D12_COMMAND_LIST_TYPE, command_allocator: &T, initial_state: Option<&D3D12PipelineState>) -> HResult<T1> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateCommandList)(self.0, nodeMask, type_, command_allocator.iptr() as *mut _ as *mut _ , initial_state.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, T1::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T1::new(lv1))
  }
  
  //  Method CheckFeatureSupport
  
  pub fn check_feature_support_options(&self, feature_support_data: &mut D3D12_FEATURE_DATA_D3D12_OPTIONS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckFeatureSupport)(self.0, D3D12_FEATURE_D3D12_OPTIONS, feature_support_data as *mut _ as *mut _, mem::size_of_val(feature_support_data) as UINT) };
    hr2ret(hr,())
  }
  
  
  pub fn check_feature_support_arch(&self, feature_support_data: &mut D3D12_FEATURE_DATA_ARCHITECTURE) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckFeatureSupport)(self.0, D3D12_FEATURE_ARCHITECTURE, feature_support_data as *mut _ as *mut _, mem::size_of_val(feature_support_data) as UINT) };
    hr2ret(hr,())
  }
  
  
  pub fn check_feature_support_feature_levels(&self, feature_support_data: &mut D3D12_FEATURE_DATA_FEATURE_LEVELS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckFeatureSupport)(self.0, D3D12_FEATURE_FEATURE_LEVELS, feature_support_data as *mut _ as *mut _, mem::size_of_val(feature_support_data) as UINT) };
    hr2ret(hr,())
  }
  
  
  pub fn check_feature_support_format_support(&self, feature_support_data: &mut D3D12_FEATURE_DATA_FORMAT_SUPPORT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckFeatureSupport)(self.0, D3D12_FEATURE_FORMAT_SUPPORT, feature_support_data as *mut _ as *mut _, mem::size_of_val(feature_support_data) as UINT) };
    hr2ret(hr,())
  }
  
  
  pub fn check_feature_support_multisample_quality_levels(&self, feature_support_data: &mut D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckFeatureSupport)(self.0, D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS, feature_support_data as *mut _ as *mut _, mem::size_of_val(feature_support_data) as UINT) };
    hr2ret(hr,())
  }
  
  
  pub fn check_feature_support_format_info(&self, feature_support_data: &mut D3D12_FEATURE_DATA_FORMAT_INFO) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckFeatureSupport)(self.0, D3D12_FEATURE_FORMAT_INFO, feature_support_data as *mut _ as *mut _, mem::size_of_val(feature_support_data) as UINT) };
    hr2ret(hr,())
  }
  
  //  Method CreateDescriptorHeap
  
  pub fn create_descriptor_heap(&self, descriptor_heap_desc: &D3D12_DESCRIPTOR_HEAP_DESC) -> HResult<D3D12DescriptorHeap> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateDescriptorHeap)(self.0, descriptor_heap_desc, D3D12DescriptorHeap::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12DescriptorHeap::new(lv1))
  }
  
  //  Method GetDescriptorHandleIncrementSize
  
  pub fn get_descriptor_handle_increment_size(&self, descriptor_heap_type: D3D12_DESCRIPTOR_HEAP_TYPE) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDescriptorHandleIncrementSize)(self.0, descriptor_heap_type) };
    hr
  }
  
  //  Method CreateRootSignature
  
  pub fn create_root_signature<T>(&self, nodeMask: UINT, blob_with_root_signature: &[T]) -> HResult<D3D12RootSignature> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateRootSignature)(self.0, nodeMask, blob_with_root_signature.as_ptr() as *const _, (mem::size_of_val(blob_with_root_signature)/1) as SIZE_T, D3D12RootSignature::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12RootSignature::new(lv1))
  }
  
  //  Method CreateConstantBufferView
  
  pub fn create_constant_buffer_view(&self, desc: Option<&D3D12_CONSTANT_BUFFER_VIEW_DESC>, dest_descriptor: D3D12_CPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateConstantBufferView)(self.0, desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), dest_descriptor) };
    ()
  }
  
  //  Method CreateShaderResourceView
  
  pub fn create_shader_resource_view(&self, resource: Option<&mut ID3D12Resource>, desc: Option<&D3D12_SHADER_RESOURCE_VIEW_DESC>, dest_descriptor: D3D12_CPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateShaderResourceView)(self.0, opt_as_mut_ptr(&resource), desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), dest_descriptor) };
    ()
  }
  
  //  Method CreateUnorderedAccessView
  
  pub fn create_unordered_access_view(&self, resource: Option<&mut ID3D12Resource>, counter_resource: Option<&mut ID3D12Resource>, desc: Option<&D3D12_UNORDERED_ACCESS_VIEW_DESC>, dest_descriptor: D3D12_CPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateUnorderedAccessView)(self.0, opt_as_mut_ptr(&resource), opt_as_mut_ptr(&counter_resource), desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), dest_descriptor) };
    ()
  }
  
  //  Method CreateRenderTargetView
  
  pub fn create_render_target_view(&self, resource: Option<&D3D12Resource>, desc: Option<&D3D12_RENDER_TARGET_VIEW_DESC>, dest_descriptor: D3D12_CPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateRenderTargetView)(self.0, resource.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), dest_descriptor) };
    ()
  }
  
  //  Method CreateDepthStencilView
  
  pub fn create_depth_stencil_view(&self, resource: Option<&mut ID3D12Resource>, desc: Option<&D3D12_DEPTH_STENCIL_VIEW_DESC>, dest_descriptor: D3D12_CPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateDepthStencilView)(self.0, opt_as_mut_ptr(&resource), desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), dest_descriptor) };
    ()
  }
  
  //  Method CreateSampler
  
  pub fn create_sampler(&self, desc: &D3D12_SAMPLER_DESC, dest_descriptor: D3D12_CPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSampler)(self.0, desc, dest_descriptor) };
    ()
  }
  
  //  Method CopyDescriptors
  
  pub fn copy_descriptors(&self, dest_descriptor_range_starts: &mut [D3D12_CPU_DESCRIPTOR_HANDLE], dest_descriptor_range_sizes: Option<&mut [UINT]>, src_descriptor_range_starts: &mut [D3D12_CPU_DESCRIPTOR_HANDLE], src_descriptor_range_sizes: Option<&mut [UINT]>, descriptor_heaps_type: D3D12_DESCRIPTOR_HEAP_TYPE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyDescriptors)(self.0,  same_length(&[Some(dest_descriptor_range_starts.len()),dest_descriptor_range_sizes.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, dest_descriptor_range_starts.as_mut_ptr() as *mut _, opt_arr_as_mut_ptr(&dest_descriptor_range_sizes) as *mut _,  same_length(&[Some(src_descriptor_range_starts.len()),src_descriptor_range_sizes.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, src_descriptor_range_starts.as_mut_ptr() as *mut _, opt_arr_as_mut_ptr(&src_descriptor_range_sizes) as *mut _, descriptor_heaps_type) };
    ()
  }
  
  //  Method CopyDescriptorsSimple
  
  pub fn copy_descriptors_simple(&self, num_descriptors: UINT, dest_descriptor_range_start: D3D12_CPU_DESCRIPTOR_HANDLE, src_descriptor_range_start: D3D12_CPU_DESCRIPTOR_HANDLE, descriptor_heaps_type: D3D12_DESCRIPTOR_HEAP_TYPE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyDescriptorsSimple)(self.0, num_descriptors, dest_descriptor_range_start, src_descriptor_range_start, descriptor_heaps_type) };
    ()
  }
  
  //  Method GetResourceAllocationInfo
  
  pub fn get_resource_allocation_info(&self, visibleMask: UINT, resource_descs: &mut [D3D12_RESOURCE_DESC]) -> D3D12_RESOURCE_ALLOCATION_INFO {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetResourceAllocationInfo)(self.0, visibleMask,  same_length(&[Some(resource_descs.len())]).expect("Arrays must have equal sizes") as UINT, resource_descs.as_mut_ptr() as *mut _) };
    hr
  }
  
  //  Method GetCustomHeapProperties
  
  pub fn get_custom_heap_properties(&self, nodeMask: UINT, heapType: D3D12_HEAP_TYPE) -> D3D12_HEAP_PROPERTIES {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCustomHeapProperties)(self.0, nodeMask, heapType) };
    hr
  }
  
  //  Method CreateCommittedResource
  
  pub fn create_committed_resource(&self, heap_properties: &D3D12_HEAP_PROPERTIES, heap_flags: D3D12_HEAP_FLAGS, resource_desc: &D3D12_RESOURCE_DESC, initial_resource_state: D3D12_RESOURCE_STATES, optimized_clear_value: Option<&D3D12_CLEAR_VALUE>) -> HResult<D3D12Resource> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateCommittedResource)(self.0, heap_properties, heap_flags, resource_desc, initial_resource_state, optimized_clear_value.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), D3D12Resource::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12Resource::new(lv1))
  }
  
  //  Method CreateHeap
  
  pub fn create_heap(&self, desc: &D3D12_HEAP_DESC) -> HResult<D3D12Heap> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateHeap)(self.0, desc, D3D12Heap::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12Heap::new(lv1))
  }
  
  //  Method CreatePlacedResource
  
  pub fn create_placed_resource(&self, heap: &mut ID3D12Heap, heap_offset: UINT64, desc: &D3D12_RESOURCE_DESC, initial_state: D3D12_RESOURCE_STATES, optimized_clear_value: Option<&D3D12_CLEAR_VALUE>) -> HResult<D3D12Resource> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreatePlacedResource)(self.0, heap, heap_offset, desc, initial_state, optimized_clear_value.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), D3D12Resource::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12Resource::new(lv1))
  }
  
  //  Method CreateReservedResource
  
  pub fn create_reserved_resource(&self, desc: &D3D12_RESOURCE_DESC, initial_state: D3D12_RESOURCE_STATES, optimized_clear_value: Option<&D3D12_CLEAR_VALUE>) -> HResult<D3D12Resource> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateReservedResource)(self.0, desc, initial_state, optimized_clear_value.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), D3D12Resource::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12Resource::new(lv1))
  }
  
  //  Method CreateSharedHandle
  
  pub fn create_shared_handle(&self, object: &mut ID3D12DeviceChild, attributes: Option<&SECURITY_ATTRIBUTES>, access: DWORD, name: Cow<str>) -> HResult<HANDLE> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let mut lv2: HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSharedHandle)(self.0, object, attributes.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), access, lv1.as_ptr() as LPCWSTR, &mut lv2 as *mut _ as *mut _) };
    hr2ret(hr,lv2)
  }
  
  //  Method OpenSharedHandle
  
  pub fn open_shared_handle<T: HasIID>(&self, n_t_handle: HANDLE) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).OpenSharedHandle)(self.0, n_t_handle, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method OpenSharedHandleByName
  
  pub fn open_shared_handle_by_name(&self, name: Cow<str>, access: DWORD) -> HResult<HANDLE> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let mut lv2: HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).OpenSharedHandleByName)(self.0, lv1.as_ptr() as LPCWSTR, access, &mut lv2 as *mut _ as *mut _) };
    hr2ret(hr,lv2)
  }
  
  //  Method MakeResident
  
  pub fn make_resident(&self, objects: &mut [&mut ID3D12Pageable]) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).MakeResident)(self.0,  same_length(&[Some(objects.len())]).expect("Arrays must have equal sizes") as UINT, objects.as_mut_ptr() as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method Evict
  
  pub fn evict(&self, objects: &mut [&mut ID3D12Pageable]) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Evict)(self.0,  same_length(&[Some(objects.len())]).expect("Arrays must have equal sizes") as UINT, objects.as_mut_ptr() as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method CreateFence
  
  pub fn create_fence(&self, initial_value: UINT64, flags: D3D12_FENCE_FLAGS) -> HResult<D3D12Fence> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateFence)(self.0, initial_value, flags, D3D12Fence::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12Fence::new(lv1))
  }
  
  //  Method GetDeviceRemovedReason
  
  pub fn get_device_removed_reason(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDeviceRemovedReason)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method GetCopyableFootprints
  
  pub fn get_copyable_footprints(&self, resource_desc: &D3D12_RESOURCE_DESC, first_subresource: UINT, base_offset: UINT64, layouts: Option<&mut [D3D12_PLACED_SUBRESOURCE_FOOTPRINT]>, num_rows: Option<&mut [UINT]>, row_size_in_bytes: Option<&mut [UINT64]>, total_bytes: Option<&mut UINT64>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCopyableFootprints)(self.0, resource_desc, first_subresource,  same_length(&[layouts.as_ref().map(|a|a.len()),num_rows.as_ref().map(|a|a.len()),row_size_in_bytes.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, base_offset, opt_arr_as_mut_ptr(&layouts) as *mut _, opt_arr_as_mut_ptr(&num_rows) as *mut _, opt_arr_as_mut_ptr(&row_size_in_bytes) as *mut _, opt_as_mut_ptr(&total_bytes)) };
    ()
  }
  
  //  Method CreateQueryHeap
  
  pub fn create_query_heap(&self, desc: &D3D12_QUERY_HEAP_DESC) -> HResult<D3D12QueryHeap> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateQueryHeap)(self.0, desc, D3D12QueryHeap::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12QueryHeap::new(lv1))
  }
  
  //  Method SetStablePowerState
  
  pub fn set_stable_power_state(&self, enable: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetStablePowerState)(self.0, enable) };
    hr2ret(hr,())
  }
  
  //  Method CreateCommandSignature
  
  pub fn create_command_signature(&self, desc: &D3D12_COMMAND_SIGNATURE_DESC, root_signature: Option<&mut ID3D12RootSignature>) -> HResult<D3D12CommandSignature> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateCommandSignature)(self.0, desc, opt_as_mut_ptr(&root_signature), D3D12CommandSignature::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,D3D12CommandSignature::new(lv1))
  }
  
  //  Method GetResourceTiling
  
  pub fn get_resource_tiling<T: HasIID>(&self, tiled_resource: &T, num_tiles_for_entire_resource: Option<&mut UINT>, packed_mip_desc: Option<&mut D3D12_PACKED_MIP_INFO>, standard_tile_shape_for_non_packed_mips: Option<&mut D3D12_TILE_SHAPE>, num_subresource_tilings: Option<&mut UINT>, first_subresource_tiling_to_get: UINT) -> D3D12_SUBRESOURCE_TILING {
    let mut lv1: D3D12_SUBRESOURCE_TILING = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetResourceTiling)(self.0, tiled_resource.iptr() as *mut _ as *mut _ , opt_as_mut_ptr(&num_tiles_for_entire_resource), opt_as_mut_ptr(&packed_mip_desc), opt_as_mut_ptr(&standard_tile_shape_for_non_packed_mips), opt_as_mut_ptr(&num_subresource_tilings), first_subresource_tiling_to_get, &mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetAdapterLuid
  
  pub fn get_adapter_luid(&self) -> LUID {
    let mut lv1: LUID = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetAdapterLuid)(self.0, &mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  
}

pub struct D3D12Fence(*mut ID3D12Fence);

impl HasIID for D3D12Fence {
  fn iid() -> &'static IID { &IID_ID3D12Fence }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Fence(pp_vtbl as *mut _ as *mut ID3D12Fence) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Fence {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Fence {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Fence {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetCompletedValue
  
  pub fn get_completed_value(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCompletedValue)(self.0) };
    hr
  }
  
  //  Method SetEventOnCompletion
  
  pub fn set_event_on_completion(&self, value: UINT64, hEvent: HANDLE) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetEventOnCompletion)(self.0, value, hEvent) };
    hr2ret(hr,())
  }
  
  //  Method Signal
  
  pub fn signal(&self, value: UINT64) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Signal)(self.0, value) };
    hr2ret(hr,())
  }
  
  
}

pub struct D3D12GraphicsCommandList(*mut ID3D12GraphicsCommandList);

impl HasIID for D3D12GraphicsCommandList {
  fn iid() -> &'static IID { &IID_ID3D12GraphicsCommandList }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12GraphicsCommandList(pp_vtbl as *mut _ as *mut ID3D12GraphicsCommandList) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12GraphicsCommandList {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12GraphicsCommandList {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12GraphicsCommandList {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetType
  
  pub fn get_type(&self) -> D3D12_COMMAND_LIST_TYPE {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetType)(self.0) };
    hr
  }
  
  //  Method Close
  
  pub fn close(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Close)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method Reset
  
  pub fn reset<T: HasIID>(&self, allocator: &T, initial_state: Option<&D3D12PipelineState>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Reset)(self.0, allocator.iptr() as *mut _ as *mut _ , initial_state.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method ClearState
  
  pub fn clear_state(&self, pipeline_state: Option<&D3D12PipelineState>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearState)(self.0, pipeline_state.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    ()
  }
  
  //  Method DrawInstanced
  
  pub fn draw_instanced(&self, vertex_count_per_instance: UINT, instance_count: UINT, start_vertex_location: UINT, start_instance_location: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).DrawInstanced)(self.0, vertex_count_per_instance, instance_count, start_vertex_location, start_instance_location) };
    ()
  }
  
  //  Method DrawIndexedInstanced
  
  pub fn draw_indexed_instanced(&self, index_count_per_instance: UINT, instance_count: UINT, start_index_location: UINT, base_vertex_location: INT, start_instance_location: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).DrawIndexedInstanced)(self.0, index_count_per_instance, instance_count, start_index_location, base_vertex_location, start_instance_location) };
    ()
  }
  
  //  Method Dispatch
  
  pub fn dispatch(&self, thread_group_count_x: UINT, thread_group_count_y: UINT, thread_group_count_z: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Dispatch)(self.0, thread_group_count_x, thread_group_count_y, thread_group_count_z) };
    ()
  }
  
  //  Method CopyBufferRegion
  
  pub fn copy_buffer_region<T: HasIID, T1: HasIID>(&self, dst_buffer: &T, dst_offset: UINT64, src_buffer: &T1, src_offset: UINT64, num_bytes: UINT64) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyBufferRegion)(self.0, dst_buffer.iptr() as *mut _ as *mut _ , dst_offset, src_buffer.iptr() as *mut _ as *mut _ , src_offset, num_bytes) };
    ()
  }
  
  //  Method CopyTextureRegion
  
  pub fn copy_texture_region(&self, dst: &D3D12_TEXTURE_COPY_LOCATION, dst_x: UINT, dst_y: UINT, dst_z: UINT, src: &D3D12_TEXTURE_COPY_LOCATION, src_box: Option<&D3D12_BOX>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyTextureRegion)(self.0, dst, dst_x, dst_y, dst_z, src, src_box.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    ()
  }
  
  //  Method CopyResource
  
  pub fn copy_resource<T: HasIID, T1: HasIID>(&self, dst_resource: &T, src_resource: &T1) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyResource)(self.0, dst_resource.iptr() as *mut _ as *mut _ , src_resource.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method CopyTiles
  
  pub fn copy_tiles<T: HasIID, T1: HasIID>(&self, tiled_resource: &T, tile_region_start_coordinate: &D3D12_TILED_RESOURCE_COORDINATE, tile_region_size: &D3D12_TILE_REGION_SIZE, buffer: &T1, buffer_start_offset_in_bytes: UINT64, flags: D3D12_TILE_COPY_FLAGS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CopyTiles)(self.0, tiled_resource.iptr() as *mut _ as *mut _ , tile_region_start_coordinate, tile_region_size, buffer.iptr() as *mut _ as *mut _ , buffer_start_offset_in_bytes, flags) };
    ()
  }
  
  //  Method ResolveSubresource
  
  pub fn resolve_subresource<T: HasIID, T1: HasIID>(&self, dst_resource: &T, dst_subresource: UINT, src_resource: &T1, src_subresource: UINT, format: DXGI_FORMAT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResolveSubresource)(self.0, dst_resource.iptr() as *mut _ as *mut _ , dst_subresource, src_resource.iptr() as *mut _ as *mut _ , src_subresource, format) };
    ()
  }
  
  //  Method IASetPrimitiveTopology
  
  pub fn ia_set_primitive_topology(&self, primitive_topology: D3D12_PRIMITIVE_TOPOLOGY) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IASetPrimitiveTopology)(self.0, primitive_topology) };
    ()
  }
  
  //  Method RSSetViewports
  
  pub fn rs_set_viewports(&self, viewports: &mut [D3D12_VIEWPORT]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).RSSetViewports)(self.0,  same_length(&[Some(viewports.len())]).expect("Arrays must have equal sizes") as UINT, viewports.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method RSSetScissorRects
  
  pub fn rs_set_scissor_rects(&self, rects: &mut [D3D12_RECT]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).RSSetScissorRects)(self.0,  same_length(&[Some(rects.len())]).expect("Arrays must have equal sizes") as UINT, rects.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method OMSetBlendFactor
  
  pub fn om_set_blend_factor(&self, blend_factor: Option<&mut [FLOAT;4]>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).OMSetBlendFactor)(self.0, opt_as_mut_ptr(&blend_factor)) };
    ()
  }
  
  //  Method OMSetStencilRef
  
  pub fn om_set_stencil_ref(&self, stencil_ref: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).OMSetStencilRef)(self.0, stencil_ref) };
    ()
  }
  
  //  Method SetPipelineState
  
  pub fn set_pipeline_state<T: HasIID>(&self, pipeline_state: &T) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPipelineState)(self.0, pipeline_state.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method ResourceBarrier
  
  pub fn resource_barrier(&self, barriers: &mut [D3D12_RESOURCE_BARRIER]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResourceBarrier)(self.0,  same_length(&[Some(barriers.len())]).expect("Arrays must have equal sizes") as UINT, barriers.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method ExecuteBundle
  
  pub fn execute_bundle<T: HasIID>(&self, command_list: &T) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ExecuteBundle)(self.0, command_list.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method SetDescriptorHeaps
  
  pub fn set_descriptor_heaps<T: HasIID>(&self, descriptor_heaps: &[&T]) -> () {
    let mut lv1: Vec<*mut IUnknown> = descriptor_heaps.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDescriptorHeaps)(self.0,  same_length(&[Some(descriptor_heaps.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _) };
    ()
  }
  
  //  Method SetComputeRootSignature
  
  pub fn set_compute_root_signature<T: HasIID>(&self, root_signature: &T) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRootSignature)(self.0, root_signature.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method SetGraphicsRootSignature
  
  pub fn set_graphics_root_signature<T: HasIID>(&self, root_signature: &T) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRootSignature)(self.0, root_signature.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method SetComputeRootDescriptorTable
  
  pub fn set_compute_root_descriptor_table(&self, root_parameter_index: UINT, base_descriptor: D3D12_GPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRootDescriptorTable)(self.0, root_parameter_index, base_descriptor) };
    ()
  }
  
  //  Method SetGraphicsRootDescriptorTable
  
  pub fn set_graphics_root_descriptor_table(&self, root_parameter_index: UINT, base_descriptor: D3D12_GPU_DESCRIPTOR_HANDLE) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRootDescriptorTable)(self.0, root_parameter_index, base_descriptor) };
    ()
  }
  
  //  Method SetComputeRoot32BitConstant
  
  pub fn set_compute_root32_bit_constant(&self, root_parameter_index: UINT, src_data: UINT, dest_offset_in32_bit_values: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRoot32BitConstant)(self.0, root_parameter_index, src_data, dest_offset_in32_bit_values) };
    ()
  }
  
  //  Method SetGraphicsRoot32BitConstant
  
  pub fn set_graphics_root32_bit_constant(&self, root_parameter_index: UINT, src_data: UINT, dest_offset_in32_bit_values: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRoot32BitConstant)(self.0, root_parameter_index, src_data, dest_offset_in32_bit_values) };
    ()
  }
  
  //  Method SetComputeRoot32BitConstants
  
  pub fn set_compute_root32_bit_constants<T>(&self, root_parameter_index: UINT, src_data: &[T], dest_offset_in32_bit_values: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRoot32BitConstants)(self.0, root_parameter_index, (mem::size_of_val(src_data)/4) as UINT, src_data.as_ptr() as *const _, dest_offset_in32_bit_values) };
    ()
  }
  
  //  Method SetGraphicsRoot32BitConstants
  
  pub fn set_graphics_root32_bit_constants<T>(&self, root_parameter_index: UINT, src_data: &[T], dest_offset_in32_bit_values: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRoot32BitConstants)(self.0, root_parameter_index, (mem::size_of_val(src_data)/4) as UINT, src_data.as_ptr() as *const _, dest_offset_in32_bit_values) };
    ()
  }
  
  //  Method SetComputeRootConstantBufferView
  
  pub fn set_compute_root_constant_buffer_view(&self, root_parameter_index: UINT, buffer_location: D3D12_GPU_VIRTUAL_ADDRESS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRootConstantBufferView)(self.0, root_parameter_index, buffer_location) };
    ()
  }
  
  //  Method SetGraphicsRootConstantBufferView
  
  pub fn set_graphics_root_constant_buffer_view(&self, root_parameter_index: UINT, buffer_location: D3D12_GPU_VIRTUAL_ADDRESS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRootConstantBufferView)(self.0, root_parameter_index, buffer_location) };
    ()
  }
  
  //  Method SetComputeRootShaderResourceView
  
  pub fn set_compute_root_shader_resource_view(&self, root_parameter_index: UINT, buffer_location: D3D12_GPU_VIRTUAL_ADDRESS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRootShaderResourceView)(self.0, root_parameter_index, buffer_location) };
    ()
  }
  
  //  Method SetGraphicsRootShaderResourceView
  
  pub fn set_graphics_root_shader_resource_view(&self, root_parameter_index: UINT, buffer_location: D3D12_GPU_VIRTUAL_ADDRESS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRootShaderResourceView)(self.0, root_parameter_index, buffer_location) };
    ()
  }
  
  //  Method SetComputeRootUnorderedAccessView
  
  pub fn set_compute_root_unordered_access_view(&self, root_parameter_index: UINT, buffer_location: D3D12_GPU_VIRTUAL_ADDRESS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetComputeRootUnorderedAccessView)(self.0, root_parameter_index, buffer_location) };
    ()
  }
  
  //  Method SetGraphicsRootUnorderedAccessView
  
  pub fn set_graphics_root_unordered_access_view(&self, root_parameter_index: UINT, buffer_location: D3D12_GPU_VIRTUAL_ADDRESS) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGraphicsRootUnorderedAccessView)(self.0, root_parameter_index, buffer_location) };
    ()
  }
  
  //  Method IASetIndexBuffer
  
  pub fn ia_set_index_buffer(&self, view: Option<&D3D12_INDEX_BUFFER_VIEW>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IASetIndexBuffer)(self.0, view.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    ()
  }
  
  //  Method IASetVertexBuffers
  
  pub fn ia_set_vertex_buffers(&self, start_slot: UINT, views: Option<&mut [D3D12_VERTEX_BUFFER_VIEW]>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IASetVertexBuffers)(self.0, start_slot,  same_length(&[views.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, opt_arr_as_mut_ptr(&views) as *mut _) };
    ()
  }
  
  //  Method SOSetTargets
  
  pub fn so_set_targets(&self, start_slot: UINT, views: Option<&mut [D3D12_STREAM_OUTPUT_BUFFER_VIEW]>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SOSetTargets)(self.0, start_slot,  same_length(&[views.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, opt_arr_as_mut_ptr(&views) as *mut _) };
    ()
  }
  
  //  Method OMSetRenderTargets
  
  pub fn om_set_render_targets(&self, num_render_target_descriptors: UINT, render_target_descriptors: &D3D12_CPU_DESCRIPTOR_HANDLE, depth_stencil_descriptor: Option<&D3D12_CPU_DESCRIPTOR_HANDLE>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).OMSetRenderTargets)(self.0, num_render_target_descriptors, render_target_descriptors, TRUE, depth_stencil_descriptor.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    ()
  }
  
  
  pub fn om_set_render_targets_arr(&self, render_target_descriptors: &mut [D3D12_CPU_DESCRIPTOR_HANDLE], depth_stencil_descriptor: Option<&D3D12_CPU_DESCRIPTOR_HANDLE>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).OMSetRenderTargets)(self.0,  same_length(&[Some(render_target_descriptors.len())]).expect("Arrays must have equal sizes") as UINT, render_target_descriptors.as_mut_ptr() as *mut _, FALSE, depth_stencil_descriptor.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    ()
  }
  
  //  Method ClearDepthStencilView
  
  pub fn clear_depth_stencil_view(&self, depth_stencil_view: D3D12_CPU_DESCRIPTOR_HANDLE, clear_flags: D3D12_CLEAR_FLAGS, depth: FLOAT, stencil: UINT8, rects: &mut [D3D12_RECT]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearDepthStencilView)(self.0, depth_stencil_view, clear_flags, depth, stencil,  same_length(&[Some(rects.len())]).expect("Arrays must have equal sizes") as UINT, rects.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method ClearRenderTargetView
  
  pub fn clear_render_target_view(&self, render_target_view: D3D12_CPU_DESCRIPTOR_HANDLE, color_r_g_b_a: &mut [FLOAT;4], rects: &mut [D3D12_RECT]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearRenderTargetView)(self.0, render_target_view, color_r_g_b_a,  same_length(&[Some(rects.len())]).expect("Arrays must have equal sizes") as UINT, rects.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method ClearUnorderedAccessViewUint
  
  pub fn clear_unordered_access_view_uint<T: HasIID>(&self, view_gpu_handle_in_current_heap: D3D12_GPU_DESCRIPTOR_HANDLE, view_cpu_handle: D3D12_CPU_DESCRIPTOR_HANDLE, resource: &T, values: &mut [UINT;4], rects: &mut [D3D12_RECT]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearUnorderedAccessViewUint)(self.0, view_gpu_handle_in_current_heap, view_cpu_handle, resource.iptr() as *mut _ as *mut _ , values,  same_length(&[Some(rects.len())]).expect("Arrays must have equal sizes") as UINT, rects.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method ClearUnorderedAccessViewFloat
  
  pub fn clear_unordered_access_view_float<T: HasIID>(&self, view_gpu_handle_in_current_heap: D3D12_GPU_DESCRIPTOR_HANDLE, view_cpu_handle: D3D12_CPU_DESCRIPTOR_HANDLE, resource: &T, values: &mut [FLOAT;4], rects: &mut [D3D12_RECT]) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearUnorderedAccessViewFloat)(self.0, view_gpu_handle_in_current_heap, view_cpu_handle, resource.iptr() as *mut _ as *mut _ , values,  same_length(&[Some(rects.len())]).expect("Arrays must have equal sizes") as UINT, rects.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method DiscardResource
  
  pub fn discard_resource<T: HasIID>(&self, resource: &T, region: Option<&D3D12_DISCARD_REGION>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).DiscardResource)(self.0, resource.iptr() as *mut _ as *mut _ , region.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    ()
  }
  
  //  Method BeginQuery
  
  pub fn begin_query<T: HasIID>(&self, query_heap: &T, type_: D3D12_QUERY_TYPE, index: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).BeginQuery)(self.0, query_heap.iptr() as *mut _ as *mut _ , type_, index) };
    ()
  }
  
  //  Method EndQuery
  
  pub fn end_query<T: HasIID>(&self, query_heap: &T, type_: D3D12_QUERY_TYPE, index: UINT) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).EndQuery)(self.0, query_heap.iptr() as *mut _ as *mut _ , type_, index) };
    ()
  }
  
  //  Method ResolveQueryData
  
  pub fn resolve_query_data<T: HasIID, T1: HasIID>(&self, query_heap: &T, type_: D3D12_QUERY_TYPE, start_index: UINT, num_queries: UINT, destination_buffer: &T1, aligned_destination_buffer_offset: UINT64) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResolveQueryData)(self.0, query_heap.iptr() as *mut _ as *mut _ , type_, start_index, num_queries, destination_buffer.iptr() as *mut _ as *mut _ , aligned_destination_buffer_offset) };
    ()
  }
  
  //  Method SetPredication
  
  pub fn set_predication(&self, buffer: Option<&D3D12Resource>, aligned_buffer_offset: UINT64, operation: D3D12_PREDICATION_OP) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPredication)(self.0, buffer.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, aligned_buffer_offset, operation) };
    ()
  }
  
  //  Method ExecuteIndirect
  
  pub fn execute_indirect<T: HasIID, T1: HasIID, T2: HasIID>(&self, command_signature: &T, max_command_count: UINT, argument_buffer: &T1, argument_buffer_offset: UINT64, count_buffer: &T2, count_buffer_offset: UINT64) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ExecuteIndirect)(self.0, command_signature.iptr() as *mut _ as *mut _ , max_command_count, argument_buffer.iptr() as *mut _ as *mut _ , argument_buffer_offset, count_buffer.iptr() as *mut _ as *mut _ , count_buffer_offset) };
    ()
  }
  
  
}

pub struct D3D12Heap(*mut ID3D12Heap);

impl HasIID for D3D12Heap {
  fn iid() -> &'static IID { &IID_ID3D12Heap }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Heap(pp_vtbl as *mut _ as *mut ID3D12Heap) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Heap {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Heap {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Heap {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> D3D12_HEAP_DESC {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0) };
    hr
  }
  
  
}

pub struct D3D12InfoQueue(*mut ID3D12InfoQueue);

impl HasIID for D3D12InfoQueue {
  fn iid() -> &'static IID { &IID_ID3D12InfoQueue }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12InfoQueue(pp_vtbl as *mut _ as *mut ID3D12InfoQueue) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12InfoQueue {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12InfoQueue {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12InfoQueue {
  //  Method SetMessageCountLimit
  
  pub fn set_message_count_limit(&self, message_count_limit: UINT64) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMessageCountLimit)(self.0, message_count_limit) };
    hr2ret(hr,())
  }
  
  //  Method ClearStoredMessages
  
  pub fn clear_stored_messages(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearStoredMessages)(self.0) };
    ()
  }
  
  //  Method GetMessage
  
  pub fn get_message(&self, message_index: UINT64, message: Option<&mut D3D12_MESSAGE>, message_byte_length: &mut SIZE_T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMessage)(self.0, message_index, opt_as_mut_ptr(&message), message_byte_length) };
    hr2ret(hr,())
  }
  
  //  Method GetNumMessagesAllowedByStorageFilter
  
  pub fn get_num_messages_allowed_by_storage_filter(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetNumMessagesAllowedByStorageFilter)(self.0) };
    hr
  }
  
  //  Method GetNumMessagesDeniedByStorageFilter
  
  pub fn get_num_messages_denied_by_storage_filter(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetNumMessagesDeniedByStorageFilter)(self.0) };
    hr
  }
  
  //  Method GetNumStoredMessages
  
  pub fn get_num_stored_messages(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetNumStoredMessages)(self.0) };
    hr
  }
  
  //  Method GetNumStoredMessagesAllowedByRetrievalFilter
  
  pub fn get_num_stored_messages_allowed_by_retrieval_filter(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetNumStoredMessagesAllowedByRetrievalFilter)(self.0) };
    hr
  }
  
  //  Method GetNumMessagesDiscardedByMessageCountLimit
  
  pub fn get_num_messages_discarded_by_message_count_limit(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetNumMessagesDiscardedByMessageCountLimit)(self.0) };
    hr
  }
  
  //  Method GetMessageCountLimit
  
  pub fn get_message_count_limit(&self) -> UINT64 {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMessageCountLimit)(self.0) };
    hr
  }
  
  //  Method AddStorageFilterEntries
  
  pub fn add_storage_filter_entries(&self, filter: &mut D3D12_INFO_QUEUE_FILTER) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).AddStorageFilterEntries)(self.0, filter) };
    hr2ret(hr,())
  }
  
  //  Method GetStorageFilter
  
  pub fn get_storage_filter(&self, filter: &mut D3D12_INFO_QUEUE_FILTER, filter_byte_length: &mut SIZE_T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetStorageFilter)(self.0, filter, filter_byte_length) };
    hr2ret(hr,())
  }
  
  //  Method ClearStorageFilter
  
  pub fn clear_storage_filter(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearStorageFilter)(self.0) };
    ()
  }
  
  //  Method PushEmptyStorageFilter
  
  pub fn push_empty_storage_filter(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PushEmptyStorageFilter)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method PushCopyOfStorageFilter
  
  pub fn push_copy_of_storage_filter(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PushCopyOfStorageFilter)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method PushStorageFilter
  
  pub fn push_storage_filter(&self, filter: &mut D3D12_INFO_QUEUE_FILTER) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PushStorageFilter)(self.0, filter) };
    hr2ret(hr,())
  }
  
  //  Method PopStorageFilter
  
  pub fn pop_storage_filter(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PopStorageFilter)(self.0) };
    ()
  }
  
  //  Method GetStorageFilterStackSize
  
  pub fn get_storage_filter_stack_size(&self) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetStorageFilterStackSize)(self.0) };
    hr
  }
  
  //  Method AddRetrievalFilterEntries
  
  pub fn add_retrieval_filter_entries(&self, filter: &mut D3D12_INFO_QUEUE_FILTER) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).AddRetrievalFilterEntries)(self.0, filter) };
    hr2ret(hr,())
  }
  
  //  Method GetRetrievalFilter
  
  pub fn get_retrieval_filter(&self, filter: &mut D3D12_INFO_QUEUE_FILTER, filter_byte_length: &mut SIZE_T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRetrievalFilter)(self.0, filter, filter_byte_length) };
    hr2ret(hr,())
  }
  
  //  Method ClearRetrievalFilter
  
  pub fn clear_retrieval_filter(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ClearRetrievalFilter)(self.0) };
    ()
  }
  
  //  Method PushEmptyRetrievalFilter
  
  pub fn push_empty_retrieval_filter(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PushEmptyRetrievalFilter)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method PushCopyOfRetrievalFilter
  
  pub fn push_copy_of_retrieval_filter(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PushCopyOfRetrievalFilter)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method PushRetrievalFilter
  
  pub fn push_retrieval_filter(&self, filter: &mut D3D12_INFO_QUEUE_FILTER) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PushRetrievalFilter)(self.0, filter) };
    hr2ret(hr,())
  }
  
  //  Method PopRetrievalFilter
  
  pub fn pop_retrieval_filter(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PopRetrievalFilter)(self.0) };
    ()
  }
  
  //  Method GetRetrievalFilterStackSize
  
  pub fn get_retrieval_filter_stack_size(&self) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRetrievalFilterStackSize)(self.0) };
    hr
  }
  
  //  Method AddMessage
  
  pub fn add_message(&self, category: D3D12_MESSAGE_CATEGORY, severity: D3D12_MESSAGE_SEVERITY, i_d: D3D12_MESSAGE_ID, description: LPCSTR) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).AddMessage)(self.0, category, severity, i_d, description) };
    hr2ret(hr,())
  }
  
  //  Method AddApplicationMessage
  
  pub fn add_application_message(&self, severity: D3D12_MESSAGE_SEVERITY, description: LPCSTR) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).AddApplicationMessage)(self.0, severity, description) };
    hr2ret(hr,())
  }
  
  //  Method SetBreakOnCategory
  
  pub fn set_break_on_category(&self, category: D3D12_MESSAGE_CATEGORY, bEnable: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetBreakOnCategory)(self.0, category, bEnable) };
    hr2ret(hr,())
  }
  
  //  Method SetBreakOnSeverity
  
  pub fn set_break_on_severity(&self, severity: D3D12_MESSAGE_SEVERITY, bEnable: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetBreakOnSeverity)(self.0, severity, bEnable) };
    hr2ret(hr,())
  }
  
  //  Method SetBreakOnID
  
  pub fn set_break_on_id(&self, i_d: D3D12_MESSAGE_ID, bEnable: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetBreakOnID)(self.0, i_d, bEnable) };
    hr2ret(hr,())
  }
  
  //  Method GetBreakOnCategory
  
  pub fn get_break_on_category(&self, category: D3D12_MESSAGE_CATEGORY) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBreakOnCategory)(self.0, category) };
    hr
  }
  
  //  Method GetBreakOnSeverity
  
  pub fn get_break_on_severity(&self, severity: D3D12_MESSAGE_SEVERITY) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBreakOnSeverity)(self.0, severity) };
    hr
  }
  
  //  Method GetBreakOnID
  
  pub fn get_break_on_id(&self, i_d: D3D12_MESSAGE_ID) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBreakOnID)(self.0, i_d) };
    hr
  }
  
  //  Method SetMuteDebugOutput
  
  pub fn set_mute_debug_output(&self, bMute: BOOL) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMuteDebugOutput)(self.0, bMute) };
    ()
  }
  
  //  Method GetMuteDebugOutput
  
  pub fn get_mute_debug_output(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMuteDebugOutput)(self.0) };
    hr
  }
  
  
}

pub struct D3D12Object(*mut ID3D12Object);

impl HasIID for D3D12Object {
  fn iid() -> &'static IID { &IID_ID3D12Object }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Object(pp_vtbl as *mut _ as *mut ID3D12Object) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Object {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Object {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Object {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  
}

pub struct D3D12Pageable(*mut ID3D12Pageable);

impl HasIID for D3D12Pageable {
  fn iid() -> &'static IID { &IID_ID3D12Pageable }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Pageable(pp_vtbl as *mut _ as *mut ID3D12Pageable) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Pageable {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Pageable {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Pageable {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct D3D12PipelineState(*mut ID3D12PipelineState);

impl HasIID for D3D12PipelineState {
  fn iid() -> &'static IID { &IID_ID3D12PipelineState }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12PipelineState(pp_vtbl as *mut _ as *mut ID3D12PipelineState) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12PipelineState {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12PipelineState {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12PipelineState {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct D3D12QueryHeap(*mut ID3D12QueryHeap);

impl HasIID for D3D12QueryHeap {
  fn iid() -> &'static IID { &IID_ID3D12QueryHeap }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12QueryHeap(pp_vtbl as *mut _ as *mut ID3D12QueryHeap) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12QueryHeap {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12QueryHeap {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12QueryHeap {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct D3D12Resource(*mut ID3D12Resource);

impl HasIID for D3D12Resource {
  fn iid() -> &'static IID { &IID_ID3D12Resource }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12Resource(pp_vtbl as *mut _ as *mut ID3D12Resource) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12Resource {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12Resource {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12Resource {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Map
  
  pub unsafe fn map(&self, subresource: UINT, read_range: Option<&D3D12_RANGE>) -> HResult<*mut ()> {
    let mut lv1: *mut () = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).Map)(self.0, subresource, read_range.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method Unmap
  
  pub fn unmap(&self, subresource: UINT, written_range: Option<&D3D12_RANGE>) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Unmap)(self.0, subresource, written_range.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    ()
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> D3D12_RESOURCE_DESC {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0) };
    hr
  }
  
  //  Method GetGPUVirtualAddress
  
  pub fn get_gpu_virtual_address(&self) -> D3D12_GPU_VIRTUAL_ADDRESS {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGPUVirtualAddress)(self.0) };
    hr
  }
  
  //  Method GetHeapProperties
  
  pub fn get_heap_properties(&self, heap_properties: Option<&mut D3D12_HEAP_PROPERTIES>, heap_flags: Option<&mut D3D12_HEAP_FLAGS>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetHeapProperties)(self.0, opt_as_mut_ptr(&heap_properties), opt_as_mut_ptr(&heap_flags)) };
    hr2ret(hr,())
  }
  
  
}

pub struct D3D12RootSignatureDeserializer(*mut ID3D12RootSignatureDeserializer);

impl HasIID for D3D12RootSignatureDeserializer {
  fn iid() -> &'static IID { &IID_ID3D12RootSignatureDeserializer }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12RootSignatureDeserializer(pp_vtbl as *mut _ as *mut ID3D12RootSignatureDeserializer) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12RootSignatureDeserializer {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12RootSignatureDeserializer {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12RootSignatureDeserializer {
  //  Method GetRootSignatureDesc
  
  pub fn get_root_signature_desc(&self) -> *const D3D12_ROOT_SIGNATURE_DESC {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRootSignatureDesc)(self.0) };
    hr
  }
  
  
}

pub struct D3D12RootSignature(*mut ID3D12RootSignature);

impl HasIID for D3D12RootSignature {
  fn iid() -> &'static IID { &IID_ID3D12RootSignature }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D3D12RootSignature(pp_vtbl as *mut _ as *mut ID3D12RootSignature) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for D3D12RootSignature {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D3D12RootSignature {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl D3D12RootSignature {
  //  Method GetPrivateData
  
  pub unsafe fn get_private_data<T>(&self, guid: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, guid, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, guid: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, guid, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method SetName
  
  pub fn set_name(&self, name: Cow<str>) -> HResult<()> {
    let lv1: Vec<u16> = str_to_vec_u16(name);
    let hr=unsafe { ((*(*self.0).lpVtbl).SetName)(self.0, lv1.as_ptr() as LPCWSTR) };
    hr2ret(hr,())
  }
  
  //  Method GetDevice
  
  pub fn get_device<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDevice)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct DXGIAdapter1(*mut IDXGIAdapter1);

impl HasIID for DXGIAdapter1 {
  fn iid() -> &'static IID { &IID_IDXGIAdapter1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIAdapter1(pp_vtbl as *mut _ as *mut IDXGIAdapter1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIAdapter1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIAdapter1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIAdapter1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumOutputs
  
  pub fn enum_outputs(&self, output: UINT) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumOutputs)(self.0, output, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_ADAPTER_DESC> {
    let mut lv1: DXGI_ADAPTER_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CheckInterfaceSupport
  
  pub fn check_interface_support(&self, interface_name: REFGUID) -> HResult<LARGE_INTEGER> {
    let mut lv1: LARGE_INTEGER = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckInterfaceSupport)(self.0, interface_name, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc1
  
  pub fn get_desc1(&self) -> HResult<DXGI_ADAPTER_DESC1> {
    let mut lv1: DXGI_ADAPTER_DESC1 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc1)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIAdapter2(*mut IDXGIAdapter2);

impl HasIID for DXGIAdapter2 {
  fn iid() -> &'static IID { &IID_IDXGIAdapter2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIAdapter2(pp_vtbl as *mut _ as *mut IDXGIAdapter2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIAdapter2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIAdapter2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIAdapter2 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumOutputs
  
  pub fn enum_outputs(&self, output: UINT) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumOutputs)(self.0, output, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_ADAPTER_DESC> {
    let mut lv1: DXGI_ADAPTER_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CheckInterfaceSupport
  
  pub fn check_interface_support(&self, interface_name: REFGUID) -> HResult<LARGE_INTEGER> {
    let mut lv1: LARGE_INTEGER = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckInterfaceSupport)(self.0, interface_name, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc1
  
  pub fn get_desc1(&self) -> HResult<DXGI_ADAPTER_DESC1> {
    let mut lv1: DXGI_ADAPTER_DESC1 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc1)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc2
  
  pub fn get_desc2(&self) -> HResult<DXGI_ADAPTER_DESC2> {
    let mut lv1: DXGI_ADAPTER_DESC2 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc2)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIAdapter3(*mut IDXGIAdapter3);

impl HasIID for DXGIAdapter3 {
  fn iid() -> &'static IID { &IID_IDXGIAdapter3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIAdapter3(pp_vtbl as *mut _ as *mut IDXGIAdapter3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIAdapter3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIAdapter3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIAdapter3 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumOutputs
  
  pub fn enum_outputs(&self, output: UINT) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumOutputs)(self.0, output, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_ADAPTER_DESC> {
    let mut lv1: DXGI_ADAPTER_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CheckInterfaceSupport
  
  pub fn check_interface_support(&self, interface_name: REFGUID) -> HResult<LARGE_INTEGER> {
    let mut lv1: LARGE_INTEGER = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckInterfaceSupport)(self.0, interface_name, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc1
  
  pub fn get_desc1(&self) -> HResult<DXGI_ADAPTER_DESC1> {
    let mut lv1: DXGI_ADAPTER_DESC1 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc1)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc2
  
  pub fn get_desc2(&self) -> HResult<DXGI_ADAPTER_DESC2> {
    let mut lv1: DXGI_ADAPTER_DESC2 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc2)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterHardwareContentProtectionTeardownStatusEvent
  
  pub fn register_hardware_content_protection_teardown_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterHardwareContentProtectionTeardownStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterHardwareContentProtectionTeardownStatus
  
  pub fn unregister_hardware_content_protection_teardown_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterHardwareContentProtectionTeardownStatus)(self.0, cookie) };
    ()
  }
  
  //  Method QueryVideoMemoryInfo
  
  pub fn query_video_memory_info(&self, node_index: UINT, memory_segment_group: DXGI_MEMORY_SEGMENT_GROUP) -> HResult<DXGI_QUERY_VIDEO_MEMORY_INFO> {
    let mut lv1: DXGI_QUERY_VIDEO_MEMORY_INFO = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).QueryVideoMemoryInfo)(self.0, node_index, memory_segment_group, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetVideoMemoryReservation
  
  pub fn set_video_memory_reservation(&self, node_index: UINT, memory_segment_group: DXGI_MEMORY_SEGMENT_GROUP, reservation: UINT64) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetVideoMemoryReservation)(self.0, node_index, memory_segment_group, reservation) };
    hr2ret(hr,())
  }
  
  //  Method RegisterVideoMemoryBudgetChangeNotificationEvent
  
  pub fn register_video_memory_budget_change_notification_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterVideoMemoryBudgetChangeNotificationEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterVideoMemoryBudgetChangeNotification
  
  pub fn unregister_video_memory_budget_change_notification(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterVideoMemoryBudgetChangeNotification)(self.0, cookie) };
    ()
  }
  
  
}

pub struct DXGIAdapter(*mut IDXGIAdapter);

impl HasIID for DXGIAdapter {
  fn iid() -> &'static IID { &IID_IDXGIAdapter }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIAdapter(pp_vtbl as *mut _ as *mut IDXGIAdapter) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIAdapter {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIAdapter {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIAdapter {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumOutputs
  
  pub fn enum_outputs(&self, output: UINT) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumOutputs)(self.0, output, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_ADAPTER_DESC> {
    let mut lv1: DXGI_ADAPTER_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CheckInterfaceSupport
  
  pub fn check_interface_support(&self, interface_name: REFGUID) -> HResult<LARGE_INTEGER> {
    let mut lv1: LARGE_INTEGER = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckInterfaceSupport)(self.0, interface_name, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIDecodeSwapChain(*mut IDXGIDecodeSwapChain);

impl HasIID for DXGIDecodeSwapChain {
  fn iid() -> &'static IID { &IID_IDXGIDecodeSwapChain }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDecodeSwapChain(pp_vtbl as *mut _ as *mut IDXGIDecodeSwapChain) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDecodeSwapChain {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDecodeSwapChain {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDecodeSwapChain {
  //  Method PresentBuffer
  
  pub fn present_buffer(&self, buffer_to_present: UINT, sync_interval: UINT, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).PresentBuffer)(self.0, buffer_to_present, sync_interval, flags) };
    hr2ret(hr,())
  }
  
  //  Method SetSourceRect
  
  pub fn set_source_rect(&self, rect: &RECT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetSourceRect)(self.0, rect) };
    hr2ret(hr,())
  }
  
  //  Method SetTargetRect
  
  pub fn set_target_rect(&self, rect: &RECT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetTargetRect)(self.0, rect) };
    hr2ret(hr,())
  }
  
  //  Method SetDestSize
  
  pub fn set_dest_size(&self, width: UINT, height: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDestSize)(self.0, width, height) };
    hr2ret(hr,())
  }
  
  //  Method GetSourceRect
  
  pub fn get_source_rect(&self) -> HResult<RECT> {
    let mut lv1: RECT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSourceRect)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetTargetRect
  
  pub fn get_target_rect(&self) -> HResult<RECT> {
    let mut lv1: RECT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetTargetRect)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDestSize
  
  pub fn get_dest_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDestSize)(self.0, &mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetColorSpace
  
  pub fn set_color_space(&self, color_space: DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetColorSpace)(self.0, color_space) };
    hr2ret(hr,())
  }
  
  //  Method GetColorSpace
  
  pub fn get_color_space(&self) -> DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetColorSpace)(self.0) };
    hr
  }
  
  
}

pub struct DXGIDevice1(*mut IDXGIDevice1);

impl HasIID for DXGIDevice1 {
  fn iid() -> &'static IID { &IID_IDXGIDevice1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDevice1(pp_vtbl as *mut _ as *mut IDXGIDevice1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDevice1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDevice1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDevice1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetAdapter
  
  pub fn get_adapter(&self) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetAdapter)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method QueryResourceResidency
  
  pub fn query_resource_residency<T: HasIID>(&self, resources: &[&T], residency_status: &mut [DXGI_RESIDENCY]) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).QueryResourceResidency)(self.0, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, residency_status.as_mut_ptr() as *mut _,  same_length(&[Some(resources.len()),Some(residency_status.len())]).expect("Arrays must have equal sizes") as UINT) };
    hr2ret(hr,())
  }
  
  //  Method SetGPUThreadPriority
  
  pub fn set_gpu_thread_priority(&self, priority: INT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGPUThreadPriority)(self.0, priority) };
    hr2ret(hr,())
  }
  
  //  Method GetGPUThreadPriority
  
  pub fn get_gpu_thread_priority(&self) -> HResult<INT> {
    let mut lv1: INT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGPUThreadPriority)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMaximumFrameLatency)(self.0, max_latency) };
    hr2ret(hr,())
  }
  
  //  Method GetMaximumFrameLatency
  
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMaximumFrameLatency)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIDevice2(*mut IDXGIDevice2);

impl HasIID for DXGIDevice2 {
  fn iid() -> &'static IID { &IID_IDXGIDevice2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDevice2(pp_vtbl as *mut _ as *mut IDXGIDevice2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDevice2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDevice2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDevice2 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetAdapter
  
  pub fn get_adapter(&self) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetAdapter)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method QueryResourceResidency
  
  pub fn query_resource_residency<T: HasIID>(&self, resources: &[&T], residency_status: &mut [DXGI_RESIDENCY]) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).QueryResourceResidency)(self.0, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, residency_status.as_mut_ptr() as *mut _,  same_length(&[Some(resources.len()),Some(residency_status.len())]).expect("Arrays must have equal sizes") as UINT) };
    hr2ret(hr,())
  }
  
  //  Method SetGPUThreadPriority
  
  pub fn set_gpu_thread_priority(&self, priority: INT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGPUThreadPriority)(self.0, priority) };
    hr2ret(hr,())
  }
  
  //  Method GetGPUThreadPriority
  
  pub fn get_gpu_thread_priority(&self) -> HResult<INT> {
    let mut lv1: INT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGPUThreadPriority)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMaximumFrameLatency)(self.0, max_latency) };
    hr2ret(hr,())
  }
  
  //  Method GetMaximumFrameLatency
  
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMaximumFrameLatency)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method OfferResources
  
  pub fn offer_resources<T: HasIID>(&self, resources: &[&T], priority: DXGI_OFFER_RESOURCE_PRIORITY) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).OfferResources)(self.0,  same_length(&[Some(resources.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, priority) };
    hr2ret(hr,())
  }
  
  //  Method ReclaimResources
  
  pub fn reclaim_resources<T: HasIID>(&self, resources: &[&T], discarded: Option<&mut [BOOL]>) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).ReclaimResources)(self.0,  same_length(&[Some(resources.len()),discarded.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, opt_arr_as_mut_ptr(&discarded) as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method EnqueueSetEvent
  
  pub fn enqueue_set_event(&self, hEvent: HANDLE) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).EnqueueSetEvent)(self.0, hEvent) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGIDevice3(*mut IDXGIDevice3);

impl HasIID for DXGIDevice3 {
  fn iid() -> &'static IID { &IID_IDXGIDevice3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDevice3(pp_vtbl as *mut _ as *mut IDXGIDevice3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDevice3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDevice3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDevice3 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetAdapter
  
  pub fn get_adapter(&self) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetAdapter)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method QueryResourceResidency
  
  pub fn query_resource_residency<T: HasIID>(&self, resources: &[&T], residency_status: &mut [DXGI_RESIDENCY]) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).QueryResourceResidency)(self.0, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, residency_status.as_mut_ptr() as *mut _,  same_length(&[Some(resources.len()),Some(residency_status.len())]).expect("Arrays must have equal sizes") as UINT) };
    hr2ret(hr,())
  }
  
  //  Method SetGPUThreadPriority
  
  pub fn set_gpu_thread_priority(&self, priority: INT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGPUThreadPriority)(self.0, priority) };
    hr2ret(hr,())
  }
  
  //  Method GetGPUThreadPriority
  
  pub fn get_gpu_thread_priority(&self) -> HResult<INT> {
    let mut lv1: INT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGPUThreadPriority)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMaximumFrameLatency)(self.0, max_latency) };
    hr2ret(hr,())
  }
  
  //  Method GetMaximumFrameLatency
  
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMaximumFrameLatency)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method OfferResources
  
  pub fn offer_resources<T: HasIID>(&self, resources: &[&T], priority: DXGI_OFFER_RESOURCE_PRIORITY) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).OfferResources)(self.0,  same_length(&[Some(resources.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, priority) };
    hr2ret(hr,())
  }
  
  //  Method ReclaimResources
  
  pub fn reclaim_resources<T: HasIID>(&self, resources: &[&T], discarded: Option<&mut [BOOL]>) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).ReclaimResources)(self.0,  same_length(&[Some(resources.len()),discarded.as_ref().map(|a|a.len())]).expect("Arrays must have equal sizes") as UINT, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, opt_arr_as_mut_ptr(&discarded) as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method EnqueueSetEvent
  
  pub fn enqueue_set_event(&self, hEvent: HANDLE) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).EnqueueSetEvent)(self.0, hEvent) };
    hr2ret(hr,())
  }
  
  //  Method Trim
  
  pub fn trim(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Trim)(self.0) };
    ()
  }
  
  
}

pub struct DXGIDeviceSubObject(*mut IDXGIDeviceSubObject);

impl HasIID for DXGIDeviceSubObject {
  fn iid() -> &'static IID { &IID_IDXGIDeviceSubObject }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDeviceSubObject(pp_vtbl as *mut _ as *mut IDXGIDeviceSubObject) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDeviceSubObject {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDeviceSubObject {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDeviceSubObject {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct DXGIDevice(*mut IDXGIDevice);

impl HasIID for DXGIDevice {
  fn iid() -> &'static IID { &IID_IDXGIDevice }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDevice(pp_vtbl as *mut _ as *mut IDXGIDevice) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDevice {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDevice {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDevice {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetAdapter
  
  pub fn get_adapter(&self) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetAdapter)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method QueryResourceResidency
  
  pub fn query_resource_residency<T: HasIID>(&self, resources: &[&T], residency_status: &mut [DXGI_RESIDENCY]) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = resources.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).QueryResourceResidency)(self.0, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, residency_status.as_mut_ptr() as *mut _,  same_length(&[Some(resources.len()),Some(residency_status.len())]).expect("Arrays must have equal sizes") as UINT) };
    hr2ret(hr,())
  }
  
  //  Method SetGPUThreadPriority
  
  pub fn set_gpu_thread_priority(&self, priority: INT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGPUThreadPriority)(self.0, priority) };
    hr2ret(hr,())
  }
  
  //  Method GetGPUThreadPriority
  
  pub fn get_gpu_thread_priority(&self) -> HResult<INT> {
    let mut lv1: INT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGPUThreadPriority)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIDisplayControl(*mut IDXGIDisplayControl);

impl HasIID for DXGIDisplayControl {
  fn iid() -> &'static IID { &IID_IDXGIDisplayControl }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIDisplayControl(pp_vtbl as *mut _ as *mut IDXGIDisplayControl) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIDisplayControl {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIDisplayControl {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIDisplayControl {
  //  Method IsStereoEnabled
  
  pub fn is_stereo_enabled(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsStereoEnabled)(self.0) };
    hr
  }
  
  //  Method SetStereoEnabled
  
  pub fn set_stereo_enabled(&self, enabled: BOOL) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetStereoEnabled)(self.0, enabled) };
    ()
  }
  
  
}

pub struct DXGIFactory1(*mut IDXGIFactory1);

impl HasIID for DXGIFactory1 {
  fn iid() -> &'static IID { &IID_IDXGIFactory1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactory1(pp_vtbl as *mut _ as *mut IDXGIFactory1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIFactory1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactory1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIFactory1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumAdapters
  
  pub fn enum_adapters(&self, adapter: UINT) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method MakeWindowAssociation
  
  pub fn make_window_association(&self, window_handle: HWND, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).MakeWindowAssociation)(self.0, window_handle, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetWindowAssociation
  
  pub fn get_window_association(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetWindowAssociation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CreateSwapChain
  
  pub fn create_swap_chain<T: HasIID>(&self, device: &T, desc: &mut DXGI_SWAP_CHAIN_DESC) -> HResult<DXGISwapChain> {
    let mut lv1: *mut IDXGISwapChain = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChain)(self.0, device.iptr() as *mut _ as *mut _ , desc, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain::new(lv1 as *mut _))
  }
  
  //  Method CreateSoftwareAdapter
  
  pub fn create_software_adapter(&self, module: HMODULE) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSoftwareAdapter)(self.0, module, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method EnumAdapters1
  
  pub fn enum_adapters1(&self, adapter: UINT) -> HResult<DXGIAdapter1> {
    let mut lv1: *mut IDXGIAdapter1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters1)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter1::new(lv1 as *mut _))
  }
  
  //  Method IsCurrent
  
  pub fn is_current(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsCurrent)(self.0) };
    hr
  }
  
  
}

pub struct DXGIFactory2(*mut IDXGIFactory2);

impl HasIID for DXGIFactory2 {
  fn iid() -> &'static IID { &IID_IDXGIFactory2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactory2(pp_vtbl as *mut _ as *mut IDXGIFactory2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIFactory2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactory2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIFactory2 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumAdapters
  
  pub fn enum_adapters(&self, adapter: UINT) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method MakeWindowAssociation
  
  pub fn make_window_association(&self, window_handle: HWND, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).MakeWindowAssociation)(self.0, window_handle, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetWindowAssociation
  
  pub fn get_window_association(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetWindowAssociation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CreateSwapChain
  
  pub fn create_swap_chain<T: HasIID>(&self, device: &T, desc: &mut DXGI_SWAP_CHAIN_DESC) -> HResult<DXGISwapChain> {
    let mut lv1: *mut IDXGISwapChain = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChain)(self.0, device.iptr() as *mut _ as *mut _ , desc, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain::new(lv1 as *mut _))
  }
  
  //  Method CreateSoftwareAdapter
  
  pub fn create_software_adapter(&self, module: HMODULE) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSoftwareAdapter)(self.0, module, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method EnumAdapters1
  
  pub fn enum_adapters1(&self, adapter: UINT) -> HResult<DXGIAdapter1> {
    let mut lv1: *mut IDXGIAdapter1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters1)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter1::new(lv1 as *mut _))
  }
  
  //  Method IsCurrent
  
  pub fn is_current(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsCurrent)(self.0) };
    hr
  }
  
  //  Method IsWindowedStereoEnabled
  
  pub fn is_windowed_stereo_enabled(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsWindowedStereoEnabled)(self.0) };
    hr
  }
  
  //  Method CreateSwapChainForHwnd
  
  pub fn create_swap_chain_for_hwnd<T: HasIID>(&self, device: &T, hWnd: HWND, desc: &DXGI_SWAP_CHAIN_DESC1, fullscreen_desc: Option<&DXGI_SWAP_CHAIN_FULLSCREEN_DESC>, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForHwnd)(self.0, device.iptr() as *mut _ as *mut _ , hWnd, desc, fullscreen_desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method CreateSwapChainForCoreWindow
  
  pub fn create_swap_chain_for_core_window<T: HasIID, T1: HasIID>(&self, device: &T, window: &T1, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForCoreWindow)(self.0, device.iptr() as *mut _ as *mut _ , window.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetSharedResourceAdapterLuid
  
  pub fn get_shared_resource_adapter_luid(&self, hResource: HANDLE) -> HResult<LUID> {
    let mut lv1: LUID = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSharedResourceAdapterLuid)(self.0, hResource, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterStereoStatusWindow
  
  pub fn register_stereo_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterStereoStatusWindow)(self.0, window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterStereoStatusEvent
  
  pub fn register_stereo_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterStereoStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterStereoStatus
  
  pub fn unregister_stereo_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterStereoStatus)(self.0, cookie) };
    ()
  }
  
  //  Method RegisterOcclusionStatusWindow
  
  pub fn register_occlusion_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterOcclusionStatusWindow)(self.0, window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterOcclusionStatusEvent
  
  pub fn register_occlusion_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterOcclusionStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterOcclusionStatus
  
  pub fn unregister_occlusion_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterOcclusionStatus)(self.0, cookie) };
    ()
  }
  
  //  Method CreateSwapChainForComposition
  
  pub fn create_swap_chain_for_composition<T: HasIID>(&self, device: &T, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForComposition)(self.0, device.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  
}

pub struct DXGIFactory3(*mut IDXGIFactory3);

impl HasIID for DXGIFactory3 {
  fn iid() -> &'static IID { &IID_IDXGIFactory3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactory3(pp_vtbl as *mut _ as *mut IDXGIFactory3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIFactory3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactory3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIFactory3 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumAdapters
  
  pub fn enum_adapters(&self, adapter: UINT) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method MakeWindowAssociation
  
  pub fn make_window_association(&self, window_handle: HWND, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).MakeWindowAssociation)(self.0, window_handle, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetWindowAssociation
  
  pub fn get_window_association(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetWindowAssociation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CreateSwapChain
  
  pub fn create_swap_chain<T: HasIID>(&self, device: &T, desc: &mut DXGI_SWAP_CHAIN_DESC) -> HResult<DXGISwapChain> {
    let mut lv1: *mut IDXGISwapChain = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChain)(self.0, device.iptr() as *mut _ as *mut _ , desc, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain::new(lv1 as *mut _))
  }
  
  //  Method CreateSoftwareAdapter
  
  pub fn create_software_adapter(&self, module: HMODULE) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSoftwareAdapter)(self.0, module, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method EnumAdapters1
  
  pub fn enum_adapters1(&self, adapter: UINT) -> HResult<DXGIAdapter1> {
    let mut lv1: *mut IDXGIAdapter1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters1)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter1::new(lv1 as *mut _))
  }
  
  //  Method IsCurrent
  
  pub fn is_current(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsCurrent)(self.0) };
    hr
  }
  
  //  Method IsWindowedStereoEnabled
  
  pub fn is_windowed_stereo_enabled(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsWindowedStereoEnabled)(self.0) };
    hr
  }
  
  //  Method CreateSwapChainForHwnd
  
  pub fn create_swap_chain_for_hwnd<T: HasIID>(&self, device: &T, hWnd: HWND, desc: &DXGI_SWAP_CHAIN_DESC1, fullscreen_desc: Option<&DXGI_SWAP_CHAIN_FULLSCREEN_DESC>, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForHwnd)(self.0, device.iptr() as *mut _ as *mut _ , hWnd, desc, fullscreen_desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method CreateSwapChainForCoreWindow
  
  pub fn create_swap_chain_for_core_window<T: HasIID, T1: HasIID>(&self, device: &T, window: &T1, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForCoreWindow)(self.0, device.iptr() as *mut _ as *mut _ , window.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetSharedResourceAdapterLuid
  
  pub fn get_shared_resource_adapter_luid(&self, hResource: HANDLE) -> HResult<LUID> {
    let mut lv1: LUID = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSharedResourceAdapterLuid)(self.0, hResource, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterStereoStatusWindow
  
  pub fn register_stereo_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterStereoStatusWindow)(self.0, window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterStereoStatusEvent
  
  pub fn register_stereo_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterStereoStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterStereoStatus
  
  pub fn unregister_stereo_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterStereoStatus)(self.0, cookie) };
    ()
  }
  
  //  Method RegisterOcclusionStatusWindow
  
  pub fn register_occlusion_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterOcclusionStatusWindow)(self.0, window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterOcclusionStatusEvent
  
  pub fn register_occlusion_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterOcclusionStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterOcclusionStatus
  
  pub fn unregister_occlusion_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterOcclusionStatus)(self.0, cookie) };
    ()
  }
  
  //  Method CreateSwapChainForComposition
  
  pub fn create_swap_chain_for_composition<T: HasIID>(&self, device: &T, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForComposition)(self.0, device.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetCreationFlags
  
  pub fn get_creation_flags(&self) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCreationFlags)(self.0) };
    hr
  }
  
  
}

pub struct DXGIFactory4(*mut IDXGIFactory4);

impl HasIID for DXGIFactory4 {
  fn iid() -> &'static IID { &IID_IDXGIFactory4 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactory4(pp_vtbl as *mut _ as *mut IDXGIFactory4) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIFactory4 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactory4 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIFactory4 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumAdapters
  
  pub fn enum_adapters(&self, adapter: UINT) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method MakeWindowAssociation
  
  pub fn make_window_association(&self, window_handle: HWND, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).MakeWindowAssociation)(self.0, window_handle, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetWindowAssociation
  
  pub fn get_window_association(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetWindowAssociation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CreateSwapChain
  
  pub fn create_swap_chain<T: HasIID>(&self, device: &T, desc: &mut DXGI_SWAP_CHAIN_DESC) -> HResult<DXGISwapChain> {
    let mut lv1: *mut IDXGISwapChain = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChain)(self.0, device.iptr() as *mut _ as *mut _ , desc, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain::new(lv1 as *mut _))
  }
  
  //  Method CreateSoftwareAdapter
  
  pub fn create_software_adapter(&self, module: HMODULE) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSoftwareAdapter)(self.0, module, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method EnumAdapters1
  
  pub fn enum_adapters1(&self, adapter: UINT) -> HResult<DXGIAdapter1> {
    let mut lv1: *mut IDXGIAdapter1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters1)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter1::new(lv1 as *mut _))
  }
  
  //  Method IsCurrent
  
  pub fn is_current(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsCurrent)(self.0) };
    hr
  }
  
  //  Method IsWindowedStereoEnabled
  
  pub fn is_windowed_stereo_enabled(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsWindowedStereoEnabled)(self.0) };
    hr
  }
  
  //  Method CreateSwapChainForHwnd
  
  pub fn create_swap_chain_for_hwnd<T: HasIID>(&self, device: &T, hWnd: HWND, desc: &DXGI_SWAP_CHAIN_DESC1, fullscreen_desc: Option<&DXGI_SWAP_CHAIN_FULLSCREEN_DESC>, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForHwnd)(self.0, device.iptr() as *mut _ as *mut _ , hWnd, desc, fullscreen_desc.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method CreateSwapChainForCoreWindow
  
  pub fn create_swap_chain_for_core_window<T: HasIID, T1: HasIID>(&self, device: &T, window: &T1, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForCoreWindow)(self.0, device.iptr() as *mut _ as *mut _ , window.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetSharedResourceAdapterLuid
  
  pub fn get_shared_resource_adapter_luid(&self, hResource: HANDLE) -> HResult<LUID> {
    let mut lv1: LUID = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSharedResourceAdapterLuid)(self.0, hResource, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterStereoStatusWindow
  
  pub fn register_stereo_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterStereoStatusWindow)(self.0, window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterStereoStatusEvent
  
  pub fn register_stereo_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterStereoStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterStereoStatus
  
  pub fn unregister_stereo_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterStereoStatus)(self.0, cookie) };
    ()
  }
  
  //  Method RegisterOcclusionStatusWindow
  
  pub fn register_occlusion_status_window(&self, window_handle: HWND, wMsg: UINT) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterOcclusionStatusWindow)(self.0, window_handle, wMsg, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method RegisterOcclusionStatusEvent
  
  pub fn register_occlusion_status_event(&self, hEvent: HANDLE) -> HResult<DWORD> {
    let mut lv1: DWORD = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).RegisterOcclusionStatusEvent)(self.0, hEvent, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnregisterOcclusionStatus
  
  pub fn unregister_occlusion_status(&self, cookie: DWORD) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnregisterOcclusionStatus)(self.0, cookie) };
    ()
  }
  
  //  Method CreateSwapChainForComposition
  
  pub fn create_swap_chain_for_composition<T: HasIID>(&self, device: &T, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForComposition)(self.0, device.iptr() as *mut _ as *mut _ , desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method GetCreationFlags
  
  pub fn get_creation_flags(&self) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCreationFlags)(self.0) };
    hr
  }
  
  //  Method EnumAdapterByLuid
  
  pub fn enum_adapter_by_luid<T: HasIID>(&self, adapter_luid: LUID) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapterByLuid)(self.0, adapter_luid, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumWarpAdapter
  
  pub fn enum_warp_adapter<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumWarpAdapter)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct DXGIFactoryMedia(*mut IDXGIFactoryMedia);

impl HasIID for DXGIFactoryMedia {
  fn iid() -> &'static IID { &IID_IDXGIFactoryMedia }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactoryMedia(pp_vtbl as *mut _ as *mut IDXGIFactoryMedia) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIFactoryMedia {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactoryMedia {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIFactoryMedia {
  //  Method CreateSwapChainForCompositionSurfaceHandle
  
  pub fn create_swap_chain_for_composition_surface_handle<T: HasIID>(&self, device: &T, hSurface: HANDLE, desc: &DXGI_SWAP_CHAIN_DESC1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGISwapChain1> {
    let mut lv1: *mut IDXGISwapChain1 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChainForCompositionSurfaceHandle)(self.0, device.iptr() as *mut _ as *mut _ , hSurface, desc, restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain1::new(lv1 as *mut _))
  }
  
  //  Method CreateDecodeSwapChainForCompositionSurfaceHandle
  
  pub fn create_decode_swap_chain_for_composition_surface_handle<T: HasIID, T1: HasIID>(&self, device: &T, hSurface: HANDLE, desc: &mut DXGI_DECODE_SWAP_CHAIN_DESC, yuv_decode_buffers: &T1, restrict_to_output: Option<&DXGIOutput>) -> HResult<DXGIDecodeSwapChain> {
    let mut lv1: *mut IDXGIDecodeSwapChain = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateDecodeSwapChainForCompositionSurfaceHandle)(self.0, device.iptr() as *mut _ as *mut _ , hSurface, desc, yuv_decode_buffers.iptr() as *mut _ as *mut _ , restrict_to_output.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIDecodeSwapChain::new(lv1 as *mut _))
  }
  
  
}

pub struct DXGIFactory(*mut IDXGIFactory);

impl HasIID for DXGIFactory {
  fn iid() -> &'static IID { &IID_IDXGIFactory }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIFactory(pp_vtbl as *mut _ as *mut IDXGIFactory) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIFactory {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIFactory {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIFactory {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method EnumAdapters
  
  pub fn enum_adapters(&self, adapter: UINT) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).EnumAdapters)(self.0, adapter, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  //  Method MakeWindowAssociation
  
  pub fn make_window_association(&self, window_handle: HWND, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).MakeWindowAssociation)(self.0, window_handle, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetWindowAssociation
  
  pub fn get_window_association(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetWindowAssociation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CreateSwapChain
  
  pub fn create_swap_chain<T: HasIID>(&self, device: &T, desc: &mut DXGI_SWAP_CHAIN_DESC) -> HResult<DXGISwapChain> {
    let mut lv1: *mut IDXGISwapChain = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSwapChain)(self.0, device.iptr() as *mut _ as *mut _ , desc, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISwapChain::new(lv1 as *mut _))
  }
  
  //  Method CreateSoftwareAdapter
  
  pub fn create_software_adapter(&self, module: HMODULE) -> HResult<DXGIAdapter> {
    let mut lv1: *mut IDXGIAdapter = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSoftwareAdapter)(self.0, module, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIAdapter::new(lv1 as *mut _))
  }
  
  
}

pub struct DXGIKeyedMutex(*mut IDXGIKeyedMutex);

impl HasIID for DXGIKeyedMutex {
  fn iid() -> &'static IID { &IID_IDXGIKeyedMutex }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIKeyedMutex(pp_vtbl as *mut _ as *mut IDXGIKeyedMutex) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIKeyedMutex {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIKeyedMutex {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIKeyedMutex {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method AcquireSync
  
  pub fn acquire_sync(&self, key: UINT64, milliseconds: DWORD) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).AcquireSync)(self.0, key, milliseconds) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseSync
  
  pub fn release_sync(&self, key: UINT64) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseSync)(self.0, key) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGIObject(*mut IDXGIObject);

impl HasIID for DXGIObject {
  fn iid() -> &'static IID { &IID_IDXGIObject }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIObject(pp_vtbl as *mut _ as *mut IDXGIObject) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIObject {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIObject {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIObject {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct DXGIOutput1(*mut IDXGIOutput1);

impl HasIID for DXGIOutput1 {
  fn iid() -> &'static IID { &IID_IDXGIOutput1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput1(pp_vtbl as *mut _ as *mut IDXGIOutput1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIOutput1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIOutput1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplayModeList)(self.0, enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode)(self.0, mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  pub fn wait_for_v_blank(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).WaitForVBlank)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method TakeOwnership
  
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).TakeOwnership)(self.0, device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseOwnership
  
  pub fn release_ownership(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseOwnership)(self.0) };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControlCapabilities)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetGammaControl
  
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGammaControl)(self.0, array) };
    hr2ret(hr,())
  }
  
  //  Method GetGammaControl
  
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControl)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDisplaySurface)(self.0, scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData
  
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList1
  //  Error: pNumModes parameter: OutOptionalOfSize shouldn't have references. But references are [("pDesc", OutOptionalArrayOfSize "pNumModes", Ptr (StructRef "DXGI_MODE_DESC1"))]
  //  Method FindClosestMatchingMode1
  
  pub fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode1)(self.0, mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData1
  
  pub fn get_display_surface_data1<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData1)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method DuplicateOutput
  
  pub fn duplicate_output<T: HasIID>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).DuplicateOutput)(self.0, device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  
}

pub struct DXGIOutput2(*mut IDXGIOutput2);

impl HasIID for DXGIOutput2 {
  fn iid() -> &'static IID { &IID_IDXGIOutput2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput2(pp_vtbl as *mut _ as *mut IDXGIOutput2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIOutput2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIOutput2 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplayModeList)(self.0, enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode)(self.0, mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  pub fn wait_for_v_blank(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).WaitForVBlank)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method TakeOwnership
  
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).TakeOwnership)(self.0, device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseOwnership
  
  pub fn release_ownership(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseOwnership)(self.0) };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControlCapabilities)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetGammaControl
  
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGammaControl)(self.0, array) };
    hr2ret(hr,())
  }
  
  //  Method GetGammaControl
  
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControl)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDisplaySurface)(self.0, scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData
  
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList1
  //  Error: pNumModes parameter: OutOptionalOfSize shouldn't have references. But references are [("pDesc", OutOptionalArrayOfSize "pNumModes", Ptr (StructRef "DXGI_MODE_DESC1"))]
  //  Method FindClosestMatchingMode1
  
  pub fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode1)(self.0, mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData1
  
  pub fn get_display_surface_data1<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData1)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method DuplicateOutput
  
  pub fn duplicate_output<T: HasIID>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).DuplicateOutput)(self.0, device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  //  Method SupportsOverlays
  
  pub fn supports_overlays(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SupportsOverlays)(self.0) };
    hr
  }
  
  
}

pub struct DXGIOutput3(*mut IDXGIOutput3);

impl HasIID for DXGIOutput3 {
  fn iid() -> &'static IID { &IID_IDXGIOutput3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput3(pp_vtbl as *mut _ as *mut IDXGIOutput3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIOutput3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIOutput3 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplayModeList)(self.0, enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode)(self.0, mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  pub fn wait_for_v_blank(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).WaitForVBlank)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method TakeOwnership
  
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).TakeOwnership)(self.0, device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseOwnership
  
  pub fn release_ownership(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseOwnership)(self.0) };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControlCapabilities)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetGammaControl
  
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGammaControl)(self.0, array) };
    hr2ret(hr,())
  }
  
  //  Method GetGammaControl
  
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControl)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDisplaySurface)(self.0, scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData
  
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList1
  //  Error: pNumModes parameter: OutOptionalOfSize shouldn't have references. But references are [("pDesc", OutOptionalArrayOfSize "pNumModes", Ptr (StructRef "DXGI_MODE_DESC1"))]
  //  Method FindClosestMatchingMode1
  
  pub fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode1)(self.0, mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData1
  
  pub fn get_display_surface_data1<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData1)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method DuplicateOutput
  
  pub fn duplicate_output<T: HasIID>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).DuplicateOutput)(self.0, device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  //  Method SupportsOverlays
  
  pub fn supports_overlays(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SupportsOverlays)(self.0) };
    hr
  }
  
  //  Method CheckOverlaySupport
  
  pub fn check_overlay_support<T: HasIID>(&self, enum_format: DXGI_FORMAT, concerned_device: &T) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckOverlaySupport)(self.0, enum_format, concerned_device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIOutput4(*mut IDXGIOutput4);

impl HasIID for DXGIOutput4 {
  fn iid() -> &'static IID { &IID_IDXGIOutput4 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput4(pp_vtbl as *mut _ as *mut IDXGIOutput4) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIOutput4 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput4 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIOutput4 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplayModeList)(self.0, enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode)(self.0, mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  pub fn wait_for_v_blank(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).WaitForVBlank)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method TakeOwnership
  
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).TakeOwnership)(self.0, device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseOwnership
  
  pub fn release_ownership(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseOwnership)(self.0) };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControlCapabilities)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetGammaControl
  
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGammaControl)(self.0, array) };
    hr2ret(hr,())
  }
  
  //  Method GetGammaControl
  
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControl)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDisplaySurface)(self.0, scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData
  
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList1
  //  Error: pNumModes parameter: OutOptionalOfSize shouldn't have references. But references are [("pDesc", OutOptionalArrayOfSize "pNumModes", Ptr (StructRef "DXGI_MODE_DESC1"))]
  //  Method FindClosestMatchingMode1
  
  pub fn find_closest_matching_mode1(&self, mode_to_match: &DXGI_MODE_DESC1, closest_match: &mut DXGI_MODE_DESC1, concerned_device: Option<&Unknown>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode1)(self.0, mode_to_match, closest_match, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData1
  
  pub fn get_display_surface_data1<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData1)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method DuplicateOutput
  
  pub fn duplicate_output<T: HasIID>(&self, device: &T) -> HResult<DXGIOutputDuplication> {
    let mut lv1: *mut IDXGIOutputDuplication = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).DuplicateOutput)(self.0, device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutputDuplication::new(lv1 as *mut _))
  }
  
  //  Method SupportsOverlays
  
  pub fn supports_overlays(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SupportsOverlays)(self.0) };
    hr
  }
  
  //  Method CheckOverlaySupport
  
  pub fn check_overlay_support<T: HasIID>(&self, enum_format: DXGI_FORMAT, concerned_device: &T) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckOverlaySupport)(self.0, enum_format, concerned_device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CheckOverlayColorSpaceSupport
  
  pub fn check_overlay_color_space_support<T: HasIID>(&self, format: DXGI_FORMAT, color_space: DXGI_COLOR_SPACE_TYPE, concerned_device: &T) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckOverlayColorSpaceSupport)(self.0, format, color_space, concerned_device.iptr() as *mut _ as *mut _ , &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIOutputDuplication(*mut IDXGIOutputDuplication);

impl HasIID for DXGIOutputDuplication {
  fn iid() -> &'static IID { &IID_IDXGIOutputDuplication }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutputDuplication(pp_vtbl as *mut _ as *mut IDXGIOutputDuplication) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIOutputDuplication {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutputDuplication {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIOutputDuplication {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> DXGI_OUTDUPL_DESC {
    let mut lv1: DXGI_OUTDUPL_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method AcquireNextFrame
  
  pub fn acquire_next_frame(&self, timeout_in_milliseconds: UINT, frame_info: &mut DXGI_OUTDUPL_FRAME_INFO) -> HResult<DXGIResource> {
    let mut lv1: *mut IDXGIResource = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).AcquireNextFrame)(self.0, timeout_in_milliseconds, frame_info, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIResource::new(lv1 as *mut _))
  }
  
  //  Method GetFrameDirtyRects
  
  pub fn get_frame_dirty_rects(&self, dirty_rects_buffer: &mut [RECT], dirty_rects_buffer_size_required: &mut UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameDirtyRects)(self.0, (mem::size_of_val(dirty_rects_buffer)/1) as UINT, dirty_rects_buffer.as_mut_ptr() as *mut _, dirty_rects_buffer_size_required) };
    hr2ret(hr,())
  }
  
  //  Method GetFrameMoveRects
  
  pub fn get_frame_move_rects(&self, move_rect_buffer: &mut [DXGI_OUTDUPL_MOVE_RECT], move_rects_buffer_size_required: &mut UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameMoveRects)(self.0, (mem::size_of_val(move_rect_buffer)/1) as UINT, move_rect_buffer.as_mut_ptr() as *mut _, move_rects_buffer_size_required) };
    hr2ret(hr,())
  }
  
  //  Method GetFramePointerShape
  
  pub fn get_frame_pointer_shape<T>(&self, pointer_shape_buffer: &mut [T], pointer_shape_buffer_size_required: &mut UINT, pointer_shape_info: &mut DXGI_OUTDUPL_POINTER_SHAPE_INFO) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFramePointerShape)(self.0, (mem::size_of_val(pointer_shape_buffer)/1) as UINT, pointer_shape_buffer.as_mut_ptr() as *mut _, pointer_shape_buffer_size_required, pointer_shape_info) };
    hr2ret(hr,())
  }
  
  //  Method MapDesktopSurface
  
  pub fn map_desktop_surface(&self) -> HResult<DXGI_MAPPED_RECT> {
    let mut lv1: DXGI_MAPPED_RECT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).MapDesktopSurface)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method UnMapDesktopSurface
  
  pub fn un_map_desktop_surface(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).UnMapDesktopSurface)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseFrame
  
  pub fn release_frame(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseFrame)(self.0) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGIOutput(*mut IDXGIOutput);

impl HasIID for DXGIOutput {
  fn iid() -> &'static IID { &IID_IDXGIOutput }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIOutput(pp_vtbl as *mut _ as *mut IDXGIOutput) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIOutput {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIOutput {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIOutput {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_OUTPUT_DESC> {
    let mut lv1: DXGI_OUTPUT_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDisplayModeList
  
  pub fn get_display_mode_list(&self, enum_format: DXGI_FORMAT, flags: UINT, desc: Option<&mut [DXGI_MODE_DESC]>) -> HResult<UINT> {
    let mut lv1: UINT = desc.as_ref().map(|v|v.len()).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplayModeList)(self.0, enum_format, flags, &mut lv1, opt_arr_as_mut_ptr(&desc) as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method FindClosestMatchingMode
  
  pub fn find_closest_matching_mode(&self, mode_to_match: &DXGI_MODE_DESC, concerned_device: Option<&Unknown>) -> HResult<DXGI_MODE_DESC> {
    let mut lv1: DXGI_MODE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).FindClosestMatchingMode)(self.0, mode_to_match, &mut lv1 as *mut _ as *mut _, concerned_device.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method WaitForVBlank
  
  pub fn wait_for_v_blank(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).WaitForVBlank)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method TakeOwnership
  
  pub fn take_ownership<T: HasIID>(&self, device: &T, exclusive: BOOL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).TakeOwnership)(self.0, device.iptr() as *mut _ as *mut _ , exclusive) };
    hr2ret(hr,())
  }
  
  //  Method ReleaseOwnership
  
  pub fn release_ownership(&self) -> () {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseOwnership)(self.0) };
    ()
  }
  
  //  Method GetGammaControlCapabilities
  
  pub fn get_gamma_control_capabilities(&self) -> HResult<DXGI_GAMMA_CONTROL_CAPABILITIES> {
    let mut lv1: DXGI_GAMMA_CONTROL_CAPABILITIES = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControlCapabilities)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetGammaControl
  
  pub fn set_gamma_control(&self, array: &DXGI_GAMMA_CONTROL) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetGammaControl)(self.0, array) };
    hr2ret(hr,())
  }
  
  //  Method GetGammaControl
  
  pub fn get_gamma_control(&self) -> HResult<DXGI_GAMMA_CONTROL> {
    let mut lv1: DXGI_GAMMA_CONTROL = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetGammaControl)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetDisplaySurface
  
  pub fn set_display_surface<T: HasIID>(&self, scanout_surface: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetDisplaySurface)(self.0, scanout_surface.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetDisplaySurfaceData
  
  pub fn get_display_surface_data<T: HasIID>(&self, destination: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDisplaySurfaceData)(self.0, destination.iptr() as *mut _ as *mut _ ) };
    hr2ret(hr,())
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGIResource1(*mut IDXGIResource1);

impl HasIID for DXGIResource1 {
  fn iid() -> &'static IID { &IID_IDXGIResource1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIResource1(pp_vtbl as *mut _ as *mut IDXGIResource1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIResource1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIResource1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIResource1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetSharedHandle
  
  pub fn get_shared_handle(&self) -> HResult<HANDLE> {
    let mut lv1: HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSharedHandle)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetUsage
  
  pub fn get_usage(&self) -> HResult<DXGI_USAGE> {
    let mut lv1: DXGI_USAGE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetUsage)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetEvictionPriority
  
  pub fn set_eviction_priority(&self, eviction_priority: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetEvictionPriority)(self.0, eviction_priority) };
    hr2ret(hr,())
  }
  
  //  Method GetEvictionPriority
  
  pub fn get_eviction_priority(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetEvictionPriority)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method CreateSubresourceSurface
  
  pub fn create_subresource_surface(&self, index: UINT) -> HResult<DXGISurface2> {
    let mut lv1: *mut IDXGISurface2 = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSubresourceSurface)(self.0, index, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGISurface2::new(lv1 as *mut _))
  }
  
  //  Method CreateSharedHandle
  
  pub fn create_shared_handle(&self, attributes: Option<&SECURITY_ATTRIBUTES>, access: DWORD, lpName: Cow<str>) -> HResult<HANDLE> {
    let lv1: Vec<u16> = str_to_vec_u16(lpName);
    let mut lv2: HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CreateSharedHandle)(self.0, attributes.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), access, lv1.as_ptr() as LPCWSTR, &mut lv2 as *mut _ as *mut _) };
    hr2ret(hr,lv2)
  }
  
  
}

pub struct DXGIResource(*mut IDXGIResource);

impl HasIID for DXGIResource {
  fn iid() -> &'static IID { &IID_IDXGIResource }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGIResource(pp_vtbl as *mut _ as *mut IDXGIResource) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGIResource {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGIResource {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGIResource {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetSharedHandle
  
  pub fn get_shared_handle(&self) -> HResult<HANDLE> {
    let mut lv1: HANDLE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSharedHandle)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetUsage
  
  pub fn get_usage(&self) -> HResult<DXGI_USAGE> {
    let mut lv1: DXGI_USAGE = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetUsage)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetEvictionPriority
  
  pub fn set_eviction_priority(&self, eviction_priority: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetEvictionPriority)(self.0, eviction_priority) };
    hr2ret(hr,())
  }
  
  //  Method GetEvictionPriority
  
  pub fn get_eviction_priority(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetEvictionPriority)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGISurface1(*mut IDXGISurface1);

impl HasIID for DXGISurface1 {
  fn iid() -> &'static IID { &IID_IDXGISurface1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISurface1(pp_vtbl as *mut _ as *mut IDXGISurface1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISurface1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISurface1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISurface1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SURFACE_DESC> {
    let mut lv1: DXGI_SURFACE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method Map
  
  pub fn map(&self, map_flags: UINT) -> HResult<DXGI_MAPPED_RECT> {
    let mut lv1: DXGI_MAPPED_RECT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).Map)(self.0, &mut lv1 as *mut _ as *mut _, map_flags) };
    hr2ret(hr,lv1)
  }
  
  //  Method Unmap
  
  pub fn unmap(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Unmap)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method GetDC
  
  pub fn get_d_c(&self, discard: BOOL) -> HResult<HDC> {
    let mut lv1: HDC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDC)(self.0, discard, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method ReleaseDC
  
  pub fn release_d_c(&self, dirty_rect: Option<&mut RECT>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseDC)(self.0, opt_as_mut_ptr(&dirty_rect)) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGISurface2(*mut IDXGISurface2);

impl HasIID for DXGISurface2 {
  fn iid() -> &'static IID { &IID_IDXGISurface2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISurface2(pp_vtbl as *mut _ as *mut IDXGISurface2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISurface2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISurface2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISurface2 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SURFACE_DESC> {
    let mut lv1: DXGI_SURFACE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method Map
  
  pub fn map(&self, map_flags: UINT) -> HResult<DXGI_MAPPED_RECT> {
    let mut lv1: DXGI_MAPPED_RECT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).Map)(self.0, &mut lv1 as *mut _ as *mut _, map_flags) };
    hr2ret(hr,lv1)
  }
  
  //  Method Unmap
  
  pub fn unmap(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Unmap)(self.0) };
    hr2ret(hr,())
  }
  
  //  Method GetDC
  
  pub fn get_d_c(&self, discard: BOOL) -> HResult<HDC> {
    let mut lv1: HDC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDC)(self.0, discard, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method ReleaseDC
  
  pub fn release_d_c(&self, dirty_rect: Option<&mut RECT>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ReleaseDC)(self.0, opt_as_mut_ptr(&dirty_rect)) };
    hr2ret(hr,())
  }
  
  //  Method GetResource
  
  pub fn get_resource<T: HasIID>(&self, subresource_index: &mut UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetResource)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void, subresource_index) };
    hr2ret(hr,T::new(lv1))
  }
  
  
}

pub struct DXGISurface(*mut IDXGISurface);

impl HasIID for DXGISurface {
  fn iid() -> &'static IID { &IID_IDXGISurface }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISurface(pp_vtbl as *mut _ as *mut IDXGISurface) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISurface {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISurface {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISurface {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SURFACE_DESC> {
    let mut lv1: DXGI_SURFACE_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method Map
  
  pub fn map(&self, map_flags: UINT) -> HResult<DXGI_MAPPED_RECT> {
    let mut lv1: DXGI_MAPPED_RECT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).Map)(self.0, &mut lv1 as *mut _ as *mut _, map_flags) };
    hr2ret(hr,lv1)
  }
  
  //  Method Unmap
  
  pub fn unmap(&self) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Unmap)(self.0) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGISwapChain1(*mut IDXGISwapChain1);

impl HasIID for DXGISwapChain1 {
  fn iid() -> &'static IID { &IID_IDXGISwapChain1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChain1(pp_vtbl as *mut _ as *mut IDXGISwapChain1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISwapChain1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChain1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISwapChain1 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present
  
  pub fn present(&self, sync_interval: UINT, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present)(self.0, sync_interval, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetBuffer
  
  pub fn get_buffer<T: HasIID>(&self, buffer: UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBuffer)(self.0, buffer, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method SetFullscreenState
  
  pub fn set_fullscreen_state(&self, fullscreen: BOOL, target: Option<&DXGIOutput>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetFullscreenState)(self.0, fullscreen, target.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetFullscreenState
  //  Error: ppTarget parameter: ANone annotation cannot be used with double indirection
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SWAP_CHAIN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method ResizeBuffers
  
  pub fn resize_buffers(&self, buffer_count: UINT, width: UINT, height: UINT, new_format: DXGI_FORMAT, swap_chain_flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeBuffers)(self.0, buffer_count, width, height, new_format, swap_chain_flags) };
    hr2ret(hr,())
  }
  
  //  Method ResizeTarget
  
  pub fn resize_target(&self, new_target_parameters: &DXGI_MODE_DESC) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeTarget)(self.0, new_target_parameters) };
    hr2ret(hr,())
  }
  
  //  Method GetContainingOutput
  
  pub fn get_containing_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetContainingOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetLastPresentCount
  
  pub fn get_last_present_count(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetLastPresentCount)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc1
  
  pub fn get_desc1(&self) -> HResult<DXGI_SWAP_CHAIN_DESC1> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC1 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc1)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetFullscreenDesc
  
  pub fn get_fullscreen_desc(&self) -> HResult<DXGI_SWAP_CHAIN_FULLSCREEN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_FULLSCREEN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFullscreenDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetHwnd
  
  pub fn get_hwnd(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetHwnd)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetCoreWindow
  
  pub fn get_core_window<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCoreWindow)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present1
  
  pub fn present1(&self, sync_interval: UINT, present_flags: UINT, present_parameters: &DXGI_PRESENT_PARAMETERS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present1)(self.0, sync_interval, present_flags, present_parameters) };
    hr2ret(hr,())
  }
  
  //  Method IsTemporaryMonoSupported
  
  pub fn is_temporary_mono_supported(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsTemporaryMonoSupported)(self.0) };
    hr
  }
  
  //  Method GetRestrictToOutput
  
  pub fn get_restrict_to_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRestrictToOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method SetBackgroundColor
  
  pub fn set_background_color(&self, color: &DXGI_RGBA) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetBackgroundColor)(self.0, color) };
    hr2ret(hr,())
  }
  
  //  Method GetBackgroundColor
  
  pub fn get_background_color(&self) -> HResult<DXGI_RGBA> {
    let mut lv1: DXGI_RGBA = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBackgroundColor)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetRotation
  
  pub fn set_rotation(&self, rotation: DXGI_MODE_ROTATION) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetRotation)(self.0, rotation) };
    hr2ret(hr,())
  }
  
  //  Method GetRotation
  
  pub fn get_rotation(&self) -> HResult<DXGI_MODE_ROTATION> {
    let mut lv1: DXGI_MODE_ROTATION = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRotation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGISwapChain2(*mut IDXGISwapChain2);

impl HasIID for DXGISwapChain2 {
  fn iid() -> &'static IID { &IID_IDXGISwapChain2 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChain2(pp_vtbl as *mut _ as *mut IDXGISwapChain2) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISwapChain2 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChain2 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISwapChain2 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present
  
  pub fn present(&self, sync_interval: UINT, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present)(self.0, sync_interval, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetBuffer
  
  pub fn get_buffer<T: HasIID>(&self, buffer: UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBuffer)(self.0, buffer, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method SetFullscreenState
  
  pub fn set_fullscreen_state(&self, fullscreen: BOOL, target: Option<&DXGIOutput>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetFullscreenState)(self.0, fullscreen, target.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetFullscreenState
  //  Error: ppTarget parameter: ANone annotation cannot be used with double indirection
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SWAP_CHAIN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method ResizeBuffers
  
  pub fn resize_buffers(&self, buffer_count: UINT, width: UINT, height: UINT, new_format: DXGI_FORMAT, swap_chain_flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeBuffers)(self.0, buffer_count, width, height, new_format, swap_chain_flags) };
    hr2ret(hr,())
  }
  
  //  Method ResizeTarget
  
  pub fn resize_target(&self, new_target_parameters: &DXGI_MODE_DESC) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeTarget)(self.0, new_target_parameters) };
    hr2ret(hr,())
  }
  
  //  Method GetContainingOutput
  
  pub fn get_containing_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetContainingOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetLastPresentCount
  
  pub fn get_last_present_count(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetLastPresentCount)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc1
  
  pub fn get_desc1(&self) -> HResult<DXGI_SWAP_CHAIN_DESC1> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC1 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc1)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetFullscreenDesc
  
  pub fn get_fullscreen_desc(&self) -> HResult<DXGI_SWAP_CHAIN_FULLSCREEN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_FULLSCREEN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFullscreenDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetHwnd
  
  pub fn get_hwnd(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetHwnd)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetCoreWindow
  
  pub fn get_core_window<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCoreWindow)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present1
  
  pub fn present1(&self, sync_interval: UINT, present_flags: UINT, present_parameters: &DXGI_PRESENT_PARAMETERS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present1)(self.0, sync_interval, present_flags, present_parameters) };
    hr2ret(hr,())
  }
  
  //  Method IsTemporaryMonoSupported
  
  pub fn is_temporary_mono_supported(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsTemporaryMonoSupported)(self.0) };
    hr
  }
  
  //  Method GetRestrictToOutput
  
  pub fn get_restrict_to_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRestrictToOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method SetBackgroundColor
  
  pub fn set_background_color(&self, color: &DXGI_RGBA) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetBackgroundColor)(self.0, color) };
    hr2ret(hr,())
  }
  
  //  Method GetBackgroundColor
  
  pub fn get_background_color(&self) -> HResult<DXGI_RGBA> {
    let mut lv1: DXGI_RGBA = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBackgroundColor)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetRotation
  
  pub fn set_rotation(&self, rotation: DXGI_MODE_ROTATION) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetRotation)(self.0, rotation) };
    hr2ret(hr,())
  }
  
  //  Method GetRotation
  
  pub fn get_rotation(&self) -> HResult<DXGI_MODE_ROTATION> {
    let mut lv1: DXGI_MODE_ROTATION = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRotation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetSourceSize
  
  pub fn set_source_size(&self, width: UINT, height: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetSourceSize)(self.0, width, height) };
    hr2ret(hr,())
  }
  
  //  Method GetSourceSize
  
  pub fn get_source_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSourceSize)(self.0, &mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMaximumFrameLatency)(self.0, max_latency) };
    hr2ret(hr,())
  }
  
  //  Method GetMaximumFrameLatency
  
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMaximumFrameLatency)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetFrameLatencyWaitableObject
  
  pub fn get_frame_latency_waitable_object(&self) -> HANDLE {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameLatencyWaitableObject)(self.0) };
    hr
  }
  
  //  Method SetMatrixTransform
  
  pub fn set_matrix_transform(&self, matrix: &DXGI_MATRIX_3X2_F) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMatrixTransform)(self.0, matrix) };
    hr2ret(hr,())
  }
  
  //  Method GetMatrixTransform
  
  pub fn get_matrix_transform(&self) -> HResult<DXGI_MATRIX_3X2_F> {
    let mut lv1: DXGI_MATRIX_3X2_F = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMatrixTransform)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

pub struct DXGISwapChain3(*mut IDXGISwapChain3);

impl HasIID for DXGISwapChain3 {
  fn iid() -> &'static IID { &IID_IDXGISwapChain3 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChain3(pp_vtbl as *mut _ as *mut IDXGISwapChain3) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISwapChain3 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChain3 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISwapChain3 {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present
  
  pub fn present(&self, sync_interval: UINT, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present)(self.0, sync_interval, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetBuffer
  
  pub fn get_buffer<T: HasIID>(&self, buffer: UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBuffer)(self.0, buffer, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method SetFullscreenState
  
  pub fn set_fullscreen_state(&self, fullscreen: BOOL, target: Option<&DXGIOutput>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetFullscreenState)(self.0, fullscreen, target.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetFullscreenState
  //  Error: ppTarget parameter: ANone annotation cannot be used with double indirection
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SWAP_CHAIN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method ResizeBuffers
  
  pub fn resize_buffers(&self, buffer_count: UINT, width: UINT, height: UINT, new_format: DXGI_FORMAT, swap_chain_flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeBuffers)(self.0, buffer_count, width, height, new_format, swap_chain_flags) };
    hr2ret(hr,())
  }
  
  //  Method ResizeTarget
  
  pub fn resize_target(&self, new_target_parameters: &DXGI_MODE_DESC) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeTarget)(self.0, new_target_parameters) };
    hr2ret(hr,())
  }
  
  //  Method GetContainingOutput
  
  pub fn get_containing_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetContainingOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetLastPresentCount
  
  pub fn get_last_present_count(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetLastPresentCount)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetDesc1
  
  pub fn get_desc1(&self) -> HResult<DXGI_SWAP_CHAIN_DESC1> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC1 = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc1)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetFullscreenDesc
  
  pub fn get_fullscreen_desc(&self) -> HResult<DXGI_SWAP_CHAIN_FULLSCREEN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_FULLSCREEN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFullscreenDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetHwnd
  
  pub fn get_hwnd(&self) -> HResult<HWND> {
    let mut lv1: HWND = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetHwnd)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetCoreWindow
  
  pub fn get_core_window<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCoreWindow)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present1
  
  pub fn present1(&self, sync_interval: UINT, present_flags: UINT, present_parameters: &DXGI_PRESENT_PARAMETERS) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present1)(self.0, sync_interval, present_flags, present_parameters) };
    hr2ret(hr,())
  }
  
  //  Method IsTemporaryMonoSupported
  
  pub fn is_temporary_mono_supported(&self) -> BOOL {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).IsTemporaryMonoSupported)(self.0) };
    hr
  }
  
  //  Method GetRestrictToOutput
  
  pub fn get_restrict_to_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRestrictToOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method SetBackgroundColor
  
  pub fn set_background_color(&self, color: &DXGI_RGBA) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetBackgroundColor)(self.0, color) };
    hr2ret(hr,())
  }
  
  //  Method GetBackgroundColor
  
  pub fn get_background_color(&self) -> HResult<DXGI_RGBA> {
    let mut lv1: DXGI_RGBA = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBackgroundColor)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetRotation
  
  pub fn set_rotation(&self, rotation: DXGI_MODE_ROTATION) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetRotation)(self.0, rotation) };
    hr2ret(hr,())
  }
  
  //  Method GetRotation
  
  pub fn get_rotation(&self) -> HResult<DXGI_MODE_ROTATION> {
    let mut lv1: DXGI_MODE_ROTATION = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetRotation)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetSourceSize
  
  pub fn set_source_size(&self, width: UINT, height: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetSourceSize)(self.0, width, height) };
    hr2ret(hr,())
  }
  
  //  Method GetSourceSize
  
  pub fn get_source_size(&self) -> HResult<DSize> {
    let mut lv1: DSize = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetSourceSize)(self.0, &mut (lv1.width) as *mut _ as *mut _, &mut (lv1.height) as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetMaximumFrameLatency
  
  pub fn set_maximum_frame_latency(&self, max_latency: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMaximumFrameLatency)(self.0, max_latency) };
    hr2ret(hr,())
  }
  
  //  Method GetMaximumFrameLatency
  
  pub fn get_maximum_frame_latency(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMaximumFrameLatency)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetFrameLatencyWaitableObject
  
  pub fn get_frame_latency_waitable_object(&self) -> HANDLE {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameLatencyWaitableObject)(self.0) };
    hr
  }
  
  //  Method SetMatrixTransform
  
  pub fn set_matrix_transform(&self, matrix: &DXGI_MATRIX_3X2_F) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetMatrixTransform)(self.0, matrix) };
    hr2ret(hr,())
  }
  
  //  Method GetMatrixTransform
  
  pub fn get_matrix_transform(&self) -> HResult<DXGI_MATRIX_3X2_F> {
    let mut lv1: DXGI_MATRIX_3X2_F = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetMatrixTransform)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetCurrentBackBufferIndex
  
  pub fn get_current_back_buffer_index(&self) -> UINT {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).GetCurrentBackBufferIndex)(self.0) };
    hr
  }
  
  //  Method CheckColorSpaceSupport
  
  pub fn check_color_space_support(&self, color_space: DXGI_COLOR_SPACE_TYPE) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckColorSpaceSupport)(self.0, color_space, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetColorSpace1
  
  pub fn set_color_space1(&self, color_space: DXGI_COLOR_SPACE_TYPE) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetColorSpace1)(self.0, color_space) };
    hr2ret(hr,())
  }
  
  //  Method ResizeBuffers1
  
  pub fn resize_buffers1<T: HasIID>(&self, width: UINT, height: UINT, format: DXGI_FORMAT, swap_chain_flags: UINT, creation_node_mask: &mut [UINT], present_queue: &[&T]) -> HResult<()> {
    let mut lv1: Vec<*mut IUnknown> = present_queue.iter().map(|o|o.iptr()).collect();
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeBuffers1)(self.0,  same_length(&[Some(creation_node_mask.len()),Some(present_queue.len())]).expect("Arrays must have equal sizes") as UINT, width, height, format, swap_chain_flags, creation_node_mask.as_mut_ptr() as *mut _, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGISwapChainMedia(*mut IDXGISwapChainMedia);

impl HasIID for DXGISwapChainMedia {
  fn iid() -> &'static IID { &IID_IDXGISwapChainMedia }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChainMedia(pp_vtbl as *mut _ as *mut IDXGISwapChainMedia) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISwapChainMedia {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChainMedia {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISwapChainMedia {
  //  Method GetFrameStatisticsMedia
  
  pub fn get_frame_statistics_media(&self) -> HResult<DXGI_FRAME_STATISTICS_MEDIA> {
    let mut lv1: DXGI_FRAME_STATISTICS_MEDIA = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatisticsMedia)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method SetPresentDuration
  
  pub fn set_present_duration(&self, duration: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPresentDuration)(self.0, duration) };
    hr2ret(hr,())
  }
  
  //  Method CheckPresentDurationSupport
  
  pub fn check_present_duration_support(&self, desired_present_duration: UINT, closest_smaller_present_duration: &mut UINT, closest_larger_present_duration: &mut UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).CheckPresentDurationSupport)(self.0, desired_present_duration, closest_smaller_present_duration, closest_larger_present_duration) };
    hr2ret(hr,())
  }
  
  
}

pub struct DXGISwapChain(*mut IDXGISwapChain);

impl HasIID for DXGISwapChain {
  fn iid() -> &'static IID { &IID_IDXGISwapChain }
  fn new(pp_vtbl : *mut IUnknown) -> Self { DXGISwapChain(pp_vtbl as *mut _ as *mut IDXGISwapChain) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}

impl Drop for DXGISwapChain {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for DXGISwapChain {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}

impl DXGISwapChain {
  //  Method SetPrivateData
  
  pub fn set_private_data<T>(&self, name: REFGUID, data: &T) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetPrivateData)(self.0, name, mem::size_of_val(data) as UINT, data as *const _ as *const _) };
    hr2ret(hr,())
  }
  
  //  Method GetPrivateData
  
  pub fn get_private_data<T>(&self, name: REFGUID, data: Option<&mut T>) -> HResult<UINT> {
    let mut lv1: UINT = data.as_ref().map(|v|mem::size_of_val(*v)).unwrap_or(0) as UINT;
    let hr=unsafe { ((*(*self.0).lpVtbl).GetPrivateData)(self.0, name, &mut lv1, data.map(|v|v as *const _ as *mut _).unwrap_or(ptr::null_mut())) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetParent
  
  pub fn get_parent<T: HasIID>(&self) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetParent)(self.0, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method Present
  
  pub fn present(&self, sync_interval: UINT, flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).Present)(self.0, sync_interval, flags) };
    hr2ret(hr,())
  }
  
  //  Method GetBuffer
  
  pub fn get_buffer<T: HasIID>(&self, buffer: UINT) -> HResult<T> {
    let mut lv1: *mut IUnknown = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetBuffer)(self.0, buffer, T::iid(), &mut lv1 as *mut *mut _ as *mut *mut c_void) };
    hr2ret(hr,T::new(lv1))
  }
  
  //  Method SetFullscreenState
  
  pub fn set_fullscreen_state(&self, fullscreen: BOOL, target: Option<&DXGIOutput>) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).SetFullscreenState)(self.0, fullscreen, target.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    hr2ret(hr,())
  }
  
  //  Method GetFullscreenState
  //  Error: ppTarget parameter: ANone annotation cannot be used with double indirection
  //  Method GetDesc
  
  pub fn get_desc(&self) -> HResult<DXGI_SWAP_CHAIN_DESC> {
    let mut lv1: DXGI_SWAP_CHAIN_DESC = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetDesc)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method ResizeBuffers
  
  pub fn resize_buffers(&self, buffer_count: UINT, width: UINT, height: UINT, new_format: DXGI_FORMAT, swap_chain_flags: UINT) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeBuffers)(self.0, buffer_count, width, height, new_format, swap_chain_flags) };
    hr2ret(hr,())
  }
  
  //  Method ResizeTarget
  
  pub fn resize_target(&self, new_target_parameters: &DXGI_MODE_DESC) -> HResult<()> {
  
    let hr=unsafe { ((*(*self.0).lpVtbl).ResizeTarget)(self.0, new_target_parameters) };
    hr2ret(hr,())
  }
  
  //  Method GetContainingOutput
  
  pub fn get_containing_output(&self) -> HResult<DXGIOutput> {
    let mut lv1: *mut IDXGIOutput = ptr::null_mut();
    let hr=unsafe { ((*(*self.0).lpVtbl).GetContainingOutput)(self.0, &mut lv1 as *mut *mut _) };
    hr2ret(hr,DXGIOutput::new(lv1 as *mut _))
  }
  
  //  Method GetFrameStatistics
  
  pub fn get_frame_statistics(&self) -> HResult<DXGI_FRAME_STATISTICS> {
    let mut lv1: DXGI_FRAME_STATISTICS = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetFrameStatistics)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  //  Method GetLastPresentCount
  
  pub fn get_last_present_count(&self) -> HResult<UINT> {
    let mut lv1: UINT = unsafe {mem::uninitialized::<_>()};
    let hr=unsafe { ((*(*self.0).lpVtbl).GetLastPresentCount)(self.0, &mut lv1 as *mut _ as *mut _) };
    hr2ret(hr,lv1)
  }
  
  
}

