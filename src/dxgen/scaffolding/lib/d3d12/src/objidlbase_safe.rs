// This file is autogenerated

use utils::*;

pub trait TsyncIMultiQI: TUnknown {
  //  Method Begin_QueryMultipleInterfaces
  
  #[allow(non_snake_case)]
  fn begin(&self, cMQIs: ULONG, m_q_is: &mut MULTI_QI) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIMultiQI)).Begin_QueryMultipleInterfaces(cMQIs, m_q_is) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_QueryMultipleInterfaces
  
  #[allow(non_snake_case)]
  fn finish(&self, m_q_is: &mut MULTI_QI) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIMultiQI)).Finish_QueryMultipleInterfaces(m_q_is) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for syncIMultiQI {
  fn new(ptr: *mut IUnknown) -> Self {
    syncIMultiQI(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for syncIMultiQI {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for syncIMultiQI {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TsyncIMultiQI for syncIMultiQI {}

pub struct syncIMultiQI(*mut IsyncIMultiQI);

impl HasIID for syncIMultiQI {
  fn iid() -> REFGUID { &IID_IsyncIMultiQI }
}

pub trait TsyncIPipeByte: TUnknown {
  //  Method Begin_Pull
  
  #[allow(non_snake_case)]
  fn begin(&self, cRequest: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeByte)).Begin_Pull(cRequest) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_Pull
  
  #[allow(non_snake_case)]
  fn finish(&self, buf: &mut BYTE, pcReturned: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeByte)).Finish_Pull(buf, pcReturned) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Begin_Push
  
  #[allow(non_snake_case)]
  fn begin(&self, buf: &mut BYTE, cSent: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeByte)).Begin_Push(buf, cSent) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_Push
  
  #[allow(non_snake_case)]
  fn finish(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeByte)).Finish_Push() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for syncIPipeByte {
  fn new(ptr: *mut IUnknown) -> Self {
    syncIPipeByte(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for syncIPipeByte {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for syncIPipeByte {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TsyncIPipeByte for syncIPipeByte {}

pub struct syncIPipeByte(*mut IsyncIPipeByte);

impl HasIID for syncIPipeByte {
  fn iid() -> REFGUID { &IID_IsyncIPipeByte }
}

pub trait TsyncIPipeDouble: TUnknown {
  //  Method Begin_Pull
  
  #[allow(non_snake_case)]
  fn begin(&self, cRequest: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeDouble)).Begin_Pull(cRequest) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_Pull
  
  #[allow(non_snake_case)]
  fn finish(&self, buf: &mut DOUBLE, pcReturned: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeDouble)).Finish_Pull(buf, pcReturned) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Begin_Push
  
  #[allow(non_snake_case)]
  fn begin(&self, buf: &mut DOUBLE, cSent: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeDouble)).Begin_Push(buf, cSent) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_Push
  
  #[allow(non_snake_case)]
  fn finish(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeDouble)).Finish_Push() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for syncIPipeDouble {
  fn new(ptr: *mut IUnknown) -> Self {
    syncIPipeDouble(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for syncIPipeDouble {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for syncIPipeDouble {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TsyncIPipeDouble for syncIPipeDouble {}

pub struct syncIPipeDouble(*mut IsyncIPipeDouble);

impl HasIID for syncIPipeDouble {
  fn iid() -> REFGUID { &IID_IsyncIPipeDouble }
}

pub trait TsyncIPipeLong: TUnknown {
  //  Method Begin_Pull
  
  #[allow(non_snake_case)]
  fn begin(&self, cRequest: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeLong)).Begin_Pull(cRequest) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_Pull
  
  #[allow(non_snake_case)]
  fn finish(&self, buf: &mut LONG, pcReturned: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeLong)).Finish_Pull(buf, pcReturned) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Begin_Push
  
  #[allow(non_snake_case)]
  fn begin(&self, buf: &mut LONG, cSent: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeLong)).Begin_Push(buf, cSent) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Finish_Push
  
  #[allow(non_snake_case)]
  fn finish(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IsyncIPipeLong)).Finish_Push() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for syncIPipeLong {
  fn new(ptr: *mut IUnknown) -> Self {
    syncIPipeLong(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for syncIPipeLong {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for syncIPipeLong {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TsyncIPipeLong for syncIPipeLong {}

pub struct syncIPipeLong(*mut IsyncIPipeLong);

impl HasIID for syncIPipeLong {
  fn iid() -> REFGUID { &IID_IsyncIPipeLong }
}

pub trait TActivationFilter: TUnknown {
  //  Method HandleActivation
  
  #[allow(non_snake_case)]
  fn handle_activation(&self, activation_type: DWORD, rclsid: &IID, replacement_cls_id: &mut CLSID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IActivationFilter)).HandleActivation(activation_type, rclsid, replacement_cls_id) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for ActivationFilter {
  fn new(ptr: *mut IUnknown) -> Self {
    ActivationFilter(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ActivationFilter {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ActivationFilter {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TActivationFilter for ActivationFilter {}

pub struct ActivationFilter(*mut IActivationFilter);

impl HasIID for ActivationFilter {
  fn iid() -> REFGUID { &IID_IActivationFilter }
}

pub trait TAddrExclusionControl: TUnknown {
  //  Method GetCurrentAddrExclusionList
  //  Error: ppEnumerator parameter: ANone annotation cannot be applied to void pointer
  //  Method UpdateAddrExclusionList
  
  #[allow(non_snake_case)]
  fn update_addr_exclusion_list(&self, enumerator: &mut IUnknown) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAddrExclusionControl)).UpdateAddrExclusionList(enumerator) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for AddrExclusionControl {
  fn new(ptr: *mut IUnknown) -> Self {
    AddrExclusionControl(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for AddrExclusionControl {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for AddrExclusionControl {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TAddrExclusionControl for AddrExclusionControl {}

pub struct AddrExclusionControl(*mut IAddrExclusionControl);

impl HasIID for AddrExclusionControl {
  fn iid() -> REFGUID { &IID_IAddrExclusionControl }
}

pub trait TAddrTrackingControl: TUnknown {
  //  Method EnableCOMDynamicAddrTracking
  
  #[allow(non_snake_case)]
  fn enable_c_o_m_dynamic_addr_tracking(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAddrTrackingControl)).EnableCOMDynamicAddrTracking() };
    hr2ret(_hr,_hr)
  }
  
  //  Method DisableCOMDynamicAddrTracking
  
  #[allow(non_snake_case)]
  fn disable_c_o_m_dynamic_addr_tracking(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAddrTrackingControl)).DisableCOMDynamicAddrTracking() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for AddrTrackingControl {
  fn new(ptr: *mut IUnknown) -> Self {
    AddrTrackingControl(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for AddrTrackingControl {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for AddrTrackingControl {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TAddrTrackingControl for AddrTrackingControl {}

pub struct AddrTrackingControl(*mut IAddrTrackingControl);

impl HasIID for AddrTrackingControl {
  fn iid() -> REFGUID { &IID_IAddrTrackingControl }
}

pub trait TAgileObject: TUnknown {
  
}

impl TUnknown for AgileObject {
  fn new(ptr: *mut IUnknown) -> Self {
    AgileObject(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for AgileObject {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for AgileObject {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TAgileObject for AgileObject {}

pub struct AgileObject(*mut IAgileObject);

impl HasIID for AgileObject {
  fn iid() -> REFGUID { &IID_IAgileObject }
}

pub trait TAgileReference: TUnknown {
  //  Method Resolve
  //  Error: ppvObjectReference parameter: ANone annotation cannot be applied to void pointer
  
}

impl TUnknown for AgileReference {
  fn new(ptr: *mut IUnknown) -> Self {
    AgileReference(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for AgileReference {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for AgileReference {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TAgileReference for AgileReference {}

pub struct AgileReference(*mut IAgileReference);

impl HasIID for AgileReference {
  fn iid() -> REFGUID { &IID_IAgileReference }
}

pub trait TAsyncManager: TUnknown {
  //  Method CompleteCall
  
  #[allow(non_snake_case)]
  fn complete_call(&self, result: HRESULT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAsyncManager)).CompleteCall(result) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCallContext
  //  Error: pInterface parameter: ANone annotation cannot be applied to void pointer
  //  Method GetState
  
  #[allow(non_snake_case)]
  fn get_state(&self, pulStateFlags: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAsyncManager)).GetState(pulStateFlags) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for AsyncManager {
  fn new(ptr: *mut IUnknown) -> Self {
    AsyncManager(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for AsyncManager {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for AsyncManager {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TAsyncManager for AsyncManager {}

pub struct AsyncManager(*mut IAsyncManager);

impl HasIID for AsyncManager {
  fn iid() -> REFGUID { &IID_IAsyncManager }
}

pub trait TAsyncRpcChannelBuffer: TRpcChannelBuffer2 {
  //  Method Send
  
  #[allow(non_snake_case)]
  fn send(&self, msg: &mut RPCOLEMESSAGE, sync: &mut ISynchronize, pulStatus: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAsyncRpcChannelBuffer)).Send(msg, sync, pulStatus) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Receive
  
  #[allow(non_snake_case)]
  fn receive(&self, msg: &mut RPCOLEMESSAGE, pulStatus: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IAsyncRpcChannelBuffer)).Receive(msg, pulStatus) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDestCtxEx
  //  Error: ppvDestContext parameter: ANone annotation cannot be applied to void pointer
  
}

impl TUnknown for AsyncRpcChannelBuffer {
  fn new(ptr: *mut IUnknown) -> Self {
    AsyncRpcChannelBuffer(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for AsyncRpcChannelBuffer {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for AsyncRpcChannelBuffer {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcChannelBuffer for AsyncRpcChannelBuffer {}
impl TRpcChannelBuffer2 for AsyncRpcChannelBuffer {}
impl TAsyncRpcChannelBuffer for AsyncRpcChannelBuffer {}

pub struct AsyncRpcChannelBuffer(*mut IAsyncRpcChannelBuffer);

impl HasIID for AsyncRpcChannelBuffer {
  fn iid() -> REFGUID { &IID_IAsyncRpcChannelBuffer }
}

pub trait TCallFactory: TUnknown {
  //  Method CreateCall
  //  Error: ppv parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for CallFactory {
  fn new(ptr: *mut IUnknown) -> Self {
    CallFactory(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for CallFactory {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for CallFactory {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TCallFactory for CallFactory {}

pub struct CallFactory(*mut ICallFactory);

impl HasIID for CallFactory {
  fn iid() -> REFGUID { &IID_ICallFactory }
}

pub trait TCancelMethodCalls: TUnknown {
  //  Method Cancel
  
  #[allow(non_snake_case)]
  fn cancel(&self, ulSeconds: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ICancelMethodCalls)).Cancel(ulSeconds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method TestCancel
  
  #[allow(non_snake_case)]
  fn test_cancel(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ICancelMethodCalls)).TestCancel() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for CancelMethodCalls {
  fn new(ptr: *mut IUnknown) -> Self {
    CancelMethodCalls(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for CancelMethodCalls {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for CancelMethodCalls {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TCancelMethodCalls for CancelMethodCalls {}

pub struct CancelMethodCalls(*mut ICancelMethodCalls);

impl HasIID for CancelMethodCalls {
  fn iid() -> REFGUID { &IID_ICancelMethodCalls }
}

pub trait TChannelHook: TUnknown {
  //  Method ClientGetSize
  
  #[allow(non_snake_case)]
  fn client_get_size(&self, uExtent: &GUID, riid: &IID, data_size: &mut ULONG) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IChannelHook)).ClientGetSize(uExtent, riid, data_size) };
    ()
  }
  
  //  Method ClientFillBuffer
  //  Warning: pDataBuffer parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn client_fill_buffer<T>(&self, uExtent: &GUID, riid: &IID, data_size: &mut ULONG, data_buffer: &mut [T]) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IChannelHook)).ClientFillBuffer(uExtent, riid, data_size, data_buffer.as_mut_ptr() as *mut _) };
    ()
  }
  
  //  Method ClientNotify
  //  Warning: pDataBuffer parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn client_notify<T>(&self, uExtent: &GUID, riid: &IID, cbDataSize: ULONG, data_buffer: &mut [T], lDataRep: DWORD, hrFault: HRESULT) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IChannelHook)).ClientNotify(uExtent, riid, cbDataSize, data_buffer.as_mut_ptr() as *mut _, lDataRep, hrFault) };
    ()
  }
  
  //  Method ServerNotify
  //  Warning: pDataBuffer parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn server_notify<T>(&self, uExtent: &GUID, riid: &IID, cbDataSize: ULONG, data_buffer: &mut [T], lDataRep: DWORD) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IChannelHook)).ServerNotify(uExtent, riid, cbDataSize, data_buffer.as_mut_ptr() as *mut _, lDataRep) };
    ()
  }
  
  //  Method ServerGetSize
  
  #[allow(non_snake_case)]
  fn server_get_size(&self, uExtent: &GUID, riid: &IID, hrFault: HRESULT, data_size: &mut ULONG) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IChannelHook)).ServerGetSize(uExtent, riid, hrFault, data_size) };
    ()
  }
  
  //  Method ServerFillBuffer
  //  Warning: pDataBuffer parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn server_fill_buffer<T>(&self, uExtent: &GUID, riid: &IID, data_size: &mut ULONG, data_buffer: &mut [T], hrFault: HRESULT) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IChannelHook)).ServerFillBuffer(uExtent, riid, data_size, data_buffer.as_mut_ptr() as *mut _, hrFault) };
    ()
  }
  
  
}

impl TUnknown for ChannelHook {
  fn new(ptr: *mut IUnknown) -> Self {
    ChannelHook(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ChannelHook {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ChannelHook {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TChannelHook for ChannelHook {}

pub struct ChannelHook(*mut IChannelHook);

impl HasIID for ChannelHook {
  fn iid() -> REFGUID { &IID_IChannelHook }
}

pub trait TClientSecurity: TUnknown {
  //  Method QueryBlanket
  //  Error: pAuthInfo parameter: ANone annotation cannot be applied to void pointer
  //  Error: pServerPrincName parameter: ANone annotation cannot be used with double indirection
  //  Method SetBlanket
  //  Warning: pAuthInfo parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn set_blanket<T>(&self, proxy: &mut IUnknown, authn_svc: DWORD, authz_svc: DWORD, server_princ_name: &mut OLECHAR, authn_level: DWORD, imp_level: DWORD, auth_info: &mut [T], capabilities: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IClientSecurity)).SetBlanket(proxy, authn_svc, authz_svc, server_princ_name, authn_level, imp_level, auth_info.as_mut_ptr() as *mut _, capabilities) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyProxy
  //  Error: ppCopy parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for ClientSecurity {
  fn new(ptr: *mut IUnknown) -> Self {
    ClientSecurity(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ClientSecurity {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ClientSecurity {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TClientSecurity for ClientSecurity {}

pub struct ClientSecurity(*mut IClientSecurity);

impl HasIID for ClientSecurity {
  fn iid() -> REFGUID { &IID_IClientSecurity }
}

pub trait TComThreadingInfo: TUnknown {
  //  Method GetCurrentApartmentType
  
  #[allow(non_snake_case)]
  fn get_current_apartment_type(&self, apt_type: &mut APTTYPE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IComThreadingInfo)).GetCurrentApartmentType(apt_type) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCurrentThreadType
  
  #[allow(non_snake_case)]
  fn get_current_thread_type(&self, thread_type: &mut THDTYPE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IComThreadingInfo)).GetCurrentThreadType(thread_type) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCurrentLogicalThreadId
  
  #[allow(non_snake_case)]
  fn get_current_logical_thread_id(&self, pguidLogicalThreadId: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IComThreadingInfo)).GetCurrentLogicalThreadId(pguidLogicalThreadId) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetCurrentLogicalThreadId
  
  #[allow(non_snake_case)]
  fn set_current_logical_thread_id(&self, rguid: &GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IComThreadingInfo)).SetCurrentLogicalThreadId(rguid) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for ComThreadingInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    ComThreadingInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ComThreadingInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ComThreadingInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TComThreadingInfo for ComThreadingInfo {}

pub struct ComThreadingInfo(*mut IComThreadingInfo);

impl HasIID for ComThreadingInfo {
  fn iid() -> REFGUID { &IID_IComThreadingInfo }
}

pub trait TEnumString: TUnknown {
  //  Method Next
  
  #[allow(non_snake_case)]
  fn next(&self, celt: ULONG, rgelt: &mut LPOLESTR, pceltFetched: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IEnumString)).Next(celt, rgelt, pceltFetched) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Skip
  
  #[allow(non_snake_case)]
  fn skip(&self, celt: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IEnumString)).Skip(celt) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Reset
  
  #[allow(non_snake_case)]
  fn reset(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IEnumString)).Reset() };
    hr2ret(_hr,_hr)
  }
  
  //  Method Clone
  //  Error: ppenum parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for EnumString {
  fn new(ptr: *mut IUnknown) -> Self {
    EnumString(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for EnumString {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for EnumString {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TEnumString for EnumString {}

pub struct EnumString(*mut IEnumString);

impl HasIID for EnumString {
  fn iid() -> REFGUID { &IID_IEnumString }
}

pub trait TEnumUnknown: TUnknown {
  //  Method Next
  //  Error: rgelt parameter: ANone annotation cannot be used with double indirection
  //  Method Skip
  
  #[allow(non_snake_case)]
  fn skip(&self, celt: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IEnumUnknown)).Skip(celt) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Reset
  
  #[allow(non_snake_case)]
  fn reset(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IEnumUnknown)).Reset() };
    hr2ret(_hr,_hr)
  }
  
  //  Method Clone
  //  Error: ppenum parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for EnumUnknown {
  fn new(ptr: *mut IUnknown) -> Self {
    EnumUnknown(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for EnumUnknown {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for EnumUnknown {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TEnumUnknown for EnumUnknown {}

pub struct EnumUnknown(*mut IEnumUnknown);

impl HasIID for EnumUnknown {
  fn iid() -> REFGUID { &IID_IEnumUnknown }
}

pub trait TExternalConnection: TUnknown {
  //  Method AddConnection
  
  #[allow(non_snake_case)]
  fn add_connection(&self, extconn: DWORD, reserved: DWORD) -> DWORD {
  
    let _hr=unsafe { (*(self.iptr() as *mut IExternalConnection)).AddConnection(extconn, reserved) };
    _hr
  }
  
  //  Method ReleaseConnection
  
  #[allow(non_snake_case)]
  fn release_connection(&self, extconn: DWORD, reserved: DWORD, fLastReleaseCloses: BOOL) -> DWORD {
  
    let _hr=unsafe { (*(self.iptr() as *mut IExternalConnection)).ReleaseConnection(extconn, reserved, fLastReleaseCloses) };
    _hr
  }
  
  
}

impl TUnknown for ExternalConnection {
  fn new(ptr: *mut IUnknown) -> Self {
    ExternalConnection(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ExternalConnection {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ExternalConnection {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TExternalConnection for ExternalConnection {}

pub struct ExternalConnection(*mut IExternalConnection);

impl HasIID for ExternalConnection {
  fn iid() -> REFGUID { &IID_IExternalConnection }
}

pub trait TFastRundown: TUnknown {
  
}

impl TUnknown for FastRundown {
  fn new(ptr: *mut IUnknown) -> Self {
    FastRundown(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for FastRundown {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for FastRundown {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TFastRundown for FastRundown {}

pub struct FastRundown(*mut IFastRundown);

impl HasIID for FastRundown {
  fn iid() -> REFGUID { &IID_IFastRundown }
}

pub trait TGlobalInterfaceTable: TUnknown {
  //  Method RegisterInterfaceInGlobal
  
  #[allow(non_snake_case)]
  fn register_interface_in_global(&self, unk: &mut IUnknown, riid: &IID, pdwCookie: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IGlobalInterfaceTable)).RegisterInterfaceInGlobal(unk, riid, pdwCookie) };
    hr2ret(_hr,_hr)
  }
  
  //  Method RevokeInterfaceFromGlobal
  
  #[allow(non_snake_case)]
  fn revoke_interface_from_global(&self, cookie: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IGlobalInterfaceTable)).RevokeInterfaceFromGlobal(cookie) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetInterfaceFromGlobal
  //  Error: ppv parameter: ANone annotation cannot be applied to void pointer
  
}

impl TUnknown for GlobalInterfaceTable {
  fn new(ptr: *mut IUnknown) -> Self {
    GlobalInterfaceTable(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for GlobalInterfaceTable {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for GlobalInterfaceTable {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TGlobalInterfaceTable for GlobalInterfaceTable {}

pub struct GlobalInterfaceTable(*mut IGlobalInterfaceTable);

impl HasIID for GlobalInterfaceTable {
  fn iid() -> REFGUID { &IID_IGlobalInterfaceTable }
}

pub trait TGlobalOptions: TUnknown {
  //  Method Set
  
  #[allow(non_snake_case)]
  fn set(&self, property: GLOBALOPT_PROPERTIES, value: ULONG_PTR) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IGlobalOptions)).Set(property, value) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Query
  
  #[allow(non_snake_case)]
  fn query(&self, property: GLOBALOPT_PROPERTIES, pdwValue: &mut ULONG_PTR) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IGlobalOptions)).Query(property, pdwValue) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for GlobalOptions {
  fn new(ptr: *mut IUnknown) -> Self {
    GlobalOptions(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for GlobalOptions {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for GlobalOptions {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TGlobalOptions for GlobalOptions {}

pub struct GlobalOptions(*mut IGlobalOptions);

impl HasIID for GlobalOptions {
  fn iid() -> REFGUID { &IID_IGlobalOptions }
}

pub trait TInternalUnknown: TUnknown {
  //  Method QueryInternalInterface
  //  Error: ppv parameter: ANone annotation cannot be applied to void pointer
  
}

impl TUnknown for InternalUnknown {
  fn new(ptr: *mut IUnknown) -> Self {
    InternalUnknown(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for InternalUnknown {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for InternalUnknown {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TInternalUnknown for InternalUnknown {}

pub struct InternalUnknown(*mut IInternalUnknown);

impl HasIID for InternalUnknown {
  fn iid() -> REFGUID { &IID_IInternalUnknown }
}

pub trait TMarshal2: TMarshal {
  
}

impl TUnknown for Marshal2 {
  fn new(ptr: *mut IUnknown) -> Self {
    Marshal2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for Marshal2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for Marshal2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TMarshal for Marshal2 {}
impl TMarshal2 for Marshal2 {}

pub struct Marshal2(*mut IMarshal2);

impl HasIID for Marshal2 {
  fn iid() -> REFGUID { &IID_IMarshal2 }
}

pub trait TMarshal: TUnknown {
  //  Method GetUnmarshalClass
  //  Warning: pvDestContext parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  //  Warning: pv parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn get_unmarshal_class<T, T1>(&self, riid: &IID, pv: &mut [T], dest_context: DWORD, pvDestContext: &mut [T1], mshlflags: DWORD, cid: &mut CLSID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMarshal)).GetUnmarshalClass(riid, pv.as_mut_ptr() as *mut _, dest_context, pvDestContext.as_mut_ptr() as *mut _, mshlflags, cid) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMarshalSizeMax
  //  Warning: pvDestContext parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  //  Warning: pv parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn get_marshal_size_max<T, T1>(&self, riid: &IID, pv: &mut [T], dest_context: DWORD, pvDestContext: &mut [T1], mshlflags: DWORD, size: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMarshal)).GetMarshalSizeMax(riid, pv.as_mut_ptr() as *mut _, dest_context, pvDestContext.as_mut_ptr() as *mut _, mshlflags, size) };
    hr2ret(_hr,_hr)
  }
  
  //  Method MarshalInterface
  //  Warning: pvDestContext parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  //  Warning: pv parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn marshal_interface<T, T1>(&self, stm: &mut IStream, riid: &IID, pv: &mut [T], dest_context: DWORD, pvDestContext: &mut [T1], mshlflags: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMarshal)).MarshalInterface(stm, riid, pv.as_mut_ptr() as *mut _, dest_context, pvDestContext.as_mut_ptr() as *mut _, mshlflags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method UnmarshalInterface
  //  Error: ppv parameter: ANone annotation cannot be applied to void pointer
  //  Method ReleaseMarshalData
  
  #[allow(non_snake_case)]
  fn release_marshal_data(&self, stm: &mut IStream) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMarshal)).ReleaseMarshalData(stm) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DisconnectObject
  
  #[allow(non_snake_case)]
  fn disconnect_object(&self, reserved: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMarshal)).DisconnectObject(reserved) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for Marshal {
  fn new(ptr: *mut IUnknown) -> Self {
    Marshal(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for Marshal {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for Marshal {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TMarshal for Marshal {}

pub struct Marshal(*mut IMarshal);

impl HasIID for Marshal {
  fn iid() -> REFGUID { &IID_IMarshal }
}

pub trait TMarshalingStream: TStream {
  //  Method GetMarshalingContextAttribute
  
  #[allow(non_snake_case)]
  fn get_marshaling_context_attribute(&self, attribute: CO_MARSHALING_CONTEXT_ATTRIBUTES, attribute_value: &mut ULONG_PTR) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMarshalingStream)).GetMarshalingContextAttribute(attribute, attribute_value) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for MarshalingStream {
  fn new(ptr: *mut IUnknown) -> Self {
    MarshalingStream(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for MarshalingStream {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for MarshalingStream {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSequentialStream for MarshalingStream {}
impl TStream for MarshalingStream {}
impl TMarshalingStream for MarshalingStream {}

pub struct MarshalingStream(*mut IMarshalingStream);

impl HasIID for MarshalingStream {
  fn iid() -> REFGUID { &IID_IMarshalingStream }
}

pub trait TMultiQI: TUnknown {
  //  Method QueryMultipleInterfaces
  
  #[allow(non_snake_case)]
  fn query_multiple_interfaces(&self, cMQIs: ULONG, m_q_is: &mut MULTI_QI) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IMultiQI)).QueryMultipleInterfaces(cMQIs, m_q_is) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for MultiQI {
  fn new(ptr: *mut IUnknown) -> Self {
    MultiQI(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for MultiQI {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for MultiQI {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TMultiQI for MultiQI {}

pub struct MultiQI(*mut IMultiQI);

impl HasIID for MultiQI {
  fn iid() -> REFGUID { &IID_IMultiQI }
}

pub trait TNoMarshal: TUnknown {
  
}

impl TUnknown for NoMarshal {
  fn new(ptr: *mut IUnknown) -> Self {
    NoMarshal(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for NoMarshal {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for NoMarshal {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TNoMarshal for NoMarshal {}

pub struct NoMarshal(*mut INoMarshal);

impl HasIID for NoMarshal {
  fn iid() -> REFGUID { &IID_INoMarshal }
}

pub trait TPSFactoryBuffer: TUnknown {
  //  Method CreateProxy
  //  Error: ppv parameter: ANone annotation cannot be applied to void pointer
  //  Error: ppProxy parameter: ANone annotation cannot be used with double indirection
  //  Method CreateStub
  //  Error: ppStub parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for PSFactoryBuffer {
  fn new(ptr: *mut IUnknown) -> Self {
    PSFactoryBuffer(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for PSFactoryBuffer {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for PSFactoryBuffer {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TPSFactoryBuffer for PSFactoryBuffer {}

pub struct PSFactoryBuffer(*mut IPSFactoryBuffer);

impl HasIID for PSFactoryBuffer {
  fn iid() -> REFGUID { &IID_IPSFactoryBuffer }
}

pub trait TPipeByte: TUnknown {
  //  Method Pull
  
  #[allow(non_snake_case)]
  fn pull(&self, buf: &mut BYTE, cRequest: ULONG, pcReturned: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IPipeByte)).Pull(buf, cRequest, pcReturned) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Push
  
  #[allow(non_snake_case)]
  fn push(&self, buf: &mut BYTE, cSent: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IPipeByte)).Push(buf, cSent) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for PipeByte {
  fn new(ptr: *mut IUnknown) -> Self {
    PipeByte(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for PipeByte {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for PipeByte {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TPipeByte for PipeByte {}

pub struct PipeByte(*mut IPipeByte);

impl HasIID for PipeByte {
  fn iid() -> REFGUID { &IID_IPipeByte }
}

pub trait TPipeDouble: TUnknown {
  //  Method Pull
  
  #[allow(non_snake_case)]
  fn pull(&self, buf: &mut DOUBLE, cRequest: ULONG, pcReturned: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IPipeDouble)).Pull(buf, cRequest, pcReturned) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Push
  
  #[allow(non_snake_case)]
  fn push(&self, buf: &mut DOUBLE, cSent: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IPipeDouble)).Push(buf, cSent) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for PipeDouble {
  fn new(ptr: *mut IUnknown) -> Self {
    PipeDouble(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for PipeDouble {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for PipeDouble {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TPipeDouble for PipeDouble {}

pub struct PipeDouble(*mut IPipeDouble);

impl HasIID for PipeDouble {
  fn iid() -> REFGUID { &IID_IPipeDouble }
}

pub trait TPipeLong: TUnknown {
  //  Method Pull
  
  #[allow(non_snake_case)]
  fn pull(&self, buf: &mut LONG, cRequest: ULONG, pcReturned: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IPipeLong)).Pull(buf, cRequest, pcReturned) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Push
  
  #[allow(non_snake_case)]
  fn push(&self, buf: &mut LONG, cSent: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IPipeLong)).Push(buf, cSent) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for PipeLong {
  fn new(ptr: *mut IUnknown) -> Self {
    PipeLong(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for PipeLong {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for PipeLong {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TPipeLong for PipeLong {}

pub struct PipeLong(*mut IPipeLong);

impl HasIID for PipeLong {
  fn iid() -> REFGUID { &IID_IPipeLong }
}

pub trait TProcessInitControl: TUnknown {
  //  Method ResetInitializerTimeout
  
  #[allow(non_snake_case)]
  fn reset_initializer_timeout(&self, seconds_remaining: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IProcessInitControl)).ResetInitializerTimeout(seconds_remaining) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for ProcessInitControl {
  fn new(ptr: *mut IUnknown) -> Self {
    ProcessInitControl(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ProcessInitControl {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ProcessInitControl {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TProcessInitControl for ProcessInitControl {}

pub struct ProcessInitControl(*mut IProcessInitControl);

impl HasIID for ProcessInitControl {
  fn iid() -> REFGUID { &IID_IProcessInitControl }
}

pub trait TReleaseMarshalBuffers: TUnknown {
  //  Method ReleaseMarshalBuffer
  
  #[allow(non_snake_case)]
  fn release_marshal_buffer(&self, msg: &mut RPCOLEMESSAGE, flags: DWORD, chnl: &mut IUnknown) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IReleaseMarshalBuffers)).ReleaseMarshalBuffer(msg, flags, chnl) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for ReleaseMarshalBuffers {
  fn new(ptr: *mut IUnknown) -> Self {
    ReleaseMarshalBuffers(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ReleaseMarshalBuffers {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ReleaseMarshalBuffers {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TReleaseMarshalBuffers for ReleaseMarshalBuffers {}

pub struct ReleaseMarshalBuffers(*mut IReleaseMarshalBuffers);

impl HasIID for ReleaseMarshalBuffers {
  fn iid() -> REFGUID { &IID_IReleaseMarshalBuffers }
}

pub trait TRpcChannelBuffer2: TRpcChannelBuffer {
  //  Method GetProtocolVersion
  
  #[allow(non_snake_case)]
  fn get_protocol_version(&self, pdwVersion: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer2)).GetProtocolVersion(pdwVersion) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for RpcChannelBuffer2 {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcChannelBuffer2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcChannelBuffer2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcChannelBuffer2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcChannelBuffer for RpcChannelBuffer2 {}
impl TRpcChannelBuffer2 for RpcChannelBuffer2 {}

pub struct RpcChannelBuffer2(*mut IRpcChannelBuffer2);

impl HasIID for RpcChannelBuffer2 {
  fn iid() -> REFGUID { &IID_IRpcChannelBuffer2 }
}

pub trait TRpcChannelBuffer3: TRpcChannelBuffer2 {
  //  Method Send
  
  #[allow(non_snake_case)]
  fn send(&self, msg: &mut RPCOLEMESSAGE, pulStatus: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer3)).Send(msg, pulStatus) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Receive
  
  #[allow(non_snake_case)]
  fn receive(&self, msg: &mut RPCOLEMESSAGE, ulSize: ULONG, pulStatus: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer3)).Receive(msg, ulSize, pulStatus) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Cancel
  
  #[allow(non_snake_case)]
  fn cancel(&self, msg: &mut RPCOLEMESSAGE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer3)).Cancel(msg) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCallContext
  //  Error: pInterface parameter: ANone annotation cannot be applied to void pointer
  //  Method GetDestCtxEx
  //  Error: ppvDestContext parameter: ANone annotation cannot be applied to void pointer
  //  Method GetState
  
  #[allow(non_snake_case)]
  fn get_state(&self, msg: &mut RPCOLEMESSAGE, state: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer3)).GetState(msg, state) };
    hr2ret(_hr,_hr)
  }
  
  //  Method RegisterAsync
  
  #[allow(non_snake_case)]
  fn register_async(&self, msg: &mut RPCOLEMESSAGE, async_mgr: &mut IAsyncManager) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer3)).RegisterAsync(msg, async_mgr) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for RpcChannelBuffer3 {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcChannelBuffer3(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcChannelBuffer3 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcChannelBuffer3 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcChannelBuffer for RpcChannelBuffer3 {}
impl TRpcChannelBuffer2 for RpcChannelBuffer3 {}
impl TRpcChannelBuffer3 for RpcChannelBuffer3 {}

pub struct RpcChannelBuffer3(*mut IRpcChannelBuffer3);

impl HasIID for RpcChannelBuffer3 {
  fn iid() -> REFGUID { &IID_IRpcChannelBuffer3 }
}

pub trait TRpcChannelBuffer: TUnknown {
  //  Method GetBuffer
  
  #[allow(non_snake_case)]
  fn get_buffer(&self, message: &mut RPCOLEMESSAGE, riid: &IID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer)).GetBuffer(message, riid) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SendReceive
  
  #[allow(non_snake_case)]
  fn send_receive(&self, message: &mut RPCOLEMESSAGE, status: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer)).SendReceive(message, status) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FreeBuffer
  
  #[allow(non_snake_case)]
  fn free_buffer(&self, message: &mut RPCOLEMESSAGE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer)).FreeBuffer(message) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDestCtx
  //  Error: ppvDestContext parameter: ANone annotation cannot be applied to void pointer
  //  Method IsConnected
  
  #[allow(non_snake_case)]
  fn is_connected(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcChannelBuffer)).IsConnected() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for RpcChannelBuffer {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcChannelBuffer(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcChannelBuffer {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcChannelBuffer {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcChannelBuffer for RpcChannelBuffer {}

pub struct RpcChannelBuffer(*mut IRpcChannelBuffer);

impl HasIID for RpcChannelBuffer {
  fn iid() -> REFGUID { &IID_IRpcChannelBuffer }
}

pub trait TRpcHelper: TUnknown {
  //  Method GetDCOMProtocolVersion
  
  #[allow(non_snake_case)]
  fn get_d_c_o_m_protocol_version(&self, com_version: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcHelper)).GetDCOMProtocolVersion(com_version) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetIIDFromOBJREF
  //  Error: piid parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for RpcHelper {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcHelper(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcHelper {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcHelper {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcHelper for RpcHelper {}

pub struct RpcHelper(*mut IRpcHelper);

impl HasIID for RpcHelper {
  fn iid() -> REFGUID { &IID_IRpcHelper }
}

pub trait TRpcOptions: TUnknown {
  //  Method Set
  
  #[allow(non_snake_case)]
  fn set(&self, prx: &mut IUnknown, property: RPCOPT_PROPERTIES, value: ULONG_PTR) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcOptions)).Set(prx, property, value) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Query
  
  #[allow(non_snake_case)]
  fn query(&self, prx: &mut IUnknown, property: RPCOPT_PROPERTIES, pdwValue: &mut ULONG_PTR) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcOptions)).Query(prx, property, pdwValue) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for RpcOptions {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcOptions(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcOptions {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcOptions {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcOptions for RpcOptions {}

pub struct RpcOptions(*mut IRpcOptions);

impl HasIID for RpcOptions {
  fn iid() -> REFGUID { &IID_IRpcOptions }
}

pub trait TRpcProxyBuffer: TUnknown {
  //  Method Connect
  
  #[allow(non_snake_case)]
  fn connect(&self, rpc_channel_buffer: &mut IRpcChannelBuffer) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcProxyBuffer)).Connect(rpc_channel_buffer) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Disconnect
  
  #[allow(non_snake_case)]
  fn disconnect(&self) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcProxyBuffer)).Disconnect() };
    ()
  }
  
  
}

impl TUnknown for RpcProxyBuffer {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcProxyBuffer(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcProxyBuffer {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcProxyBuffer {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcProxyBuffer for RpcProxyBuffer {}

pub struct RpcProxyBuffer(*mut IRpcProxyBuffer);

impl HasIID for RpcProxyBuffer {
  fn iid() -> REFGUID { &IID_IRpcProxyBuffer }
}

pub trait TRpcSyntaxNegotiate: TUnknown {
  //  Method NegotiateSyntax
  
  #[allow(non_snake_case)]
  fn negotiate_syntax(&self, msg: &mut RPCOLEMESSAGE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IRpcSyntaxNegotiate)).NegotiateSyntax(msg) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for RpcSyntaxNegotiate {
  fn new(ptr: *mut IUnknown) -> Self {
    RpcSyntaxNegotiate(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for RpcSyntaxNegotiate {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for RpcSyntaxNegotiate {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TRpcSyntaxNegotiate for RpcSyntaxNegotiate {}

pub struct RpcSyntaxNegotiate(*mut IRpcSyntaxNegotiate);

impl HasIID for RpcSyntaxNegotiate {
  fn iid() -> REFGUID { &IID_IRpcSyntaxNegotiate }
}

pub trait TSequentialStream: TUnknown {
  //  Method Read
  //  Warning: pv parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn read<T>(&self, pv: &mut [T], cb: ULONG, pcbRead: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISequentialStream)).Read(pv.as_mut_ptr() as *mut _, cb, pcbRead) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Write
  //  Warning: pv parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn write<T>(&self, pv: &[T], cb: ULONG, pcbWritten: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISequentialStream)).Write(pv.as_ptr() as *const _, cb, pcbWritten) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for SequentialStream {
  fn new(ptr: *mut IUnknown) -> Self {
    SequentialStream(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for SequentialStream {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for SequentialStream {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSequentialStream for SequentialStream {}

pub struct SequentialStream(*mut ISequentialStream);

impl HasIID for SequentialStream {
  fn iid() -> REFGUID { &IID_ISequentialStream }
}

pub trait TServerSecurity: TUnknown {
  //  Method QueryBlanket
  //  Error: pPrivs parameter: ANone annotation cannot be applied to void pointer
  //  Error: pServerPrincName parameter: ANone annotation cannot be used with double indirection
  //  Method ImpersonateClient
  
  #[allow(non_snake_case)]
  fn impersonate_client(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IServerSecurity)).ImpersonateClient() };
    hr2ret(_hr,_hr)
  }
  
  //  Method RevertToSelf
  
  #[allow(non_snake_case)]
  fn revert_to_self(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IServerSecurity)).RevertToSelf() };
    hr2ret(_hr,_hr)
  }
  
  //  Method IsImpersonating
  
  #[allow(non_snake_case)]
  fn is_impersonating(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut IServerSecurity)).IsImpersonating() };
    _hr
  }
  
  
}

impl TUnknown for ServerSecurity {
  fn new(ptr: *mut IUnknown) -> Self {
    ServerSecurity(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for ServerSecurity {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for ServerSecurity {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TServerSecurity for ServerSecurity {}

pub struct ServerSecurity(*mut IServerSecurity);

impl HasIID for ServerSecurity {
  fn iid() -> REFGUID { &IID_IServerSecurity }
}

pub trait TStdMarshalInfo: TUnknown {
  //  Method GetClassForHandler
  //  Warning: pvDestContext parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn get_class_for_handler<T>(&self, dest_context: DWORD, pvDestContext: &mut [T], clsid: &mut CLSID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStdMarshalInfo)).GetClassForHandler(dest_context, pvDestContext.as_mut_ptr() as *mut _, clsid) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for StdMarshalInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    StdMarshalInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for StdMarshalInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for StdMarshalInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TStdMarshalInfo for StdMarshalInfo {}

pub struct StdMarshalInfo(*mut IStdMarshalInfo);

impl HasIID for StdMarshalInfo {
  fn iid() -> REFGUID { &IID_IStdMarshalInfo }
}

pub trait TStream: TSequentialStream {
  //  Method Seek
  
  #[allow(non_snake_case)]
  fn seek(&self, dlibMove: LARGE_INTEGER, origin: DWORD, plibNewPosition: &mut ULARGE_INTEGER) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).Seek(dlibMove, origin, plibNewPosition) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetSize
  
  #[allow(non_snake_case)]
  fn set_size(&self, libNewSize: ULARGE_INTEGER) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).SetSize(libNewSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyTo
  
  #[allow(non_snake_case)]
  fn copy_to(&self, pstm: &mut IStream, cb: ULARGE_INTEGER, pcbRead: &mut ULARGE_INTEGER, pcbWritten: &mut ULARGE_INTEGER) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).CopyTo(pstm, cb, pcbRead, pcbWritten) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Commit
  
  #[allow(non_snake_case)]
  fn commit(&self, grfCommitFlags: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).Commit(grfCommitFlags) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Revert
  
  #[allow(non_snake_case)]
  fn revert(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).Revert() };
    hr2ret(_hr,_hr)
  }
  
  //  Method LockRegion
  
  #[allow(non_snake_case)]
  fn lock_region(&self, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, lock_type: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).LockRegion(libOffset, cb, lock_type) };
    hr2ret(_hr,_hr)
  }
  
  //  Method UnlockRegion
  
  #[allow(non_snake_case)]
  fn unlock_region(&self, libOffset: ULARGE_INTEGER, cb: ULARGE_INTEGER, lock_type: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).UnlockRegion(libOffset, cb, lock_type) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Stat
  
  #[allow(non_snake_case)]
  fn stat(&self, pstatstg: &mut STATSTG, grfStatFlag: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IStream)).Stat(pstatstg, grfStatFlag) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Clone
  //  Error: ppstm parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for Stream {
  fn new(ptr: *mut IUnknown) -> Self {
    Stream(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for Stream {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for Stream {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSequentialStream for Stream {}
impl TStream for Stream {}

pub struct Stream(*mut IStream);

impl HasIID for Stream {
  fn iid() -> REFGUID { &IID_IStream }
}

pub trait TSurrogate: TUnknown {
  //  Method LoadDllServer
  
  #[allow(non_snake_case)]
  fn load_dll_server(&self, clsid: &IID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISurrogate)).LoadDllServer(clsid) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FreeSurrogate
  
  #[allow(non_snake_case)]
  fn free_surrogate(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISurrogate)).FreeSurrogate() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for Surrogate {
  fn new(ptr: *mut IUnknown) -> Self {
    Surrogate(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for Surrogate {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for Surrogate {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSurrogate for Surrogate {}

pub struct Surrogate(*mut ISurrogate);

impl HasIID for Surrogate {
  fn iid() -> REFGUID { &IID_ISurrogate }
}

pub trait TSynchronizeContainer: TUnknown {
  //  Method AddSynchronize
  
  #[allow(non_snake_case)]
  fn add_synchronize(&self, sync: &mut ISynchronize) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronizeContainer)).AddSynchronize(sync) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WaitMultiple
  //  Error: ppSync parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for SynchronizeContainer {
  fn new(ptr: *mut IUnknown) -> Self {
    SynchronizeContainer(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for SynchronizeContainer {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for SynchronizeContainer {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSynchronizeContainer for SynchronizeContainer {}

pub struct SynchronizeContainer(*mut ISynchronizeContainer);

impl HasIID for SynchronizeContainer {
  fn iid() -> REFGUID { &IID_ISynchronizeContainer }
}

pub trait TSynchronizeEvent: TSynchronizeHandle {
  //  Method SetEventHandle
  
  #[allow(non_snake_case)]
  fn set_event_handle(&self, ph: &mut HANDLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronizeEvent)).SetEventHandle(ph) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for SynchronizeEvent {
  fn new(ptr: *mut IUnknown) -> Self {
    SynchronizeEvent(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for SynchronizeEvent {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for SynchronizeEvent {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSynchronizeHandle for SynchronizeEvent {}
impl TSynchronizeEvent for SynchronizeEvent {}

pub struct SynchronizeEvent(*mut ISynchronizeEvent);

impl HasIID for SynchronizeEvent {
  fn iid() -> REFGUID { &IID_ISynchronizeEvent }
}

pub trait TSynchronizeHandle: TUnknown {
  //  Method GetHandle
  
  #[allow(non_snake_case)]
  fn get_handle(&self, ph: &mut HANDLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronizeHandle)).GetHandle(ph) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for SynchronizeHandle {
  fn new(ptr: *mut IUnknown) -> Self {
    SynchronizeHandle(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for SynchronizeHandle {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for SynchronizeHandle {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSynchronizeHandle for SynchronizeHandle {}

pub struct SynchronizeHandle(*mut ISynchronizeHandle);

impl HasIID for SynchronizeHandle {
  fn iid() -> REFGUID { &IID_ISynchronizeHandle }
}

pub trait TSynchronizeMutex: TSynchronize {
  //  Method ReleaseMutex
  
  #[allow(non_snake_case)]
  fn release_mutex(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronizeMutex)).ReleaseMutex() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for SynchronizeMutex {
  fn new(ptr: *mut IUnknown) -> Self {
    SynchronizeMutex(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for SynchronizeMutex {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for SynchronizeMutex {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSynchronize for SynchronizeMutex {}
impl TSynchronizeMutex for SynchronizeMutex {}

pub struct SynchronizeMutex(*mut ISynchronizeMutex);

impl HasIID for SynchronizeMutex {
  fn iid() -> REFGUID { &IID_ISynchronizeMutex }
}

pub trait TSynchronize: TUnknown {
  //  Method Wait
  
  #[allow(non_snake_case)]
  fn wait(&self, flags: DWORD, milliseconds: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronize)).Wait(flags, milliseconds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Signal
  
  #[allow(non_snake_case)]
  fn signal(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronize)).Signal() };
    hr2ret(_hr,_hr)
  }
  
  //  Method Reset
  
  #[allow(non_snake_case)]
  fn reset(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ISynchronize)).Reset() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for Synchronize {
  fn new(ptr: *mut IUnknown) -> Self {
    Synchronize(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for Synchronize {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for Synchronize {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TSynchronize for Synchronize {}

pub struct Synchronize(*mut ISynchronize);

impl HasIID for Synchronize {
  fn iid() -> REFGUID { &IID_ISynchronize }
}

pub trait TWaitMultiple: TUnknown {
  //  Method WaitMultiple
  //  Error: pSync parameter: ANone annotation cannot be used with double indirection
  //  Method AddSynchronize
  
  #[allow(non_snake_case)]
  fn add_synchronize(&self, sync: &mut ISynchronize) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWaitMultiple)).AddSynchronize(sync) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WaitMultiple {
  fn new(ptr: *mut IUnknown) -> Self {
    WaitMultiple(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WaitMultiple {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WaitMultiple {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWaitMultiple for WaitMultiple {}

pub struct WaitMultiple(*mut IWaitMultiple);

impl HasIID for WaitMultiple {
  fn iid() -> REFGUID { &IID_IWaitMultiple }
}

