// This file is autogenerated

use utils::*;

use d2d1_safe::*;
use d2d1_1_safe::*;
use d2d1_2_safe::*;
use dxgi_safe::*;
use dwrite_safe::*;
pub trait TD2D1Device2: TD2D1Device1 {
  //  Method CreateDeviceContext
  
  #[allow(non_snake_case)]
  fn create_device_context2(&self, options: D2D1_DEVICE_CONTEXT_OPTIONS) -> HResult<D2D1DeviceContext2> {
    let mut lv1: *mut ID2D1DeviceContext2 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Device2)).CreateDeviceContext(options, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1DeviceContext2::new(lv1 as *mut _))
  }
  
  //  Method FlushDeviceContexts
  
  #[allow(non_snake_case)]
  fn flush_device_contexts(&self, bitmap: &mut ID2D1Bitmap) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Device2)).FlushDeviceContexts(bitmap) };
    ()
  }
  
  //  Method GetDxgiDevice
  //  Error: dxgiDevice parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for D2D1Device2 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Device2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Device2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Device2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1Device2 {}
impl TD2D1Device for D2D1Device2 {}
impl TD2D1Device1 for D2D1Device2 {}
impl TD2D1Device2 for D2D1Device2 {}

pub struct D2D1Device2(*mut ID2D1Device2);

impl HasIID for D2D1Device2 {
  fn iid() -> REFGUID { &IID_ID2D1Device2 }
}

pub trait TD2D1DeviceContext2: TD2D1DeviceContext1 {
  //  Method CreateInk
  //  Error: ink parameter: ANone annotation cannot be used with double indirection
  //  Method CreateInkStyle
  //  Error: inkStyle parameter: ANone annotation cannot be used with double indirection
  //  Method CreateGradientMesh
  //  Error: gradientMesh parameter: ANone annotation cannot be used with double indirection
  //  Method CreateLookupTable3D
  //  Error: lookupTable parameter: ANone annotation cannot be used with double indirection
  //  Method CreateImageSourceFromDxgi
  //  Error: imageSource parameter: ANone annotation cannot be used with double indirection
  //  Error: surfaces parameter: ANone annotation cannot be used with double indirection
  //  Method GetGradientMeshWorldBounds
  
  #[allow(non_snake_case)]
  fn get_gradient_mesh_world_bounds(&self, gradientMesh: &mut ID2D1GradientMesh, bounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext2)).GetGradientMeshWorldBounds(gradientMesh, bounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawInk
  
  #[allow(non_snake_case)]
  fn draw_ink(&self, ink: &mut ID2D1Ink, brush: &mut ID2D1Brush, inkStyle: &mut ID2D1InkStyle) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext2)).DrawInk(ink, brush, inkStyle) };
    ()
  }
  
  //  Method DrawGradientMesh
  
  #[allow(non_snake_case)]
  fn draw_gradient_mesh(&self, gradientMesh: &mut ID2D1GradientMesh) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext2)).DrawGradientMesh(gradientMesh) };
    ()
  }
  
  //  Method DrawGdiMetafile
  
  #[allow(non_snake_case)]
  fn draw_gdi_metafile2(&self, gdiMetafile: &mut ID2D1GdiMetafile, destinationRectangle: &D2D1_RECT_F, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext2)).DrawGdiMetafile(gdiMetafile, destinationRectangle, sourceRectangle) };
    ()
  }
  
  //  Method CreateTransformedImageSource
  //  Error: transformedImageSource parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for D2D1DeviceContext2 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1DeviceContext2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1DeviceContext2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1DeviceContext2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1DeviceContext2 {}
impl TD2D1RenderTarget for D2D1DeviceContext2 {}
impl TD2D1DeviceContext for D2D1DeviceContext2 {}
impl TD2D1DeviceContext1 for D2D1DeviceContext2 {}
impl TD2D1DeviceContext2 for D2D1DeviceContext2 {}

pub struct D2D1DeviceContext2(*mut ID2D1DeviceContext2);

impl HasIID for D2D1DeviceContext2 {
  fn iid() -> REFGUID { &IID_ID2D1DeviceContext2 }
}

pub trait TD2D1Factory3: TD2D1Factory2 {
  //  Method CreateDevice
  
  #[allow(non_snake_case)]
  fn create_device3<T: TDXGIDevice>(&self, dxgiDevice: &T) -> HResult<D2D1Device2> {
    let mut lv1: *mut ID2D1Device2 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Factory3)).CreateDevice(dxgiDevice.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Device2::new(lv1 as *mut _))
  }
  
  
}

impl TUnknown for D2D1Factory3 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Factory3(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Factory3 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Factory3 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Factory for D2D1Factory3 {}
impl TD2D1Factory1 for D2D1Factory3 {}
impl TD2D1Factory2 for D2D1Factory3 {}
impl TD2D1Factory3 for D2D1Factory3 {}

pub struct D2D1Factory3(*mut ID2D1Factory3);

impl HasIID for D2D1Factory3 {
  fn iid() -> REFGUID { &IID_ID2D1Factory3 }
}

