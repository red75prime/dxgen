// This file is autogenerated

use utils::*;

pub trait TWICBitmapClipper: TWICBitmapSource {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_source: &mut IWICBitmapSource, prc: &WICRect) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapClipper)).Initialize(i_source, prc) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapClipper {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapClipper(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapClipper {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapClipper {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICBitmapClipper {}
impl TWICBitmapClipper for WICBitmapClipper {}

pub struct WICBitmapClipper(*mut IWICBitmapClipper);

impl HasIID for WICBitmapClipper {
  fn iid() -> REFGUID { &IID_IWICBitmapClipper }
}

pub trait TWICBitmapCodecInfo: TWICComponentInfo {
  //  Method GetContainerFormat
  
  #[allow(non_snake_case)]
  fn get_container_format(&self, pguidContainerFormat: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetContainerFormat(pguidContainerFormat) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPixelFormats
  
  #[allow(non_snake_case)]
  fn get_pixel_formats(&self, cFormats: UINT, pguidPixelFormats: &mut GUID, pcActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetPixelFormats(cFormats, pguidPixelFormats, pcActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColorManagementVersion
  
  #[allow(non_snake_case)]
  fn get_color_management_version(&self, cchColorManagementVersion: UINT, wzColorManagementVersion: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetColorManagementVersion(cchColorManagementVersion, wzColorManagementVersion, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDeviceManufacturer
  
  #[allow(non_snake_case)]
  fn get_device_manufacturer(&self, cchDeviceManufacturer: UINT, wzDeviceManufacturer: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetDeviceManufacturer(cchDeviceManufacturer, wzDeviceManufacturer, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDeviceModels
  
  #[allow(non_snake_case)]
  fn get_device_models(&self, cchDeviceModels: UINT, wzDeviceModels: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetDeviceModels(cchDeviceModels, wzDeviceModels, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMimeTypes
  
  #[allow(non_snake_case)]
  fn get_mime_types(&self, cchMimeTypes: UINT, wzMimeTypes: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetMimeTypes(cchMimeTypes, wzMimeTypes, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFileExtensions
  
  #[allow(non_snake_case)]
  fn get_file_extensions(&self, cchFileExtensions: UINT, wzFileExtensions: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).GetFileExtensions(cchFileExtensions, wzFileExtensions, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DoesSupportAnimation
  
  #[allow(non_snake_case)]
  fn does_support_animation(&self, pfSupportAnimation: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).DoesSupportAnimation(pfSupportAnimation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DoesSupportChromakey
  
  #[allow(non_snake_case)]
  fn does_support_chromakey(&self, pfSupportChromakey: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).DoesSupportChromakey(pfSupportChromakey) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DoesSupportLossless
  
  #[allow(non_snake_case)]
  fn does_support_lossless(&self, pfSupportLossless: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).DoesSupportLossless(pfSupportLossless) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DoesSupportMultiframe
  
  #[allow(non_snake_case)]
  fn does_support_multiframe(&self, pfSupportMultiframe: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).DoesSupportMultiframe(pfSupportMultiframe) };
    hr2ret(_hr,_hr)
  }
  
  //  Method MatchesMimeType
  
  #[allow(non_snake_case)]
  fn matches_mime_type(&self, wzMimeType: Cow<str>, pfMatches: &mut BOOL) -> HResult<HRESULT> {
    let lv1: Vec<u16> = str_to_vec_u16(wzMimeType);
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecInfo)).MatchesMimeType(lv1.as_ptr() as LPCWSTR, pfMatches) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapCodecInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapCodecInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapCodecInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapCodecInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICBitmapCodecInfo {}
impl TWICBitmapCodecInfo for WICBitmapCodecInfo {}

pub struct WICBitmapCodecInfo(*mut IWICBitmapCodecInfo);

impl HasIID for WICBitmapCodecInfo {
  fn iid() -> REFGUID { &IID_IWICBitmapCodecInfo }
}

pub trait TWICBitmapCodecProgressNotification: TUnknown {
  //  Method RegisterProgressNotification
  
  #[allow(non_snake_case)]
  fn register_progress_notification(&self, pfnProgressNotification: PFNProgressNotification, pvData: LPVOID, progress_flags: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapCodecProgressNotification)).RegisterProgressNotification(pfnProgressNotification, pvData, progress_flags) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapCodecProgressNotification {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapCodecProgressNotification(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapCodecProgressNotification {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapCodecProgressNotification {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapCodecProgressNotification for WICBitmapCodecProgressNotification {}

pub struct WICBitmapCodecProgressNotification(*mut IWICBitmapCodecProgressNotification);

impl HasIID for WICBitmapCodecProgressNotification {
  fn iid() -> REFGUID { &IID_IWICBitmapCodecProgressNotification }
}

pub trait TWICBitmapDecoderInfo: TWICBitmapCodecInfo {
  //  Method GetPatterns
  
  #[allow(non_snake_case)]
  fn get_patterns(&self, cbSizePatterns: UINT, patterns: &mut WICBitmapPattern, pcPatterns: &mut UINT, pcbPatternsActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoderInfo)).GetPatterns(cbSizePatterns, patterns, pcPatterns, pcbPatternsActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method MatchesPattern
  
  #[allow(non_snake_case)]
  fn matches_pattern(&self, i_stream: &mut IStream, pfMatches: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoderInfo)).MatchesPattern(i_stream, pfMatches) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CreateInstance
  //  Error: ppIBitmapDecoder parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICBitmapDecoderInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapDecoderInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapDecoderInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapDecoderInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICBitmapDecoderInfo {}
impl TWICBitmapCodecInfo for WICBitmapDecoderInfo {}
impl TWICBitmapDecoderInfo for WICBitmapDecoderInfo {}

pub struct WICBitmapDecoderInfo(*mut IWICBitmapDecoderInfo);

impl HasIID for WICBitmapDecoderInfo {
  fn iid() -> REFGUID { &IID_IWICBitmapDecoderInfo }
}

pub trait TWICBitmapDecoder: TUnknown {
  //  Method QueryCapability
  
  #[allow(non_snake_case)]
  fn query_capability(&self, i_stream: &mut IStream, pdwCapability: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoder)).QueryCapability(i_stream, pdwCapability) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_stream: &mut IStream, cacheOptions: WICDecodeOptions) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoder)).Initialize(i_stream, cacheOptions) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetContainerFormat
  
  #[allow(non_snake_case)]
  fn get_container_format(&self, pguidContainerFormat: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoder)).GetContainerFormat(pguidContainerFormat) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDecoderInfo
  //  Error: ppIDecoderInfo parameter: ANone annotation cannot be used with double indirection
  //  Method CopyPalette
  
  #[allow(non_snake_case)]
  fn copy_palette(&self, i_palette: &mut IWICPalette) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoder)).CopyPalette(i_palette) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMetadataQueryReader
  //  Error: ppIMetadataQueryReader parameter: ANone annotation cannot be used with double indirection
  //  Method GetPreview
  //  Error: ppIBitmapSource parameter: ANone annotation cannot be used with double indirection
  //  Method GetColorContexts
  //  Error: ppIColorContexts parameter: ANone annotation cannot be used with double indirection
  //  Method GetThumbnail
  //  Error: ppIThumbnail parameter: ANone annotation cannot be used with double indirection
  //  Method GetFrameCount
  
  #[allow(non_snake_case)]
  fn get_frame_count(&self, count: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapDecoder)).GetFrameCount(count) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFrame
  //  Error: ppIBitmapFrame parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICBitmapDecoder {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapDecoder(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapDecoder {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapDecoder {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapDecoder for WICBitmapDecoder {}

pub struct WICBitmapDecoder(*mut IWICBitmapDecoder);

impl HasIID for WICBitmapDecoder {
  fn iid() -> REFGUID { &IID_IWICBitmapDecoder }
}

pub trait TWICBitmapEncoderInfo: TWICBitmapCodecInfo {
  //  Method CreateInstance
  //  Error: ppIBitmapEncoder parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICBitmapEncoderInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapEncoderInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapEncoderInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapEncoderInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICBitmapEncoderInfo {}
impl TWICBitmapCodecInfo for WICBitmapEncoderInfo {}
impl TWICBitmapEncoderInfo for WICBitmapEncoderInfo {}

pub struct WICBitmapEncoderInfo(*mut IWICBitmapEncoderInfo);

impl HasIID for WICBitmapEncoderInfo {
  fn iid() -> REFGUID { &IID_IWICBitmapEncoderInfo }
}

pub trait TWICBitmapEncoder: TUnknown {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_stream: &mut IStream, cacheOption: WICBitmapEncoderCacheOption) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapEncoder)).Initialize(i_stream, cacheOption) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetContainerFormat
  
  #[allow(non_snake_case)]
  fn get_container_format(&self, pguidContainerFormat: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapEncoder)).GetContainerFormat(pguidContainerFormat) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEncoderInfo
  //  Error: ppIEncoderInfo parameter: ANone annotation cannot be used with double indirection
  //  Method SetColorContexts
  //  Error: ppIColorContext parameter: ANone annotation cannot be used with double indirection
  //  Method SetPalette
  
  #[allow(non_snake_case)]
  fn set_palette(&self, i_palette: &mut IWICPalette) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapEncoder)).SetPalette(i_palette) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetThumbnail
  
  #[allow(non_snake_case)]
  fn set_thumbnail(&self, i_thumbnail: &mut IWICBitmapSource) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapEncoder)).SetThumbnail(i_thumbnail) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetPreview
  
  #[allow(non_snake_case)]
  fn set_preview(&self, i_preview: &mut IWICBitmapSource) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapEncoder)).SetPreview(i_preview) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CreateNewFrame
  //  Error: ppIEncoderOptions parameter: ANone annotation cannot be used with double indirection
  //  Error: ppIFrameEncode parameter: ANone annotation cannot be used with double indirection
  //  Method Commit
  
  #[allow(non_snake_case)]
  fn commit(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapEncoder)).Commit() };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMetadataQueryWriter
  //  Error: ppIMetadataQueryWriter parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICBitmapEncoder {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapEncoder(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapEncoder {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapEncoder {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapEncoder for WICBitmapEncoder {}

pub struct WICBitmapEncoder(*mut IWICBitmapEncoder);

impl HasIID for WICBitmapEncoder {
  fn iid() -> REFGUID { &IID_IWICBitmapEncoder }
}

pub trait TWICBitmapFlipRotator: TWICBitmapSource {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_source: &mut IWICBitmapSource, options: WICBitmapTransformOptions) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFlipRotator)).Initialize(i_source, options) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapFlipRotator {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapFlipRotator(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapFlipRotator {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapFlipRotator {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICBitmapFlipRotator {}
impl TWICBitmapFlipRotator for WICBitmapFlipRotator {}

pub struct WICBitmapFlipRotator(*mut IWICBitmapFlipRotator);

impl HasIID for WICBitmapFlipRotator {
  fn iid() -> REFGUID { &IID_IWICBitmapFlipRotator }
}

pub trait TWICBitmapFrameDecode: TWICBitmapSource {
  //  Method GetMetadataQueryReader
  //  Error: ppIMetadataQueryReader parameter: ANone annotation cannot be used with double indirection
  //  Method GetColorContexts
  //  Error: ppIColorContexts parameter: ANone annotation cannot be used with double indirection
  //  Method GetThumbnail
  //  Error: ppIThumbnail parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICBitmapFrameDecode {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapFrameDecode(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapFrameDecode {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapFrameDecode {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICBitmapFrameDecode {}
impl TWICBitmapFrameDecode for WICBitmapFrameDecode {}

pub struct WICBitmapFrameDecode(*mut IWICBitmapFrameDecode);

impl HasIID for WICBitmapFrameDecode {
  fn iid() -> REFGUID { &IID_IWICBitmapFrameDecode }
}

pub trait TWICBitmapFrameEncode: TUnknown {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_encoder_options: &mut IPropertyBag2) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).Initialize(i_encoder_options) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetSize
  
  #[allow(non_snake_case)]
  fn set_size(&self, uiWidth: UINT, uiHeight: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).SetSize(uiWidth, uiHeight) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetResolution
  
  #[allow(non_snake_case)]
  fn set_resolution(&self, dpiX: f64, dpiY: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).SetResolution(dpiX, dpiY) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetPixelFormat
  
  #[allow(non_snake_case)]
  fn set_pixel_format(&self, pixel_format: &mut WICPixelFormatGUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).SetPixelFormat(pixel_format) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetColorContexts
  //  Error: ppIColorContext parameter: ANone annotation cannot be used with double indirection
  //  Method SetPalette
  
  #[allow(non_snake_case)]
  fn set_palette(&self, i_palette: &mut IWICPalette) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).SetPalette(i_palette) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetThumbnail
  
  #[allow(non_snake_case)]
  fn set_thumbnail(&self, i_thumbnail: &mut IWICBitmapSource) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).SetThumbnail(i_thumbnail) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WritePixels
  
  #[allow(non_snake_case)]
  fn write_pixels(&self, lineCount: UINT, cbStride: UINT, cbBufferSize: UINT, pbPixels: &mut BYTE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).WritePixels(lineCount, cbStride, cbBufferSize, pbPixels) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WriteSource
  
  #[allow(non_snake_case)]
  fn write_source(&self, i_bitmap_source: &mut IWICBitmapSource, prc: &mut WICRect) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).WriteSource(i_bitmap_source, prc) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Commit
  
  #[allow(non_snake_case)]
  fn commit(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapFrameEncode)).Commit() };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMetadataQueryWriter
  //  Error: ppIMetadataQueryWriter parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICBitmapFrameEncode {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapFrameEncode(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapFrameEncode {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapFrameEncode {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapFrameEncode for WICBitmapFrameEncode {}

pub struct WICBitmapFrameEncode(*mut IWICBitmapFrameEncode);

impl HasIID for WICBitmapFrameEncode {
  fn iid() -> REFGUID { &IID_IWICBitmapFrameEncode }
}

pub trait TWICBitmapLock: TUnknown {
  //  Method GetSize
  
  #[allow(non_snake_case)]
  fn get_size(&self, puiWidth: &mut UINT, puiHeight: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapLock)).GetSize(puiWidth, puiHeight) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetStride
  
  #[allow(non_snake_case)]
  fn get_stride(&self, pcbStride: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapLock)).GetStride(pcbStride) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDataPointer
  
  #[allow(non_snake_case)]
  fn get_data_pointer(&self, pcbBufferSize: &mut UINT, ppbData: &mut WICInProcPointer) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapLock)).GetDataPointer(pcbBufferSize, ppbData) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPixelFormat
  
  #[allow(non_snake_case)]
  fn get_pixel_format(&self, pixel_format: &mut WICPixelFormatGUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapLock)).GetPixelFormat(pixel_format) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapLock {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapLock(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapLock {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapLock {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapLock for WICBitmapLock {}

pub struct WICBitmapLock(*mut IWICBitmapLock);

impl HasIID for WICBitmapLock {
  fn iid() -> REFGUID { &IID_IWICBitmapLock }
}

pub trait TWICBitmapScaler: TWICBitmapSource {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_source: &mut IWICBitmapSource, uiWidth: UINT, uiHeight: UINT, mode: WICBitmapInterpolationMode) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapScaler)).Initialize(i_source, uiWidth, uiHeight, mode) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapScaler {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapScaler(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapScaler {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapScaler {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICBitmapScaler {}
impl TWICBitmapScaler for WICBitmapScaler {}

pub struct WICBitmapScaler(*mut IWICBitmapScaler);

impl HasIID for WICBitmapScaler {
  fn iid() -> REFGUID { &IID_IWICBitmapScaler }
}

pub trait TWICBitmapSourceTransform: TUnknown {
  //  Method CopyPixels
  
  #[allow(non_snake_case)]
  fn copy_pixels(&self, prc: &WICRect, uiWidth: UINT, uiHeight: UINT, pguidDstFormat: &mut WICPixelFormatGUID, dstTransform: WICBitmapTransformOptions, nStride: UINT, cbBufferSize: UINT, pbBuffer: &mut BYTE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSourceTransform)).CopyPixels(prc, uiWidth, uiHeight, pguidDstFormat, dstTransform, nStride, cbBufferSize, pbBuffer) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetClosestSize
  
  #[allow(non_snake_case)]
  fn get_closest_size(&self, puiWidth: &mut UINT, puiHeight: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSourceTransform)).GetClosestSize(puiWidth, puiHeight) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetClosestPixelFormat
  
  #[allow(non_snake_case)]
  fn get_closest_pixel_format(&self, pguidDstFormat: &mut WICPixelFormatGUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSourceTransform)).GetClosestPixelFormat(pguidDstFormat) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DoesSupportTransform
  
  #[allow(non_snake_case)]
  fn does_support_transform(&self, dstTransform: WICBitmapTransformOptions, pfIsSupported: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSourceTransform)).DoesSupportTransform(dstTransform, pfIsSupported) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapSourceTransform {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapSourceTransform(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapSourceTransform {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapSourceTransform {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSourceTransform for WICBitmapSourceTransform {}

pub struct WICBitmapSourceTransform(*mut IWICBitmapSourceTransform);

impl HasIID for WICBitmapSourceTransform {
  fn iid() -> REFGUID { &IID_IWICBitmapSourceTransform }
}

pub trait TWICBitmapSource: TUnknown {
  //  Method GetSize
  
  #[allow(non_snake_case)]
  fn get_size(&self, puiWidth: &mut UINT, puiHeight: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSource)).GetSize(puiWidth, puiHeight) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPixelFormat
  
  #[allow(non_snake_case)]
  fn get_pixel_format(&self, pixel_format: &mut WICPixelFormatGUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSource)).GetPixelFormat(pixel_format) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetResolution
  
  #[allow(non_snake_case)]
  fn get_resolution(&self, dpi_x: &mut f64, dpi_y: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSource)).GetResolution(dpi_x, dpi_y) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyPalette
  
  #[allow(non_snake_case)]
  fn copy_palette(&self, i_palette: &mut IWICPalette) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSource)).CopyPalette(i_palette) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyPixels
  
  #[allow(non_snake_case)]
  fn copy_pixels(&self, prc: &WICRect, cbStride: UINT, cbBufferSize: UINT, pbBuffer: &mut BYTE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmapSource)).CopyPixels(prc, cbStride, cbBufferSize, pbBuffer) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmapSource {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmapSource(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmapSource {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmapSource {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICBitmapSource {}

pub struct WICBitmapSource(*mut IWICBitmapSource);

impl HasIID for WICBitmapSource {
  fn iid() -> REFGUID { &IID_IWICBitmapSource }
}

pub trait TWICBitmap: TWICBitmapSource {
  //  Method Lock
  //  Error: ppILock parameter: ANone annotation cannot be used with double indirection
  //  Method SetPalette
  
  #[allow(non_snake_case)]
  fn set_palette(&self, i_palette: &mut IWICPalette) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmap)).SetPalette(i_palette) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetResolution
  
  #[allow(non_snake_case)]
  fn set_resolution(&self, dpiX: f64, dpiY: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICBitmap)).SetResolution(dpiX, dpiY) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICBitmap {
  fn new(ptr: *mut IUnknown) -> Self {
    WICBitmap(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICBitmap {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICBitmap {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICBitmap {}
impl TWICBitmap for WICBitmap {}

pub struct WICBitmap(*mut IWICBitmap);

impl HasIID for WICBitmap {
  fn iid() -> REFGUID { &IID_IWICBitmap }
}

pub trait TWICColorContext: TUnknown {
  //  Method InitializeFromFilename
  
  #[allow(non_snake_case)]
  fn initialize_from_filename(&self, wzFilename: Cow<str>) -> HResult<HRESULT> {
    let lv1: Vec<u16> = str_to_vec_u16(wzFilename);
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorContext)).InitializeFromFilename(lv1.as_ptr() as LPCWSTR) };
    hr2ret(_hr,_hr)
  }
  
  //  Method InitializeFromMemory
  
  #[allow(non_snake_case)]
  fn initialize_from_memory(&self, pbBuffer: &BYTE, cbBufferSize: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorContext)).InitializeFromMemory(pbBuffer, cbBufferSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method InitializeFromExifColorSpace
  
  #[allow(non_snake_case)]
  fn initialize_from_exif_color_space(&self, value: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorContext)).InitializeFromExifColorSpace(value) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetType
  
  #[allow(non_snake_case)]
  fn get_type(&self, type_: &mut WICColorContextType) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorContext)).GetType(type_) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetProfileBytes
  
  #[allow(non_snake_case)]
  fn get_profile_bytes(&self, cbBuffer: UINT, pbBuffer: &mut BYTE, pcbActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorContext)).GetProfileBytes(cbBuffer, pbBuffer, pcbActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetExifColorSpace
  
  #[allow(non_snake_case)]
  fn get_exif_color_space(&self, value: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorContext)).GetExifColorSpace(value) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICColorContext {
  fn new(ptr: *mut IUnknown) -> Self {
    WICColorContext(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICColorContext {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICColorContext {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICColorContext for WICColorContext {}

pub struct WICColorContext(*mut IWICColorContext);

impl HasIID for WICColorContext {
  fn iid() -> REFGUID { &IID_IWICColorContext }
}

pub trait TWICColorTransform: TWICBitmapSource {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_bitmap_source: &mut IWICBitmapSource, i_context_source: &mut IWICColorContext, i_context_dest: &mut IWICColorContext, pixelFmtDest: REFWICPixelFormatGUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICColorTransform)).Initialize(i_bitmap_source, i_context_source, i_context_dest, pixelFmtDest) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICColorTransform {
  fn new(ptr: *mut IUnknown) -> Self {
    WICColorTransform(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICColorTransform {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICColorTransform {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICColorTransform {}
impl TWICColorTransform for WICColorTransform {}

pub struct WICColorTransform(*mut IWICColorTransform);

impl HasIID for WICColorTransform {
  fn iid() -> REFGUID { &IID_IWICColorTransform }
}

pub trait TWICComponentInfo: TUnknown {
  //  Method GetComponentType
  
  #[allow(non_snake_case)]
  fn get_component_type(&self, type_: &mut WICComponentType) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetComponentType(type_) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCLSID
  
  #[allow(non_snake_case)]
  fn get_c_l_s_i_d(&self, pclsid: &mut CLSID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetCLSID(pclsid) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSigningStatus
  
  #[allow(non_snake_case)]
  fn get_signing_status(&self, status: &mut DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetSigningStatus(status) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetAuthor
  
  #[allow(non_snake_case)]
  fn get_author(&self, cchAuthor: UINT, wzAuthor: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetAuthor(cchAuthor, wzAuthor, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetVendorGUID
  
  #[allow(non_snake_case)]
  fn get_vendor_g_u_i_d(&self, pguidVendor: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetVendorGUID(pguidVendor) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetVersion
  
  #[allow(non_snake_case)]
  fn get_version(&self, cchVersion: UINT, wzVersion: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetVersion(cchVersion, wzVersion, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSpecVersion
  
  #[allow(non_snake_case)]
  fn get_spec_version(&self, cchSpecVersion: UINT, wzSpecVersion: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetSpecVersion(cchSpecVersion, wzSpecVersion, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFriendlyName
  
  #[allow(non_snake_case)]
  fn get_friendly_name(&self, cchFriendlyName: UINT, wzFriendlyName: &mut WCHAR, pcchActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICComponentInfo)).GetFriendlyName(cchFriendlyName, wzFriendlyName, pcchActual) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICComponentInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    WICComponentInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICComponentInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICComponentInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICComponentInfo {}

pub struct WICComponentInfo(*mut IWICComponentInfo);

impl HasIID for WICComponentInfo {
  fn iid() -> REFGUID { &IID_IWICComponentInfo }
}

pub trait TWICDdsDecoder: TUnknown {
  //  Method GetParameters
  
  #[allow(non_snake_case)]
  fn get_parameters(&self, parameters: &mut WICDdsParameters) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDdsDecoder)).GetParameters(parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFrame
  //  Error: ppIBitmapFrame parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICDdsDecoder {
  fn new(ptr: *mut IUnknown) -> Self {
    WICDdsDecoder(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICDdsDecoder {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICDdsDecoder {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICDdsDecoder for WICDdsDecoder {}

pub struct WICDdsDecoder(*mut IWICDdsDecoder);

impl HasIID for WICDdsDecoder {
  fn iid() -> REFGUID { &IID_IWICDdsDecoder }
}

pub trait TWICDdsEncoder: TUnknown {
  //  Method SetParameters
  
  #[allow(non_snake_case)]
  fn set_parameters(&self, parameters: &mut WICDdsParameters) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDdsEncoder)).SetParameters(parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetParameters
  
  #[allow(non_snake_case)]
  fn get_parameters(&self, parameters: &mut WICDdsParameters) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDdsEncoder)).GetParameters(parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CreateNewFrame
  //  Error: ppIFrameEncode parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICDdsEncoder {
  fn new(ptr: *mut IUnknown) -> Self {
    WICDdsEncoder(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICDdsEncoder {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICDdsEncoder {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICDdsEncoder for WICDdsEncoder {}

pub struct WICDdsEncoder(*mut IWICDdsEncoder);

impl HasIID for WICDdsEncoder {
  fn iid() -> REFGUID { &IID_IWICDdsEncoder }
}

pub trait TWICDdsFrameDecode: TUnknown {
  //  Method GetSizeInBlocks
  
  #[allow(non_snake_case)]
  fn get_size_in_blocks(&self, width_in_blocks: &mut UINT, height_in_blocks: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDdsFrameDecode)).GetSizeInBlocks(width_in_blocks, height_in_blocks) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFormatInfo
  
  #[allow(non_snake_case)]
  fn get_format_info(&self, format_info: &mut WICDdsFormatInfo) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDdsFrameDecode)).GetFormatInfo(format_info) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyBlocks
  
  #[allow(non_snake_case)]
  fn copy_blocks(&self, prcBoundsInBlocks: &WICRect, cbStride: UINT, cbBufferSize: UINT, pbBuffer: &mut BYTE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDdsFrameDecode)).CopyBlocks(prcBoundsInBlocks, cbStride, cbBufferSize, pbBuffer) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICDdsFrameDecode {
  fn new(ptr: *mut IUnknown) -> Self {
    WICDdsFrameDecode(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICDdsFrameDecode {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICDdsFrameDecode {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICDdsFrameDecode for WICDdsFrameDecode {}

pub struct WICDdsFrameDecode(*mut IWICDdsFrameDecode);

impl HasIID for WICDdsFrameDecode {
  fn iid() -> REFGUID { &IID_IWICDdsFrameDecode }
}

pub trait TWICDevelopRawNotificationCallback: TUnknown {
  //  Method Notify
  
  #[allow(non_snake_case)]
  fn notify(&self, notification_mask: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRawNotificationCallback)).Notify(notification_mask) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICDevelopRawNotificationCallback {
  fn new(ptr: *mut IUnknown) -> Self {
    WICDevelopRawNotificationCallback(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICDevelopRawNotificationCallback {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICDevelopRawNotificationCallback {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICDevelopRawNotificationCallback for WICDevelopRawNotificationCallback {}

pub struct WICDevelopRawNotificationCallback(*mut IWICDevelopRawNotificationCallback);

impl HasIID for WICDevelopRawNotificationCallback {
  fn iid() -> REFGUID { &IID_IWICDevelopRawNotificationCallback }
}

pub trait TWICDevelopRaw: TWICBitmapFrameDecode {
  //  Method QueryRawCapabilitiesInfo
  
  #[allow(non_snake_case)]
  fn query_raw_capabilities_info(&self, info: &mut WICRawCapabilitiesInfo) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).QueryRawCapabilitiesInfo(info) };
    hr2ret(_hr,_hr)
  }
  
  //  Method LoadParameterSet
  
  #[allow(non_snake_case)]
  fn load_parameter_set(&self, parameter_set: WICRawParameterSet) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).LoadParameterSet(parameter_set) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCurrentParameterSet
  //  Error: ppCurrentParameterSet parameter: ANone annotation cannot be used with double indirection
  //  Method SetExposureCompensation
  
  #[allow(non_snake_case)]
  fn set_exposure_compensation(&self, ev: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetExposureCompensation(ev) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetExposureCompensation
  
  #[allow(non_snake_case)]
  fn get_exposure_compensation(&self, e_v: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetExposureCompensation(e_v) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetWhitePointRGB
  
  #[allow(non_snake_case)]
  fn set_white_point_r_g_b(&self, red: UINT, green: UINT, blue: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetWhitePointRGB(red, green, blue) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetWhitePointRGB
  
  #[allow(non_snake_case)]
  fn get_white_point_r_g_b(&self, red: &mut UINT, green: &mut UINT, blue: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetWhitePointRGB(red, green, blue) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetNamedWhitePoint
  
  #[allow(non_snake_case)]
  fn set_named_white_point(&self, white_point: WICNamedWhitePoint) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetNamedWhitePoint(white_point) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetNamedWhitePoint
  
  #[allow(non_snake_case)]
  fn get_named_white_point(&self, white_point: &mut WICNamedWhitePoint) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetNamedWhitePoint(white_point) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetWhitePointKelvin
  
  #[allow(non_snake_case)]
  fn set_white_point_kelvin(&self, white_point_kelvin: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetWhitePointKelvin(white_point_kelvin) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetWhitePointKelvin
  
  #[allow(non_snake_case)]
  fn get_white_point_kelvin(&self, white_point_kelvin: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetWhitePointKelvin(white_point_kelvin) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetKelvinRangeInfo
  
  #[allow(non_snake_case)]
  fn get_kelvin_range_info(&self, min_kelvin_temp: &mut UINT, max_kelvin_temp: &mut UINT, kelvin_temp_step_value: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetKelvinRangeInfo(min_kelvin_temp, max_kelvin_temp, kelvin_temp_step_value) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetContrast
  
  #[allow(non_snake_case)]
  fn set_contrast(&self, contrast: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetContrast(contrast) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetContrast
  
  #[allow(non_snake_case)]
  fn get_contrast(&self, contrast: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetContrast(contrast) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetGamma
  
  #[allow(non_snake_case)]
  fn set_gamma(&self, gamma: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetGamma(gamma) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetGamma
  
  #[allow(non_snake_case)]
  fn get_gamma(&self, gamma: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetGamma(gamma) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetSharpness
  
  #[allow(non_snake_case)]
  fn set_sharpness(&self, sharpness: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetSharpness(sharpness) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSharpness
  
  #[allow(non_snake_case)]
  fn get_sharpness(&self, sharpness: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetSharpness(sharpness) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetSaturation
  
  #[allow(non_snake_case)]
  fn set_saturation(&self, saturation: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetSaturation(saturation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSaturation
  
  #[allow(non_snake_case)]
  fn get_saturation(&self, saturation: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetSaturation(saturation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTint
  
  #[allow(non_snake_case)]
  fn set_tint(&self, tint: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetTint(tint) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetTint
  
  #[allow(non_snake_case)]
  fn get_tint(&self, tint: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetTint(tint) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetNoiseReduction
  
  #[allow(non_snake_case)]
  fn set_noise_reduction(&self, noise_reduction: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetNoiseReduction(noise_reduction) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetNoiseReduction
  
  #[allow(non_snake_case)]
  fn get_noise_reduction(&self, noise_reduction: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetNoiseReduction(noise_reduction) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetDestinationColorContext
  
  #[allow(non_snake_case)]
  fn set_destination_color_context(&self, color_context: &mut IWICColorContext) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetDestinationColorContext(color_context) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetToneCurve
  
  #[allow(non_snake_case)]
  fn set_tone_curve(&self, cbToneCurveSize: UINT, tone_curve: &WICRawToneCurve) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetToneCurve(cbToneCurveSize, tone_curve) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetToneCurve
  
  #[allow(non_snake_case)]
  fn get_tone_curve(&self, cbToneCurveBufferSize: UINT, tone_curve: &mut WICRawToneCurve, pcbActualToneCurveBufferSize: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetToneCurve(cbToneCurveBufferSize, tone_curve, pcbActualToneCurveBufferSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetRotation
  
  #[allow(non_snake_case)]
  fn set_rotation(&self, rotation: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetRotation(rotation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetRotation
  
  #[allow(non_snake_case)]
  fn get_rotation(&self, rotation: &mut f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetRotation(rotation) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetRenderMode
  
  #[allow(non_snake_case)]
  fn set_render_mode(&self, render_mode: WICRawRenderMode) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetRenderMode(render_mode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetRenderMode
  
  #[allow(non_snake_case)]
  fn get_render_mode(&self, render_mode: &mut WICRawRenderMode) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).GetRenderMode(render_mode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetNotificationCallback
  
  #[allow(non_snake_case)]
  fn set_notification_callback(&self, callback: &mut IWICDevelopRawNotificationCallback) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICDevelopRaw)).SetNotificationCallback(callback) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICDevelopRaw {
  fn new(ptr: *mut IUnknown) -> Self {
    WICDevelopRaw(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICDevelopRaw {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICDevelopRaw {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICDevelopRaw {}
impl TWICBitmapFrameDecode for WICDevelopRaw {}
impl TWICDevelopRaw for WICDevelopRaw {}

pub struct WICDevelopRaw(*mut IWICDevelopRaw);

impl HasIID for WICDevelopRaw {
  fn iid() -> REFGUID { &IID_IWICDevelopRaw }
}

pub trait TWICEnumMetadataItem: TUnknown {
  //  Method Next
  
  #[allow(non_snake_case)]
  fn next(&self, celt: ULONG, rgeltSchema: &mut PROPVARIANT, rgeltId: &mut PROPVARIANT, rgeltValue: &mut PROPVARIANT, pceltFetched: &mut ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICEnumMetadataItem)).Next(celt, rgeltSchema, rgeltId, rgeltValue, pceltFetched) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Skip
  
  #[allow(non_snake_case)]
  fn skip(&self, celt: ULONG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICEnumMetadataItem)).Skip(celt) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Reset
  
  #[allow(non_snake_case)]
  fn reset(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICEnumMetadataItem)).Reset() };
    hr2ret(_hr,_hr)
  }
  
  //  Method Clone
  //  Error: ppIEnumMetadataItem parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICEnumMetadataItem {
  fn new(ptr: *mut IUnknown) -> Self {
    WICEnumMetadataItem(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICEnumMetadataItem {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICEnumMetadataItem {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICEnumMetadataItem for WICEnumMetadataItem {}

pub struct WICEnumMetadataItem(*mut IWICEnumMetadataItem);

impl HasIID for WICEnumMetadataItem {
  fn iid() -> REFGUID { &IID_IWICEnumMetadataItem }
}

pub trait TWICFastMetadataEncoder: TUnknown {
  //  Method Commit
  
  #[allow(non_snake_case)]
  fn commit(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICFastMetadataEncoder)).Commit() };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMetadataQueryWriter
  //  Error: ppIMetadataQueryWriter parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICFastMetadataEncoder {
  fn new(ptr: *mut IUnknown) -> Self {
    WICFastMetadataEncoder(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICFastMetadataEncoder {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICFastMetadataEncoder {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICFastMetadataEncoder for WICFastMetadataEncoder {}

pub struct WICFastMetadataEncoder(*mut IWICFastMetadataEncoder);

impl HasIID for WICFastMetadataEncoder {
  fn iid() -> REFGUID { &IID_IWICFastMetadataEncoder }
}

pub trait TWICFormatConverterInfo: TWICComponentInfo {
  //  Method GetPixelFormats
  
  #[allow(non_snake_case)]
  fn get_pixel_formats(&self, cFormats: UINT, pixel_format_g_u_i_ds: &mut WICPixelFormatGUID, pcActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICFormatConverterInfo)).GetPixelFormats(cFormats, pixel_format_g_u_i_ds, pcActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CreateInstance
  //  Error: ppIConverter parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICFormatConverterInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    WICFormatConverterInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICFormatConverterInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICFormatConverterInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICFormatConverterInfo {}
impl TWICFormatConverterInfo for WICFormatConverterInfo {}

pub struct WICFormatConverterInfo(*mut IWICFormatConverterInfo);

impl HasIID for WICFormatConverterInfo {
  fn iid() -> REFGUID { &IID_IWICFormatConverterInfo }
}

pub trait TWICFormatConverter: TWICBitmapSource {
  //  Method Initialize
  
  #[allow(non_snake_case)]
  fn initialize(&self, i_source: &mut IWICBitmapSource, dstFormat: REFWICPixelFormatGUID, dither: WICBitmapDitherType, i_palette: &mut IWICPalette, alphaThresholdPercent: f64, paletteTranslate: WICBitmapPaletteType) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICFormatConverter)).Initialize(i_source, dstFormat, dither, i_palette, alphaThresholdPercent, paletteTranslate) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CanConvert
  
  #[allow(non_snake_case)]
  fn can_convert(&self, srcPixelFormat: REFWICPixelFormatGUID, dstPixelFormat: REFWICPixelFormatGUID, pfCanConvert: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICFormatConverter)).CanConvert(srcPixelFormat, dstPixelFormat, pfCanConvert) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICFormatConverter {
  fn new(ptr: *mut IUnknown) -> Self {
    WICFormatConverter(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICFormatConverter {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICFormatConverter {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICFormatConverter {}
impl TWICFormatConverter for WICFormatConverter {}

pub struct WICFormatConverter(*mut IWICFormatConverter);

impl HasIID for WICFormatConverter {
  fn iid() -> REFGUID { &IID_IWICFormatConverter }
}

pub trait TWICImageEncoder: TUnknown {
  //  Method WriteFrame
  
  #[allow(non_snake_case)]
  fn write_frame(&self, image: &mut ID2D1Image, frame_encode: &mut IWICBitmapFrameEncode, image_parameters: &WICImageParameters) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICImageEncoder)).WriteFrame(image, frame_encode, image_parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WriteFrameThumbnail
  
  #[allow(non_snake_case)]
  fn write_frame_thumbnail(&self, image: &mut ID2D1Image, frame_encode: &mut IWICBitmapFrameEncode, image_parameters: &WICImageParameters) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICImageEncoder)).WriteFrameThumbnail(image, frame_encode, image_parameters) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WriteThumbnail
  
  #[allow(non_snake_case)]
  fn write_thumbnail(&self, image: &mut ID2D1Image, encoder: &mut IWICBitmapEncoder, image_parameters: &WICImageParameters) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICImageEncoder)).WriteThumbnail(image, encoder, image_parameters) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICImageEncoder {
  fn new(ptr: *mut IUnknown) -> Self {
    WICImageEncoder(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICImageEncoder {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICImageEncoder {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICImageEncoder for WICImageEncoder {}

pub struct WICImageEncoder(*mut IWICImageEncoder);

impl HasIID for WICImageEncoder {
  fn iid() -> REFGUID { &IID_IWICImageEncoder }
}

pub trait TWICImagingFactory2: TWICImagingFactory {
  //  Method CreateImageEncoder
  //  Error: ppWICImageEncoder parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICImagingFactory2 {
  fn new(ptr: *mut IUnknown) -> Self {
    WICImagingFactory2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICImagingFactory2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICImagingFactory2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICImagingFactory for WICImagingFactory2 {}
impl TWICImagingFactory2 for WICImagingFactory2 {}

pub struct WICImagingFactory2(*mut IWICImagingFactory2);

impl HasIID for WICImagingFactory2 {
  fn iid() -> REFGUID { &IID_IWICImagingFactory2 }
}

pub trait TWICImagingFactory: TUnknown {
  //  Method CreateDecoderFromFilename
  //  Error: ppIDecoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreateDecoderFromStream
  //  Error: ppIDecoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreateDecoderFromFileHandle
  //  Error: ppIDecoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreateComponentInfo
  //  Error: ppIInfo parameter: ANone annotation cannot be used with double indirection
  //  Method CreateDecoder
  //  Error: ppIDecoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreateEncoder
  //  Error: ppIEncoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreatePalette
  //  Error: ppIPalette parameter: ANone annotation cannot be used with double indirection
  //  Method CreateFormatConverter
  //  Error: ppIFormatConverter parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapScaler
  //  Error: ppIBitmapScaler parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapClipper
  //  Error: ppIBitmapClipper parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFlipRotator
  //  Error: ppIBitmapFlipRotator parameter: ANone annotation cannot be used with double indirection
  //  Method CreateStream
  //  Error: ppIWICStream parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorContext
  //  Error: ppIWICColorContext parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorTransformer
  //  Error: ppIWICColorTransform parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmap
  //  Error: ppIBitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromSource
  //  Error: ppIBitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromSourceRect
  //  Error: ppIBitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromMemory
  //  Error: ppIBitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromHBITMAP
  //  Error: ppIBitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromHICON
  //  Error: ppIBitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateComponentEnumerator
  //  Error: ppIEnumUnknown parameter: ANone annotation cannot be used with double indirection
  //  Method CreateFastMetadataEncoderFromDecoder
  //  Error: ppIFastEncoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreateFastMetadataEncoderFromFrameDecode
  //  Error: ppIFastEncoder parameter: ANone annotation cannot be used with double indirection
  //  Method CreateQueryWriter
  //  Error: ppIQueryWriter parameter: ANone annotation cannot be used with double indirection
  //  Method CreateQueryWriterFromReader
  //  Error: ppIQueryWriter parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICImagingFactory {
  fn new(ptr: *mut IUnknown) -> Self {
    WICImagingFactory(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICImagingFactory {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICImagingFactory {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICImagingFactory for WICImagingFactory {}

pub struct WICImagingFactory(*mut IWICImagingFactory);

impl HasIID for WICImagingFactory {
  fn iid() -> REFGUID { &IID_IWICImagingFactory }
}

pub trait TWICJpegFrameDecode: TUnknown {
  //  Method DoesSupportIndexing
  
  #[allow(non_snake_case)]
  fn does_support_indexing(&self, pfIndexingSupported: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).DoesSupportIndexing(pfIndexingSupported) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetIndexing
  
  #[allow(non_snake_case)]
  fn set_indexing(&self, options: WICJpegIndexingOptions, horizontalIntervalSize: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).SetIndexing(options, horizontalIntervalSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ClearIndexing
  
  #[allow(non_snake_case)]
  fn clear_indexing(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).ClearIndexing() };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetAcHuffmanTable
  
  #[allow(non_snake_case)]
  fn get_ac_huffman_table(&self, scanIndex: UINT, tableIndex: UINT, ac_huffman_table: &mut DXGI_JPEG_AC_HUFFMAN_TABLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).GetAcHuffmanTable(scanIndex, tableIndex, ac_huffman_table) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDcHuffmanTable
  
  #[allow(non_snake_case)]
  fn get_dc_huffman_table(&self, scanIndex: UINT, tableIndex: UINT, dc_huffman_table: &mut DXGI_JPEG_DC_HUFFMAN_TABLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).GetDcHuffmanTable(scanIndex, tableIndex, dc_huffman_table) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetQuantizationTable
  
  #[allow(non_snake_case)]
  fn get_quantization_table(&self, scanIndex: UINT, tableIndex: UINT, quantization_table: &mut DXGI_JPEG_QUANTIZATION_TABLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).GetQuantizationTable(scanIndex, tableIndex, quantization_table) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetFrameHeader
  
  #[allow(non_snake_case)]
  fn get_frame_header(&self, frame_header: &mut WICJpegFrameHeader) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).GetFrameHeader(frame_header) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetScanHeader
  
  #[allow(non_snake_case)]
  fn get_scan_header(&self, scanIndex: UINT, scan_header: &mut WICJpegScanHeader) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).GetScanHeader(scanIndex, scan_header) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyScan
  
  #[allow(non_snake_case)]
  fn copy_scan(&self, scanIndex: UINT, scanOffset: UINT, cbScanData: UINT, pbScanData: &mut BYTE, pcbScanDataActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).CopyScan(scanIndex, scanOffset, cbScanData, pbScanData, pcbScanDataActual) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyMinimalStream
  
  #[allow(non_snake_case)]
  fn copy_minimal_stream(&self, streamOffset: UINT, cbStreamData: UINT, pbStreamData: &mut BYTE, pcbStreamDataActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameDecode)).CopyMinimalStream(streamOffset, cbStreamData, pbStreamData, pcbStreamDataActual) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICJpegFrameDecode {
  fn new(ptr: *mut IUnknown) -> Self {
    WICJpegFrameDecode(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICJpegFrameDecode {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICJpegFrameDecode {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICJpegFrameDecode for WICJpegFrameDecode {}

pub struct WICJpegFrameDecode(*mut IWICJpegFrameDecode);

impl HasIID for WICJpegFrameDecode {
  fn iid() -> REFGUID { &IID_IWICJpegFrameDecode }
}

pub trait TWICJpegFrameEncode: TUnknown {
  //  Method GetAcHuffmanTable
  
  #[allow(non_snake_case)]
  fn get_ac_huffman_table(&self, scanIndex: UINT, tableIndex: UINT, ac_huffman_table: &mut DXGI_JPEG_AC_HUFFMAN_TABLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameEncode)).GetAcHuffmanTable(scanIndex, tableIndex, ac_huffman_table) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDcHuffmanTable
  
  #[allow(non_snake_case)]
  fn get_dc_huffman_table(&self, scanIndex: UINT, tableIndex: UINT, dc_huffman_table: &mut DXGI_JPEG_DC_HUFFMAN_TABLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameEncode)).GetDcHuffmanTable(scanIndex, tableIndex, dc_huffman_table) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetQuantizationTable
  
  #[allow(non_snake_case)]
  fn get_quantization_table(&self, scanIndex: UINT, tableIndex: UINT, quantization_table: &mut DXGI_JPEG_QUANTIZATION_TABLE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameEncode)).GetQuantizationTable(scanIndex, tableIndex, quantization_table) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WriteScan
  
  #[allow(non_snake_case)]
  fn write_scan(&self, cbScanData: UINT, pbScanData: &BYTE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICJpegFrameEncode)).WriteScan(cbScanData, pbScanData) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICJpegFrameEncode {
  fn new(ptr: *mut IUnknown) -> Self {
    WICJpegFrameEncode(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICJpegFrameEncode {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICJpegFrameEncode {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICJpegFrameEncode for WICJpegFrameEncode {}

pub struct WICJpegFrameEncode(*mut IWICJpegFrameEncode);

impl HasIID for WICJpegFrameEncode {
  fn iid() -> REFGUID { &IID_IWICJpegFrameEncode }
}

pub trait TWICMetadataQueryReader: TUnknown {
  //  Method GetContainerFormat
  
  #[allow(non_snake_case)]
  fn get_container_format(&self, pguidContainerFormat: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICMetadataQueryReader)).GetContainerFormat(pguidContainerFormat) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetLocation
  
  #[allow(non_snake_case)]
  fn get_location(&self, cchMaxLength: UINT, wzNamespace: &mut WCHAR, pcchActualLength: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICMetadataQueryReader)).GetLocation(cchMaxLength, wzNamespace, pcchActualLength) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetMetadataByName
  
  #[allow(non_snake_case)]
  fn get_metadata_by_name(&self, wzName: Cow<str>, pvarValue: &mut PROPVARIANT) -> HResult<HRESULT> {
    let lv1: Vec<u16> = str_to_vec_u16(wzName);
    let _hr=unsafe { (*(self.iptr() as *mut IWICMetadataQueryReader)).GetMetadataByName(lv1.as_ptr() as LPCWSTR, pvarValue) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEnumerator
  //  Error: ppIEnumString parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICMetadataQueryReader {
  fn new(ptr: *mut IUnknown) -> Self {
    WICMetadataQueryReader(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICMetadataQueryReader {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICMetadataQueryReader {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICMetadataQueryReader for WICMetadataQueryReader {}

pub struct WICMetadataQueryReader(*mut IWICMetadataQueryReader);

impl HasIID for WICMetadataQueryReader {
  fn iid() -> REFGUID { &IID_IWICMetadataQueryReader }
}

pub trait TWICMetadataQueryWriter: TWICMetadataQueryReader {
  //  Method SetMetadataByName
  
  #[allow(non_snake_case)]
  fn set_metadata_by_name(&self, wzName: Cow<str>, pvarValue: &PROPVARIANT) -> HResult<HRESULT> {
    let lv1: Vec<u16> = str_to_vec_u16(wzName);
    let _hr=unsafe { (*(self.iptr() as *mut IWICMetadataQueryWriter)).SetMetadataByName(lv1.as_ptr() as LPCWSTR, pvarValue) };
    hr2ret(_hr,_hr)
  }
  
  //  Method RemoveMetadataByName
  
  #[allow(non_snake_case)]
  fn remove_metadata_by_name(&self, wzName: Cow<str>) -> HResult<HRESULT> {
    let lv1: Vec<u16> = str_to_vec_u16(wzName);
    let _hr=unsafe { (*(self.iptr() as *mut IWICMetadataQueryWriter)).RemoveMetadataByName(lv1.as_ptr() as LPCWSTR) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICMetadataQueryWriter {
  fn new(ptr: *mut IUnknown) -> Self {
    WICMetadataQueryWriter(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICMetadataQueryWriter {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICMetadataQueryWriter {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICMetadataQueryReader for WICMetadataQueryWriter {}
impl TWICMetadataQueryWriter for WICMetadataQueryWriter {}

pub struct WICMetadataQueryWriter(*mut IWICMetadataQueryWriter);

impl HasIID for WICMetadataQueryWriter {
  fn iid() -> REFGUID { &IID_IWICMetadataQueryWriter }
}

pub trait TWICPalette: TUnknown {
  //  Method InitializePredefined
  
  #[allow(non_snake_case)]
  fn initialize_predefined(&self, ePaletteType: WICBitmapPaletteType, fAddTransparentColor: BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).InitializePredefined(ePaletteType, fAddTransparentColor) };
    hr2ret(_hr,_hr)
  }
  
  //  Method InitializeCustom
  
  #[allow(non_snake_case)]
  fn initialize_custom(&self, colors: &mut WICColor, cCount: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).InitializeCustom(colors, cCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method InitializeFromBitmap
  
  #[allow(non_snake_case)]
  fn initialize_from_bitmap(&self, i_surface: &mut IWICBitmapSource, cCount: UINT, fAddTransparentColor: BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).InitializeFromBitmap(i_surface, cCount, fAddTransparentColor) };
    hr2ret(_hr,_hr)
  }
  
  //  Method InitializeFromPalette
  
  #[allow(non_snake_case)]
  fn initialize_from_palette(&self, i_palette: &mut IWICPalette) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).InitializeFromPalette(i_palette) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetType
  
  #[allow(non_snake_case)]
  fn get_type(&self, pePaletteType: &mut WICBitmapPaletteType) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).GetType(pePaletteType) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColorCount
  
  #[allow(non_snake_case)]
  fn get_color_count(&self, pcCount: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).GetColorCount(pcCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColors
  
  #[allow(non_snake_case)]
  fn get_colors(&self, cCount: UINT, colors: &mut WICColor, pcActualColors: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).GetColors(cCount, colors, pcActualColors) };
    hr2ret(_hr,_hr)
  }
  
  //  Method IsBlackWhite
  
  #[allow(non_snake_case)]
  fn is_black_white(&self, pfIsBlackWhite: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).IsBlackWhite(pfIsBlackWhite) };
    hr2ret(_hr,_hr)
  }
  
  //  Method IsGrayscale
  
  #[allow(non_snake_case)]
  fn is_grayscale(&self, pfIsGrayscale: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).IsGrayscale(pfIsGrayscale) };
    hr2ret(_hr,_hr)
  }
  
  //  Method HasAlpha
  
  #[allow(non_snake_case)]
  fn has_alpha(&self, pfHasAlpha: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPalette)).HasAlpha(pfHasAlpha) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICPalette {
  fn new(ptr: *mut IUnknown) -> Self {
    WICPalette(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICPalette {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICPalette {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICPalette for WICPalette {}

pub struct WICPalette(*mut IWICPalette);

impl HasIID for WICPalette {
  fn iid() -> REFGUID { &IID_IWICPalette }
}

pub trait TWICPixelFormatInfo2: TWICPixelFormatInfo {
  //  Method SupportsTransparency
  
  #[allow(non_snake_case)]
  fn supports_transparency(&self, pfSupportsTransparency: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPixelFormatInfo2)).SupportsTransparency(pfSupportsTransparency) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetNumericRepresentation
  
  #[allow(non_snake_case)]
  fn get_numeric_representation(&self, numeric_representation: &mut WICPixelFormatNumericRepresentation) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPixelFormatInfo2)).GetNumericRepresentation(numeric_representation) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICPixelFormatInfo2 {
  fn new(ptr: *mut IUnknown) -> Self {
    WICPixelFormatInfo2(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICPixelFormatInfo2 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICPixelFormatInfo2 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICPixelFormatInfo2 {}
impl TWICPixelFormatInfo for WICPixelFormatInfo2 {}
impl TWICPixelFormatInfo2 for WICPixelFormatInfo2 {}

pub struct WICPixelFormatInfo2(*mut IWICPixelFormatInfo2);

impl HasIID for WICPixelFormatInfo2 {
  fn iid() -> REFGUID { &IID_IWICPixelFormatInfo2 }
}

pub trait TWICPixelFormatInfo: TWICComponentInfo {
  //  Method GetFormatGUID
  
  #[allow(non_snake_case)]
  fn get_format_g_u_i_d(&self, format: &mut GUID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPixelFormatInfo)).GetFormatGUID(format) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColorContext
  //  Error: ppIColorContext parameter: ANone annotation cannot be used with double indirection
  //  Method GetBitsPerPixel
  
  #[allow(non_snake_case)]
  fn get_bits_per_pixel(&self, puiBitsPerPixel: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPixelFormatInfo)).GetBitsPerPixel(puiBitsPerPixel) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetChannelCount
  
  #[allow(non_snake_case)]
  fn get_channel_count(&self, puiChannelCount: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPixelFormatInfo)).GetChannelCount(puiChannelCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetChannelMask
  
  #[allow(non_snake_case)]
  fn get_channel_mask(&self, uiChannelIndex: UINT, cbMaskBuffer: UINT, pbMaskBuffer: &mut BYTE, pcbActual: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPixelFormatInfo)).GetChannelMask(uiChannelIndex, cbMaskBuffer, pbMaskBuffer, pcbActual) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICPixelFormatInfo {
  fn new(ptr: *mut IUnknown) -> Self {
    WICPixelFormatInfo(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICPixelFormatInfo {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICPixelFormatInfo {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICComponentInfo for WICPixelFormatInfo {}
impl TWICPixelFormatInfo for WICPixelFormatInfo {}

pub struct WICPixelFormatInfo(*mut IWICPixelFormatInfo);

impl HasIID for WICPixelFormatInfo {
  fn iid() -> REFGUID { &IID_IWICPixelFormatInfo }
}

pub trait TWICPlanarBitmapFrameEncode: TUnknown {
  //  Method WritePixels
  
  #[allow(non_snake_case)]
  fn write_pixels(&self, lineCount: UINT, planes: &mut WICBitmapPlane, cPlanes: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPlanarBitmapFrameEncode)).WritePixels(lineCount, planes, cPlanes) };
    hr2ret(_hr,_hr)
  }
  
  //  Method WriteSource
  //  Error: ppPlanes parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for WICPlanarBitmapFrameEncode {
  fn new(ptr: *mut IUnknown) -> Self {
    WICPlanarBitmapFrameEncode(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICPlanarBitmapFrameEncode {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICPlanarBitmapFrameEncode {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICPlanarBitmapFrameEncode for WICPlanarBitmapFrameEncode {}

pub struct WICPlanarBitmapFrameEncode(*mut IWICPlanarBitmapFrameEncode);

impl HasIID for WICPlanarBitmapFrameEncode {
  fn iid() -> REFGUID { &IID_IWICPlanarBitmapFrameEncode }
}

pub trait TWICPlanarBitmapSourceTransform: TUnknown {
  //  Method DoesSupportTransform
  
  #[allow(non_snake_case)]
  fn does_support_transform(&self, puiWidth: &mut UINT, puiHeight: &mut UINT, dstTransform: WICBitmapTransformOptions, dstPlanarOptions: WICPlanarOptions, pguidDstFormats: &WICPixelFormatGUID, plane_descriptions: &mut WICBitmapPlaneDescription, cPlanes: UINT, pfIsSupported: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPlanarBitmapSourceTransform)).DoesSupportTransform(puiWidth, puiHeight, dstTransform, dstPlanarOptions, pguidDstFormats, plane_descriptions, cPlanes, pfIsSupported) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyPixels
  
  #[allow(non_snake_case)]
  fn copy_pixels(&self, prcSource: &WICRect, uiWidth: UINT, uiHeight: UINT, dstTransform: WICBitmapTransformOptions, dstPlanarOptions: WICPlanarOptions, dst_planes: &WICBitmapPlane, cPlanes: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPlanarBitmapSourceTransform)).CopyPixels(prcSource, uiWidth, uiHeight, dstTransform, dstPlanarOptions, dst_planes, cPlanes) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICPlanarBitmapSourceTransform {
  fn new(ptr: *mut IUnknown) -> Self {
    WICPlanarBitmapSourceTransform(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICPlanarBitmapSourceTransform {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICPlanarBitmapSourceTransform {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICPlanarBitmapSourceTransform for WICPlanarBitmapSourceTransform {}

pub struct WICPlanarBitmapSourceTransform(*mut IWICPlanarBitmapSourceTransform);

impl HasIID for WICPlanarBitmapSourceTransform {
  fn iid() -> REFGUID { &IID_IWICPlanarBitmapSourceTransform }
}

pub trait TWICPlanarFormatConverter: TWICBitmapSource {
  //  Method Initialize
  //  Error: ppPlanes parameter: ANone annotation cannot be used with double indirection
  //  Method CanConvert
  
  #[allow(non_snake_case)]
  fn can_convert(&self, src_pixel_formats: &WICPixelFormatGUID, cSrcPlanes: UINT, dstPixelFormat: REFWICPixelFormatGUID, pfCanConvert: &mut BOOL) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICPlanarFormatConverter)).CanConvert(src_pixel_formats, cSrcPlanes, dstPixelFormat, pfCanConvert) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICPlanarFormatConverter {
  fn new(ptr: *mut IUnknown) -> Self {
    WICPlanarFormatConverter(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICPlanarFormatConverter {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICPlanarFormatConverter {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICBitmapSource for WICPlanarFormatConverter {}
impl TWICPlanarFormatConverter for WICPlanarFormatConverter {}

pub struct WICPlanarFormatConverter(*mut IWICPlanarFormatConverter);

impl HasIID for WICPlanarFormatConverter {
  fn iid() -> REFGUID { &IID_IWICPlanarFormatConverter }
}

pub trait TWICProgressCallback: TUnknown {
  //  Method Notify
  
  #[allow(non_snake_case)]
  fn notify(&self, uFrameNum: ULONG, operation: WICProgressOperation, dblProgress: f64) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICProgressCallback)).Notify(uFrameNum, operation, dblProgress) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICProgressCallback {
  fn new(ptr: *mut IUnknown) -> Self {
    WICProgressCallback(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICProgressCallback {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICProgressCallback {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICProgressCallback for WICProgressCallback {}

pub struct WICProgressCallback(*mut IWICProgressCallback);

impl HasIID for WICProgressCallback {
  fn iid() -> REFGUID { &IID_IWICProgressCallback }
}

pub trait TWICProgressiveLevelControl: TUnknown {
  //  Method GetLevelCount
  
  #[allow(non_snake_case)]
  fn get_level_count(&self, pcLevels: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICProgressiveLevelControl)).GetLevelCount(pcLevels) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetCurrentLevel
  
  #[allow(non_snake_case)]
  fn get_current_level(&self, pnLevel: &mut UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICProgressiveLevelControl)).GetCurrentLevel(pnLevel) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetCurrentLevel
  
  #[allow(non_snake_case)]
  fn set_current_level(&self, nLevel: UINT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut IWICProgressiveLevelControl)).SetCurrentLevel(nLevel) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for WICProgressiveLevelControl {
  fn new(ptr: *mut IUnknown) -> Self {
    WICProgressiveLevelControl(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for WICProgressiveLevelControl {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for WICProgressiveLevelControl {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TWICProgressiveLevelControl for WICProgressiveLevelControl {}

pub struct WICProgressiveLevelControl(*mut IWICProgressiveLevelControl);

impl HasIID for WICProgressiveLevelControl {
  fn iid() -> REFGUID { &IID_IWICProgressiveLevelControl }
}

