// This file is autogenerated

use utils::*;

use d2d1_safe::*;
use dwrite_safe::*;

#[derive(Debug)]
pub struct D2D1Bitmap1(*mut ID2D1Bitmap1);

impl HasIID for D2D1Bitmap1 {
  fn iid() -> REFGUID { &IID_ID2D1Bitmap1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1Bitmap1(pp_vtbl as *mut _ as *mut ID2D1Bitmap1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1Bitmap1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1Bitmap1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1Bitmap1 {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method GetSize
  
  #[allow(non_snake_case)]
  pub fn get_size(&self) -> D2D1_SIZE_F {
    let mut lv1: D2D1_SIZE_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap)).GetSize(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetPixelSize
  
  #[allow(non_snake_case)]
  pub fn get_pixel_size(&self) -> D2D1_SIZE_U {
    let mut lv1: D2D1_SIZE_U = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap)).GetPixelSize(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetPixelFormat
  
  #[allow(non_snake_case)]
  pub fn get_pixel_format(&self) -> D2D1_PIXEL_FORMAT {
    let mut lv1: D2D1_PIXEL_FORMAT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap)).GetPixelFormat(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetDpi
  
  #[allow(non_snake_case)]
  pub fn get_dpi(&self) -> (FLOAT, FLOAT) {
    let mut lv1: FLOAT = unsafe {mem::uninitialized::<_>()};
    let mut lv2: FLOAT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap)).GetDpi(&mut lv1 as *mut _ as *mut _, &mut lv2 as *mut _ as *mut _) };
    (lv1, lv2)
  }
  
  //  Method CopyFromBitmap
  
  #[allow(non_snake_case)]
  pub fn copy_from_bitmap<T: HasIID>(&self, destPoint: Option<&D2D1_POINT_2U>, bitmap: &T, srcRect: Option<&D2D1_RECT_U>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap)).CopyFromBitmap(destPoint.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), bitmap.iptr() as *mut _ as *mut _ , srcRect.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyFromRenderTarget
  
  #[allow(non_snake_case)]
  pub fn copy_from_render_target<T: HasIID>(&self, destPoint: Option<&D2D1_POINT_2U>, renderTarget: &T, srcRect: Option<&D2D1_RECT_U>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap)).CopyFromRenderTarget(destPoint.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), renderTarget.iptr() as *mut _ as *mut _ , srcRect.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null())) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CopyFromMemory
  
  #[allow(non_snake_case)]
  pub unsafe fn copy_from_memory<T>(&self, dstRect: Option<&D2D1_RECT_U>, srcData: &[T], pitch: UINT32) -> HResult<HRESULT> {
  
    let _hr= { (*(self.0 as *mut ID2D1Bitmap)).CopyFromMemory(dstRect.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), srcData.as_ptr() as *const _, pitch) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetColorContext
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method GetOptions
  
  #[allow(non_snake_case)]
  pub fn get_options(&self) -> D2D1_BITMAP_OPTIONS {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap1)).GetOptions() };
    _hr
  }
  
  //  Method GetSurface
  //  Error: dxgiSurface parameter: ANone annotation cannot be used with double indirection
  //  Method Map
  
  #[allow(non_snake_case)]
  pub fn map(&self, options: D2D1_MAP_OPTIONS, mappedRect: &mut D2D1_MAPPED_RECT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap1)).Map(options, mappedRect) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Unmap
  
  #[allow(non_snake_case)]
  pub fn unmap(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Bitmap1)).Unmap() };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1BitmapBrush1(*mut ID2D1BitmapBrush1);

impl HasIID for D2D1BitmapBrush1 {
  fn iid() -> REFGUID { &IID_ID2D1BitmapBrush1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1BitmapBrush1(pp_vtbl as *mut _ as *mut ID2D1BitmapBrush1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1BitmapBrush1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1BitmapBrush1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1BitmapBrush1 {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method SetOpacity
  
  #[allow(non_snake_case)]
  pub fn set_opacity(&self, opacity: FLOAT) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).SetOpacity(opacity) };
    ()
  }
  
  //  Method SetTransform
  
  #[allow(non_snake_case)]
  pub fn set_transform(&self, transform: &D2D1_MATRIX_3X2_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).SetTransform(transform) };
    ()
  }
  
  //  Method GetOpacity
  
  #[allow(non_snake_case)]
  pub fn get_opacity(&self) -> FLOAT {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).GetOpacity() };
    _hr
  }
  
  //  Method GetTransform
  
  #[allow(non_snake_case)]
  pub fn get_transform(&self) -> D2D1_MATRIX_3X2_F {
    let mut lv1: D2D1_MATRIX_3X2_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).GetTransform(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method SetExtendModeX
  
  #[allow(non_snake_case)]
  pub fn set_extend_mode_x(&self, extendModeX: D2D1_EXTEND_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).SetExtendModeX(extendModeX) };
    ()
  }
  
  //  Method SetExtendModeY
  
  #[allow(non_snake_case)]
  pub fn set_extend_mode_y(&self, extendModeY: D2D1_EXTEND_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).SetExtendModeY(extendModeY) };
    ()
  }
  
  //  Method SetInterpolationMode
  
  #[allow(non_snake_case)]
  pub fn set_interpolation_mode(&self, interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).SetInterpolationMode(interpolationMode) };
    ()
  }
  
  //  Method SetBitmap
  
  #[allow(non_snake_case)]
  pub fn set_bitmap<T: HasIID>(&self, bitmap: &T) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).SetBitmap(bitmap.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method GetExtendModeX
  
  #[allow(non_snake_case)]
  pub fn get_extend_mode_x(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).GetExtendModeX() };
    _hr
  }
  
  //  Method GetExtendModeY
  
  #[allow(non_snake_case)]
  pub fn get_extend_mode_y(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).GetExtendModeY() };
    _hr
  }
  
  //  Method GetInterpolationMode
  
  #[allow(non_snake_case)]
  pub fn get_interpolation_mode(&self) -> D2D1_BITMAP_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).GetInterpolationMode() };
    _hr
  }
  
  //  Method GetBitmap
  
  #[allow(non_snake_case)]
  pub fn get_bitmap(&self) -> Option<D2D1Bitmap> {
    let mut lv1: *mut ID2D1Bitmap = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush)).GetBitmap(&mut lv1 as *mut *mut _) };
    if lv1==ptr::null_mut() {None} else {Some(D2D1Bitmap::new(lv1 as *mut _))}
  }
  
  //  Method SetInterpolationMode1
  
  #[allow(non_snake_case)]
  pub fn set_interpolation_mode1(&self, interpolationMode: D2D1_INTERPOLATION_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush1)).SetInterpolationMode1(interpolationMode) };
    ()
  }
  
  //  Method GetInterpolationMode1
  
  #[allow(non_snake_case)]
  pub fn get_interpolation_mode1(&self) -> D2D1_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1BitmapBrush1)).GetInterpolationMode1() };
    _hr
  }
  
  
}

pub struct D2D1ColorContext(*mut ID2D1ColorContext);

impl HasIID for D2D1ColorContext {
  fn iid() -> REFGUID { &IID_ID2D1ColorContext }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1ColorContext(pp_vtbl as *mut _ as *mut ID2D1ColorContext) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1ColorContext {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1ColorContext {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1ColorContext {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method GetColorSpace
  
  #[allow(non_snake_case)]
  pub fn get_color_space(&self) -> D2D1_COLOR_SPACE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ColorContext)).GetColorSpace() };
    _hr
  }
  
  //  Method GetProfileSize
  
  #[allow(non_snake_case)]
  pub fn get_profile_size(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ColorContext)).GetProfileSize() };
    _hr
  }
  
  //  Method GetProfile
  
  #[allow(non_snake_case)]
  pub fn get_profile(&self, profile: &mut BYTE, profileSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ColorContext)).GetProfile(profile, profileSize) };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1CommandList(*mut ID2D1CommandList);

impl HasIID for D2D1CommandList {
  fn iid() -> REFGUID { &IID_ID2D1CommandList }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1CommandList(pp_vtbl as *mut _ as *mut ID2D1CommandList) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1CommandList {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1CommandList {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1CommandList {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method Stream
  
  #[allow(non_snake_case)]
  pub fn stream(&self, sink: &mut ID2D1CommandSink) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandList)).Stream(sink) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Close
  
  #[allow(non_snake_case)]
  pub fn close(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandList)).Close() };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1CommandSink(*mut ID2D1CommandSink);

impl HasIID for D2D1CommandSink {
  fn iid() -> REFGUID { &IID_ID2D1CommandSink }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1CommandSink(pp_vtbl as *mut _ as *mut ID2D1CommandSink) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1CommandSink {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1CommandSink {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1CommandSink {
  //  Method BeginDraw
  
  #[allow(non_snake_case)]
  pub fn begin_draw(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).BeginDraw() };
    hr2ret(_hr,_hr)
  }
  
  //  Method EndDraw
  
  #[allow(non_snake_case)]
  pub fn end_draw(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).EndDraw() };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetAntialiasMode
  
  #[allow(non_snake_case)]
  pub fn set_antialias_mode(&self, antialiasMode: D2D1_ANTIALIAS_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetAntialiasMode(antialiasMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTags
  
  #[allow(non_snake_case)]
  pub fn set_tags(&self, tag1: D2D1_TAG, tag2: D2D1_TAG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetTags(tag1, tag2) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTextAntialiasMode
  
  #[allow(non_snake_case)]
  pub fn set_text_antialias_mode(&self, textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetTextAntialiasMode(textAntialiasMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTextRenderingParams
  
  #[allow(non_snake_case)]
  pub fn set_text_rendering_params(&self, textRenderingParams: &mut IDWriteRenderingParams) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetTextRenderingParams(textRenderingParams) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTransform
  
  #[allow(non_snake_case)]
  pub fn set_transform(&self, transform: &D2D1_MATRIX_3X2_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetTransform(transform) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetPrimitiveBlend
  
  #[allow(non_snake_case)]
  pub fn set_primitive_blend(&self, primitiveBlend: D2D1_PRIMITIVE_BLEND) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetPrimitiveBlend(primitiveBlend) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetUnitMode
  
  #[allow(non_snake_case)]
  pub fn set_unit_mode(&self, unitMode: D2D1_UNIT_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).SetUnitMode(unitMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Clear
  
  #[allow(non_snake_case)]
  pub fn clear(&self, color: &D2D1_COLOR_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).Clear(color) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawGlyphRun
  
  #[allow(non_snake_case)]
  pub fn draw_glyph_run(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, glyphRunDescription: &DWRITE_GLYPH_RUN_DESCRIPTION, foregroundBrush: &mut ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawGlyphRun(baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawLine
  
  #[allow(non_snake_case)]
  pub fn draw_line(&self, point0: D2D1_POINT_2F, point1: D2D1_POINT_2F, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawLine(point0, point1, brush, strokeWidth, strokeStyle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawGeometry
  
  #[allow(non_snake_case)]
  pub fn draw_geometry(&self, geometry: &mut ID2D1Geometry, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawGeometry(geometry, brush, strokeWidth, strokeStyle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawRectangle
  
  #[allow(non_snake_case)]
  pub fn draw_rectangle(&self, rect: &D2D1_RECT_F, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawRectangle(rect, brush, strokeWidth, strokeStyle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawBitmap
  
  #[allow(non_snake_case)]
  pub fn draw_bitmap(&self, bitmap: &mut ID2D1Bitmap, destinationRectangle: &D2D1_RECT_F, opacity: FLOAT, interpolationMode: D2D1_INTERPOLATION_MODE, sourceRectangle: &D2D1_RECT_F, perspectiveTransform: &D2D1_MATRIX_4X4_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawBitmap(bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawImage
  
  #[allow(non_snake_case)]
  pub fn draw_image(&self, image: &mut ID2D1Image, targetOffset: &D2D1_POINT_2F, imageRectangle: &D2D1_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE, compositeMode: D2D1_COMPOSITE_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawImage(image, targetOffset, imageRectangle, interpolationMode, compositeMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawGdiMetafile
  
  #[allow(non_snake_case)]
  pub fn draw_gdi_metafile(&self, gdiMetafile: &mut ID2D1GdiMetafile, targetOffset: &D2D1_POINT_2F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).DrawGdiMetafile(gdiMetafile, targetOffset) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillMesh
  
  #[allow(non_snake_case)]
  pub fn fill_mesh(&self, mesh: &mut ID2D1Mesh, brush: &mut ID2D1Brush) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).FillMesh(mesh, brush) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillOpacityMask
  
  #[allow(non_snake_case)]
  pub fn fill_opacity_mask(&self, opacityMask: &mut ID2D1Bitmap, brush: &mut ID2D1Brush, destinationRectangle: &D2D1_RECT_F, sourceRectangle: &D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).FillOpacityMask(opacityMask, brush, destinationRectangle, sourceRectangle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillGeometry
  
  #[allow(non_snake_case)]
  pub fn fill_geometry(&self, geometry: &mut ID2D1Geometry, brush: &mut ID2D1Brush, opacityBrush: &mut ID2D1Brush) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).FillGeometry(geometry, brush, opacityBrush) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillRectangle
  
  #[allow(non_snake_case)]
  pub fn fill_rectangle(&self, rect: &D2D1_RECT_F, brush: &mut ID2D1Brush) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).FillRectangle(rect, brush) };
    hr2ret(_hr,_hr)
  }
  
  //  Method PushAxisAlignedClip
  
  #[allow(non_snake_case)]
  pub fn push_axis_aligned_clip(&self, clipRect: &D2D1_RECT_F, antialiasMode: D2D1_ANTIALIAS_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).PushAxisAlignedClip(clipRect, antialiasMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method PushLayer
  
  #[allow(non_snake_case)]
  pub fn push_layer(&self, layerParameters1: &D2D1_LAYER_PARAMETERS1, layer: &mut ID2D1Layer) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).PushLayer(layerParameters1, layer) };
    hr2ret(_hr,_hr)
  }
  
  //  Method PopAxisAlignedClip
  
  #[allow(non_snake_case)]
  pub fn pop_axis_aligned_clip(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).PopAxisAlignedClip() };
    hr2ret(_hr,_hr)
  }
  
  //  Method PopLayer
  
  #[allow(non_snake_case)]
  pub fn pop_layer(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1CommandSink)).PopLayer() };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1DeviceContext(*mut ID2D1DeviceContext);

impl HasIID for D2D1DeviceContext {
  fn iid() -> REFGUID { &IID_ID2D1DeviceContext }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1DeviceContext(pp_vtbl as *mut _ as *mut ID2D1DeviceContext) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1DeviceContext {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1DeviceContext {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1DeviceContext {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method CreateBitmap
  
  #[allow(non_snake_case)]
  pub unsafe fn create_bitmap<T>(&self, size: D2D1_SIZE_U, srcData: &[T], pitch: UINT32, bitmapProperties: &D2D1_BITMAP_PROPERTIES) -> HResult<D2D1Bitmap> {
    let mut lv1: *mut ID2D1Bitmap = ptr::null_mut();
    let _hr= { (*(self.0 as *mut ID2D1RenderTarget)).CreateBitmap(size, srcData.as_ptr() as *const _, pitch, bitmapProperties, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Bitmap::new(lv1 as *mut _))
  }
  
  //  Method CreateBitmapFromWicBitmap
  
  #[allow(non_snake_case)]
  pub fn create_bitmap_from_wic_bitmap<T: HasIID>(&self, wicBitmapSource: &T, bitmapProperties: Option<&D2D1_BITMAP_PROPERTIES>) -> HResult<D2D1Bitmap> {
    let mut lv1: *mut ID2D1Bitmap = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateBitmapFromWicBitmap(wicBitmapSource.iptr() as *mut _ as *mut _ , bitmapProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Bitmap::new(lv1 as *mut _))
  }
  
  //  Method CreateSharedBitmap
  
  #[allow(non_snake_case)]
  pub fn create_shared_bitmap<T: HasIID>(&self, data: &T, bitmapProperties: Option<&D2D1_BITMAP_PROPERTIES>) -> HResult<D2D1Bitmap> {
    let mut lv1: *mut ID2D1Bitmap = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateSharedBitmap(T::iid(), data.iptr() as *mut _ as *mut c_void, bitmapProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Bitmap::new(lv1 as *mut _))
  }
  
  //  Method CreateBitmapBrush
  
  #[allow(non_snake_case)]
  pub fn create_bitmap_brush<T: HasIID>(&self, bitmap: &T, bitmapBrushProperties: Option<&D2D1_BITMAP_BRUSH_PROPERTIES>, brushProperties: Option<&D2D1_BRUSH_PROPERTIES>) -> HResult<D2D1BitmapBrush> {
    let mut lv1: *mut ID2D1BitmapBrush = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateBitmapBrush(bitmap.iptr() as *mut _ as *mut _ , bitmapBrushProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), brushProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1BitmapBrush::new(lv1 as *mut _))
  }
  
  //  Method CreateSolidColorBrush
  
  #[allow(non_snake_case)]
  pub fn create_solid_color_brush(&self, color: &D2D1_COLOR_F, brushProperties: Option<&D2D1_BRUSH_PROPERTIES>) -> HResult<D2D1SolidColorBrush> {
    let mut lv1: *mut ID2D1SolidColorBrush = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateSolidColorBrush(color, brushProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1SolidColorBrush::new(lv1 as *mut _))
  }
  
  //  Method CreateGradientStopCollection
  
  #[allow(non_snake_case)]
  pub fn create_gradient_stop_collection(&self, gradientStops: &[D2D1_GRADIENT_STOP], colorInterpolationGamma: D2D1_GAMMA, extendMode: D2D1_EXTEND_MODE) -> HResult<D2D1GradientStopCollection> {
    let mut lv1: *mut ID2D1GradientStopCollection = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateGradientStopCollection(slice_as_ptr(gradientStops), gradientStops.len() as UINT32, colorInterpolationGamma, extendMode, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1GradientStopCollection::new(lv1 as *mut _))
  }
  
  //  Method CreateLinearGradientBrush
  
  #[allow(non_snake_case)]
  pub fn create_linear_gradient_brush<T: HasIID>(&self, linearGradientBrushProperties: &D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES, brushProperties: Option<&D2D1_BRUSH_PROPERTIES>, gradientStopCollection: &T) -> HResult<D2D1LinearGradientBrush> {
    let mut lv1: *mut ID2D1LinearGradientBrush = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateLinearGradientBrush(linearGradientBrushProperties, brushProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), gradientStopCollection.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1LinearGradientBrush::new(lv1 as *mut _))
  }
  
  //  Method CreateRadialGradientBrush
  
  #[allow(non_snake_case)]
  pub fn create_radial_gradient_brush<T: HasIID>(&self, radialGradientBrushProperties: &D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES, brushProperties: Option<&D2D1_BRUSH_PROPERTIES>, gradientStopCollection: &T) -> HResult<D2D1RadialGradientBrush> {
    let mut lv1: *mut ID2D1RadialGradientBrush = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateRadialGradientBrush(radialGradientBrushProperties, brushProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), gradientStopCollection.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1RadialGradientBrush::new(lv1 as *mut _))
  }
  
  //  Method CreateCompatibleRenderTarget
  
  #[allow(non_snake_case)]
  pub fn create_compatible_render_target(&self, desiredSize: Option<&D2D1_SIZE_F>, desiredPixelSize: Option<&D2D1_SIZE_U>, desiredFormat: Option<&D2D1_PIXEL_FORMAT>, options: D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS) -> HResult<D2D1BitmapRenderTarget> {
    let mut lv1: *mut ID2D1BitmapRenderTarget = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateCompatibleRenderTarget(desiredSize.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), desiredPixelSize.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), desiredFormat.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), options, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1BitmapRenderTarget::new(lv1 as *mut _))
  }
  
  //  Method CreateLayer
  
  #[allow(non_snake_case)]
  pub fn create_layer(&self, size: Option<&D2D1_SIZE_F>) -> HResult<D2D1Layer> {
    let mut lv1: *mut ID2D1Layer = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateLayer(size.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Layer::new(lv1 as *mut _))
  }
  
  //  Method CreateMesh
  
  #[allow(non_snake_case)]
  pub fn create_mesh(&self) -> HResult<D2D1Mesh> {
    let mut lv1: *mut ID2D1Mesh = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).CreateMesh(&mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Mesh::new(lv1 as *mut _))
  }
  
  //  Method DrawLine
  
  #[allow(non_snake_case)]
  pub fn draw_line<T: HasIID>(&self, point0: D2D1_POINT_2F, point1: D2D1_POINT_2F, brush: &T, strokeWidth: FLOAT, strokeStyle: Option<&D2D1StrokeStyle>) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawLine(point0, point1, brush.iptr() as *mut _ as *mut _ , strokeWidth, strokeStyle.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    ()
  }
  
  //  Method DrawRectangle
  
  #[allow(non_snake_case)]
  pub fn draw_rectangle<T: HasIID>(&self, rect: &D2D1_RECT_F, brush: &T, strokeWidth: FLOAT, strokeStyle: Option<&D2D1StrokeStyle>) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawRectangle(rect, brush.iptr() as *mut _ as *mut _ , strokeWidth, strokeStyle.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    ()
  }
  
  //  Method FillRectangle
  
  #[allow(non_snake_case)]
  pub fn fill_rectangle<T: HasIID>(&self, rect: &D2D1_RECT_F, brush: &T) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).FillRectangle(rect, brush.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method DrawRoundedRectangle
  
  #[allow(non_snake_case)]
  pub fn draw_rounded_rectangle(&self, roundedRect: &D2D1_ROUNDED_RECT, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawRoundedRectangle(roundedRect, brush, strokeWidth, strokeStyle) };
    ()
  }
  
  //  Method FillRoundedRectangle
  
  #[allow(non_snake_case)]
  pub fn fill_rounded_rectangle(&self, roundedRect: &D2D1_ROUNDED_RECT, brush: &mut ID2D1Brush) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).FillRoundedRectangle(roundedRect, brush) };
    ()
  }
  
  //  Method DrawEllipse
  
  #[allow(non_snake_case)]
  pub fn draw_ellipse(&self, ellipse: &D2D1_ELLIPSE, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawEllipse(ellipse, brush, strokeWidth, strokeStyle) };
    ()
  }
  
  //  Method FillEllipse
  
  #[allow(non_snake_case)]
  pub fn fill_ellipse(&self, ellipse: &D2D1_ELLIPSE, brush: &mut ID2D1Brush) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).FillEllipse(ellipse, brush) };
    ()
  }
  
  //  Method DrawGeometry
  
  #[allow(non_snake_case)]
  pub fn draw_geometry(&self, geometry: &mut ID2D1Geometry, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawGeometry(geometry, brush, strokeWidth, strokeStyle) };
    ()
  }
  
  //  Method FillGeometry
  
  #[allow(non_snake_case)]
  pub fn fill_geometry(&self, geometry: &mut ID2D1Geometry, brush: &mut ID2D1Brush, opacityBrush: &mut ID2D1Brush) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).FillGeometry(geometry, brush, opacityBrush) };
    ()
  }
  
  //  Method FillMesh
  
  #[allow(non_snake_case)]
  pub fn fill_mesh(&self, mesh: &mut ID2D1Mesh, brush: &mut ID2D1Brush) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).FillMesh(mesh, brush) };
    ()
  }
  
  //  Method FillOpacityMask
  
  #[allow(non_snake_case)]
  pub fn fill_opacity_mask(&self, opacityMask: &mut ID2D1Bitmap, brush: &mut ID2D1Brush, content: D2D1_OPACITY_MASK_CONTENT, destinationRectangle: &D2D1_RECT_F, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).FillOpacityMask(opacityMask, brush, content, destinationRectangle, sourceRectangle) };
    ()
  }
  
  //  Method DrawBitmap
  
  #[allow(non_snake_case)]
  pub fn draw_bitmap(&self, bitmap: &mut ID2D1Bitmap, destinationRectangle: &D2D1_RECT_F, opacity: FLOAT, interpolationMode: D2D1_BITMAP_INTERPOLATION_MODE, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawBitmap(bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle) };
    ()
  }
  
  //  Method DrawText
  
  #[allow(non_snake_case)]
  pub fn draw_text<T: HasIID, T1: HasIID>(&self, string: &[WCHAR], textFormat: &T, layoutRect: &D2D1_RECT_F, defaultForegroundBrush: &T1, options: D2D1_DRAW_TEXT_OPTIONS, measuringMode: DWRITE_MEASURING_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawText(slice_as_ptr(string), string.len() as UINT32, textFormat.iptr() as *mut _ as *mut _ , layoutRect, defaultForegroundBrush.iptr() as *mut _ as *mut _ , options, measuringMode) };
    ()
  }
  
  //  Method DrawTextLayout
  
  #[allow(non_snake_case)]
  pub fn draw_text_layout(&self, origin: D2D1_POINT_2F, textLayout: &mut IDWriteTextLayout, defaultForegroundBrush: &mut ID2D1Brush, options: D2D1_DRAW_TEXT_OPTIONS) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawTextLayout(origin, textLayout, defaultForegroundBrush, options) };
    ()
  }
  
  //  Method DrawGlyphRun
  
  #[allow(non_snake_case)]
  pub fn draw_glyph_run(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, foregroundBrush: &mut ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).DrawGlyphRun(baselineOrigin, glyphRun, foregroundBrush, measuringMode) };
    ()
  }
  
  //  Method SetTransform
  
  #[allow(non_snake_case)]
  pub fn set_transform(&self, transform: &D2D1_MATRIX_3X2_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SetTransform(transform) };
    ()
  }
  
  //  Method GetTransform
  
  #[allow(non_snake_case)]
  pub fn get_transform(&self, transform: &mut D2D1_MATRIX_3X2_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetTransform(transform) };
    ()
  }
  
  //  Method SetAntialiasMode
  
  #[allow(non_snake_case)]
  pub fn set_antialias_mode(&self, antialiasMode: D2D1_ANTIALIAS_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SetAntialiasMode(antialiasMode) };
    ()
  }
  
  //  Method GetAntialiasMode
  
  #[allow(non_snake_case)]
  pub fn get_antialias_mode(&self) -> D2D1_ANTIALIAS_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetAntialiasMode() };
    _hr
  }
  
  //  Method SetTextAntialiasMode
  
  #[allow(non_snake_case)]
  pub fn set_text_antialias_mode(&self, textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SetTextAntialiasMode(textAntialiasMode) };
    ()
  }
  
  //  Method GetTextAntialiasMode
  
  #[allow(non_snake_case)]
  pub fn get_text_antialias_mode(&self) -> D2D1_TEXT_ANTIALIAS_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetTextAntialiasMode() };
    _hr
  }
  
  //  Method SetTextRenderingParams
  
  #[allow(non_snake_case)]
  pub fn set_text_rendering_params(&self, textRenderingParams: &mut IDWriteRenderingParams) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SetTextRenderingParams(textRenderingParams) };
    ()
  }
  
  //  Method GetTextRenderingParams
  //  Error: textRenderingParams parameter: ANone annotation cannot be used with double indirection
  //  Method SetTags
  
  #[allow(non_snake_case)]
  pub fn set_tags(&self, tag1: D2D1_TAG, tag2: D2D1_TAG) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SetTags(tag1, tag2) };
    ()
  }
  
  //  Method GetTags
  
  #[allow(non_snake_case)]
  pub fn get_tags(&self, tag1: &mut D2D1_TAG, tag2: &mut D2D1_TAG) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetTags(tag1, tag2) };
    ()
  }
  
  //  Method PushLayer
  
  #[allow(non_snake_case)]
  pub fn push_layer(&self, layerParameters: &D2D1_LAYER_PARAMETERS, layer: &mut ID2D1Layer) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).PushLayer(layerParameters, layer) };
    ()
  }
  
  //  Method PopLayer
  
  #[allow(non_snake_case)]
  pub fn pop_layer(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).PopLayer() };
    ()
  }
  
  //  Method Flush
  
  #[allow(non_snake_case)]
  pub fn flush(&self, tag1: Option<&mut D2D1_TAG>, tag2: Option<&mut D2D1_TAG>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).Flush(opt_as_mut_ptr(&tag1), opt_as_mut_ptr(&tag2)) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SaveDrawingState
  
  #[allow(non_snake_case)]
  pub fn save_drawing_state(&self, drawingStateBlock: &mut ID2D1DrawingStateBlock) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SaveDrawingState(drawingStateBlock) };
    ()
  }
  
  //  Method RestoreDrawingState
  
  #[allow(non_snake_case)]
  pub fn restore_drawing_state(&self, drawingStateBlock: &mut ID2D1DrawingStateBlock) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).RestoreDrawingState(drawingStateBlock) };
    ()
  }
  
  //  Method PushAxisAlignedClip
  
  #[allow(non_snake_case)]
  pub fn push_axis_aligned_clip(&self, clipRect: &D2D1_RECT_F, antialiasMode: D2D1_ANTIALIAS_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).PushAxisAlignedClip(clipRect, antialiasMode) };
    ()
  }
  
  //  Method PopAxisAlignedClip
  
  #[allow(non_snake_case)]
  pub fn pop_axis_aligned_clip(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).PopAxisAlignedClip() };
    ()
  }
  
  //  Method Clear
  
  #[allow(non_snake_case)]
  pub fn clear(&self, clearColor: &D2D1_COLOR_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).Clear(clearColor) };
    ()
  }
  
  //  Method BeginDraw
  
  #[allow(non_snake_case)]
  pub fn begin_draw(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).BeginDraw() };
    ()
  }
  
  //  Method EndDraw
  
  #[allow(non_snake_case)]
  pub fn end_draw(&self, tag1: Option<&mut D2D1_TAG>, tag2: Option<&mut D2D1_TAG>) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).EndDraw(opt_as_mut_ptr(&tag1), opt_as_mut_ptr(&tag2)) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPixelFormat
  
  #[allow(non_snake_case)]
  pub fn get_pixel_format(&self) -> D2D1_PIXEL_FORMAT {
    let mut lv1: D2D1_PIXEL_FORMAT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetPixelFormat(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method SetDpi
  
  #[allow(non_snake_case)]
  pub fn set_dpi(&self, dpiX: FLOAT, dpiY: FLOAT) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).SetDpi(dpiX, dpiY) };
    ()
  }
  
  //  Method GetDpi
  
  #[allow(non_snake_case)]
  pub fn get_dpi(&self, dpiX: &mut FLOAT, dpiY: &mut FLOAT) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetDpi(dpiX, dpiY) };
    ()
  }
  
  //  Method GetSize
  
  #[allow(non_snake_case)]
  pub fn get_size(&self) -> D2D1_SIZE_F {
    let mut lv1: D2D1_SIZE_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetSize(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetPixelSize
  
  #[allow(non_snake_case)]
  pub fn get_pixel_size(&self) -> D2D1_SIZE_U {
    let mut lv1: D2D1_SIZE_U = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetPixelSize(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method GetMaximumBitmapSize
  
  #[allow(non_snake_case)]
  pub fn get_maximum_bitmap_size(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).GetMaximumBitmapSize() };
    _hr
  }
  
  //  Method IsSupported
  
  #[allow(non_snake_case)]
  pub fn is_supported(&self, renderTargetProperties: &D2D1_RENDER_TARGET_PROPERTIES) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1RenderTarget)).IsSupported(renderTargetProperties) };
    _hr
  }
  
  //  Method CreateBitmap
  //  Error: bitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromWicBitmap
  //  Error: bitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorContext
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorContextFromFilename
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorContextFromWicColorContext
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromDxgiSurface
  
  #[allow(non_snake_case)]
  pub fn create_bitmap_from_dxgi_surface<T: HasIID>(&self, surface: &T, bitmapProperties: &D2D1_BITMAP_PROPERTIES1) -> HResult<D2D1Bitmap1> {
    let mut lv1: *mut ID2D1Bitmap1 = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).CreateBitmapFromDxgiSurface(surface.iptr() as *mut _ as *mut _ , bitmapProperties, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Bitmap1::new(lv1 as *mut _))
  }
  
  //  Method CreateEffect
  //  Error: effect parameter: ANone annotation cannot be used with double indirection
  //  Method CreateGradientStopCollection
  //  Error: gradientStopCollection1 parameter: ANone annotation cannot be used with double indirection
  //  Method CreateImageBrush
  //  Error: imageBrush parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapBrush
  //  Error: bitmapBrush parameter: ANone annotation cannot be used with double indirection
  //  Method CreateCommandList
  //  Error: commandList parameter: ANone annotation cannot be used with double indirection
  //  Method IsDxgiFormatSupported
  
  #[allow(non_snake_case)]
  pub fn is_dxgi_format_supported(&self, format: DXGI_FORMAT) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).IsDxgiFormatSupported(format) };
    _hr
  }
  
  //  Method IsBufferPrecisionSupported
  
  #[allow(non_snake_case)]
  pub fn is_buffer_precision_supported(&self, bufferPrecision: D2D1_BUFFER_PRECISION) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).IsBufferPrecisionSupported(bufferPrecision) };
    _hr
  }
  
  //  Method GetImageLocalBounds
  
  #[allow(non_snake_case)]
  pub fn get_image_local_bounds(&self, image: &mut ID2D1Image, localBounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetImageLocalBounds(image, localBounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetImageWorldBounds
  
  #[allow(non_snake_case)]
  pub fn get_image_world_bounds(&self, image: &mut ID2D1Image, worldBounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetImageWorldBounds(image, worldBounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetGlyphRunWorldBounds
  
  #[allow(non_snake_case)]
  pub fn get_glyph_run_world_bounds(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, measuringMode: DWRITE_MEASURING_MODE, bounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetGlyphRunWorldBounds(baselineOrigin, glyphRun, measuringMode, bounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDevice
  //  Error: device parameter: ANone annotation cannot be used with double indirection
  //  Method SetTarget
  
  #[allow(non_snake_case)]
  pub fn set_target<T: HasIID>(&self, image: &T) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).SetTarget(image.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method GetTarget
  //  Error: image parameter: ANone annotation cannot be used with double indirection
  //  Method SetRenderingControls
  
  #[allow(non_snake_case)]
  pub fn set_rendering_controls(&self, renderingControls: &D2D1_RENDERING_CONTROLS) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).SetRenderingControls(renderingControls) };
    ()
  }
  
  //  Method GetRenderingControls
  
  #[allow(non_snake_case)]
  pub fn get_rendering_controls(&self, renderingControls: &mut D2D1_RENDERING_CONTROLS) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetRenderingControls(renderingControls) };
    ()
  }
  
  //  Method SetPrimitiveBlend
  
  #[allow(non_snake_case)]
  pub fn set_primitive_blend(&self, primitiveBlend: D2D1_PRIMITIVE_BLEND) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).SetPrimitiveBlend(primitiveBlend) };
    ()
  }
  
  //  Method GetPrimitiveBlend
  
  #[allow(non_snake_case)]
  pub fn get_primitive_blend(&self) -> D2D1_PRIMITIVE_BLEND {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetPrimitiveBlend() };
    _hr
  }
  
  //  Method SetUnitMode
  
  #[allow(non_snake_case)]
  pub fn set_unit_mode(&self, unitMode: D2D1_UNIT_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).SetUnitMode(unitMode) };
    ()
  }
  
  //  Method GetUnitMode
  
  #[allow(non_snake_case)]
  pub fn get_unit_mode(&self) -> D2D1_UNIT_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetUnitMode() };
    _hr
  }
  
  //  Method DrawGlyphRun
  
  #[allow(non_snake_case)]
  pub fn draw_glyph_run_dc(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, glyphRunDescription: &DWRITE_GLYPH_RUN_DESCRIPTION, foregroundBrush: &mut ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).DrawGlyphRun(baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode) };
    ()
  }
  
  //  Method DrawImage
  
  #[allow(non_snake_case)]
  pub fn draw_image(&self, image: &mut ID2D1Image, targetOffset: &D2D1_POINT_2F, imageRectangle: &D2D1_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE, compositeMode: D2D1_COMPOSITE_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).DrawImage(image, targetOffset, imageRectangle, interpolationMode, compositeMode) };
    ()
  }
  
  //  Method DrawGdiMetafile
  
  #[allow(non_snake_case)]
  pub fn draw_gdi_metafile(&self, gdiMetafile: &mut ID2D1GdiMetafile, targetOffset: &D2D1_POINT_2F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).DrawGdiMetafile(gdiMetafile, targetOffset) };
    ()
  }
  
  //  Method DrawBitmap
  
  #[allow(non_snake_case)]
  pub fn draw_bitmap_dc(&self, bitmap: &mut ID2D1Bitmap, destinationRectangle: &D2D1_RECT_F, opacity: FLOAT, interpolationMode: D2D1_INTERPOLATION_MODE, sourceRectangle: &D2D1_RECT_F, perspectiveTransform: &D2D1_MATRIX_4X4_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).DrawBitmap(bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform) };
    ()
  }
  
  //  Method PushLayer
  
  #[allow(non_snake_case)]
  pub fn push_layer_dc(&self, layerParameters: &D2D1_LAYER_PARAMETERS1, layer: &mut ID2D1Layer) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).PushLayer(layerParameters, layer) };
    ()
  }
  
  //  Method InvalidateEffectInputRectangle
  
  #[allow(non_snake_case)]
  pub fn invalidate_effect_input_rectangle(&self, effect: &mut ID2D1Effect, input: UINT32, inputRectangle: &D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).InvalidateEffectInputRectangle(effect, input, inputRectangle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectInvalidRectangleCount
  
  #[allow(non_snake_case)]
  pub fn get_effect_invalid_rectangle_count(&self, effect: &mut ID2D1Effect, rectangleCount: &mut UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetEffectInvalidRectangleCount(effect, rectangleCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectInvalidRectangles
  
  #[allow(non_snake_case)]
  pub fn get_effect_invalid_rectangles(&self, effect: &mut ID2D1Effect, rectangles: &mut D2D1_RECT_F, rectanglesCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetEffectInvalidRectangles(effect, rectangles, rectanglesCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectRequiredInputRectangles
  
  #[allow(non_snake_case)]
  pub fn get_effect_required_input_rectangles(&self, renderEffect: &mut ID2D1Effect, renderImageRectangle: &D2D1_RECT_F, inputDescriptions: &D2D1_EFFECT_INPUT_DESCRIPTION, requiredInputRects: &mut D2D1_RECT_F, inputCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).GetEffectRequiredInputRectangles(renderEffect, renderImageRectangle, inputDescriptions, requiredInputRects, inputCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillOpacityMask
  
  #[allow(non_snake_case)]
  pub fn fill_opacity_mask_dc(&self, opacityMask: &mut ID2D1Bitmap, brush: &mut ID2D1Brush, destinationRectangle: &D2D1_RECT_F, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DeviceContext)).FillOpacityMask(opacityMask, brush, destinationRectangle, sourceRectangle) };
    ()
  }
  
  
}

pub struct D2D1Device(*mut ID2D1Device);

impl HasIID for D2D1Device {
  fn iid() -> REFGUID { &IID_ID2D1Device }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1Device(pp_vtbl as *mut _ as *mut ID2D1Device) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1Device {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1Device {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1Device {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method CreateDeviceContext
  
  #[allow(non_snake_case)]
  pub fn create_device_context(&self, options: D2D1_DEVICE_CONTEXT_OPTIONS) -> HResult<D2D1DeviceContext> {
    let mut lv1: *mut ID2D1DeviceContext = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Device)).CreateDeviceContext(options, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1DeviceContext::new(lv1 as *mut _))
  }
  
  //  Method CreatePrintControl
  //  Error: printControl parameter: ANone annotation cannot be used with double indirection
  //  Method SetMaximumTextureMemory
  
  #[allow(non_snake_case)]
  pub fn set_maximum_texture_memory(&self, maximumInBytes: UINT64) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Device)).SetMaximumTextureMemory(maximumInBytes) };
    ()
  }
  
  //  Method GetMaximumTextureMemory
  
  #[allow(non_snake_case)]
  pub fn get_maximum_texture_memory(&self) -> UINT64 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Device)).GetMaximumTextureMemory() };
    _hr
  }
  
  //  Method ClearResources
  
  #[allow(non_snake_case)]
  pub fn clear_resources(&self, millisecondsSinceUse: UINT32) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Device)).ClearResources(millisecondsSinceUse) };
    ()
  }
  
  
}

pub struct D2D1DrawingStateBlock1(*mut ID2D1DrawingStateBlock1);

impl HasIID for D2D1DrawingStateBlock1 {
  fn iid() -> REFGUID { &IID_ID2D1DrawingStateBlock1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1DrawingStateBlock1(pp_vtbl as *mut _ as *mut ID2D1DrawingStateBlock1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1DrawingStateBlock1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1DrawingStateBlock1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1DrawingStateBlock1 {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method GetDescription
  
  #[allow(non_snake_case)]
  pub fn get_description(&self) -> D2D1_DRAWING_STATE_DESCRIPTION {
    let mut lv1: D2D1_DRAWING_STATE_DESCRIPTION = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1DrawingStateBlock)).GetDescription(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method SetDescription
  
  #[allow(non_snake_case)]
  pub fn set_description(&self, stateDescription: &D2D1_DRAWING_STATE_DESCRIPTION) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DrawingStateBlock)).SetDescription(stateDescription) };
    ()
  }
  
  //  Method SetTextRenderingParams
  
  #[allow(non_snake_case)]
  pub fn set_text_rendering_params<T: HasIID>(&self, textRenderingParams: &T) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DrawingStateBlock)).SetTextRenderingParams(textRenderingParams.iptr() as *mut _ as *mut _ ) };
    ()
  }
  
  //  Method GetTextRenderingParams
  
  #[allow(non_snake_case)]
  pub fn get_text_rendering_params(&self) -> DWriteRenderingParams {
    let mut lv1: *mut IDWriteRenderingParams = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1DrawingStateBlock)).GetTextRenderingParams(&mut lv1 as *mut *mut _) };
    DWriteRenderingParams::new(lv1 as *mut _)
  }
  
  //  Method GetDescription
  
  #[allow(non_snake_case)]
  pub fn get_description1(&self, stateDescription: &mut D2D1_DRAWING_STATE_DESCRIPTION1) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DrawingStateBlock1)).GetDescription(stateDescription) };
    ()
  }
  
  //  Method SetDescription
  
  #[allow(non_snake_case)]
  pub fn set_description1(&self, stateDescription: &D2D1_DRAWING_STATE_DESCRIPTION1) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1DrawingStateBlock1)).SetDescription(stateDescription) };
    ()
  }
  
  
}

pub struct D2D1Effect(*mut ID2D1Effect);

impl HasIID for D2D1Effect {
  fn iid() -> REFGUID { &IID_ID2D1Effect }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1Effect(pp_vtbl as *mut _ as *mut ID2D1Effect) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1Effect {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1Effect {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1Effect {
  //  Method GetPropertyCount
  
  #[allow(non_snake_case)]
  pub fn get_property_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyCount() };
    _hr
  }
  
  //  Method GetPropertyName
  
  #[allow(non_snake_case)]
  pub fn get_property_name(&self, index: UINT32, name: PWSTR, nameCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyName(index, name, nameCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPropertyNameLength
  
  #[allow(non_snake_case)]
  pub fn get_property_name_length(&self, index: UINT32) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyNameLength(index) };
    _hr
  }
  
  //  Method GetType
  
  #[allow(non_snake_case)]
  pub fn get_type(&self, index: UINT32) -> D2D1_PROPERTY_TYPE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetType(index) };
    _hr
  }
  
  //  Method GetPropertyIndex
  
  #[allow(non_snake_case)]
  pub fn get_property_index(&self, name: PCWSTR) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyIndex(name) };
    _hr
  }
  
  //  Method SetValueByName
  
  #[allow(non_snake_case)]
  pub fn set_value_by_name(&self, name: PCWSTR, type_: D2D1_PROPERTY_TYPE, data: &BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).SetValueByName(name, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetValue
  
  #[allow(non_snake_case)]
  pub fn set_value(&self, index: UINT32, type_: D2D1_PROPERTY_TYPE, data: &BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).SetValue(index, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValueByName
  
  #[allow(non_snake_case)]
  pub fn get_value_by_name(&self, name: PCWSTR, type_: D2D1_PROPERTY_TYPE, data: &mut BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetValueByName(name, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValue
  
  #[allow(non_snake_case)]
  pub fn get_value(&self, index: UINT32, type_: D2D1_PROPERTY_TYPE, data: &mut BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetValue(index, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValueSize
  
  #[allow(non_snake_case)]
  pub fn get_value_size(&self, index: UINT32) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetValueSize(index) };
    _hr
  }
  
  //  Method GetSubProperties
  //  Error: subProperties parameter: ANone annotation cannot be used with double indirection
  //  Method SetInput
  
  #[allow(non_snake_case)]
  pub fn set_input(&self, index: UINT32, input: &mut ID2D1Image, invalidate: BOOL) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Effect)).SetInput(index, input, invalidate) };
    ()
  }
  
  //  Method SetInputCount
  
  #[allow(non_snake_case)]
  pub fn set_input_count(&self, inputCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Effect)).SetInputCount(inputCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetInput
  //  Error: input parameter: ANone annotation cannot be used with double indirection
  //  Method GetInputCount
  
  #[allow(non_snake_case)]
  pub fn get_input_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Effect)).GetInputCount() };
    _hr
  }
  
  //  Method GetOutput
  //  Error: outputImage parameter: ANone annotation cannot be used with double indirection
  
}

pub struct D2D1Factory1(*mut ID2D1Factory1);

impl HasIID for D2D1Factory1 {
  fn iid() -> REFGUID { &IID_ID2D1Factory1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1Factory1(pp_vtbl as *mut _ as *mut ID2D1Factory1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1Factory1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1Factory1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1Factory1 {
  //  Method ReloadSystemMetrics
  
  #[allow(non_snake_case)]
  pub fn reload_system_metrics(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).ReloadSystemMetrics() };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDesktopDpi
  
  #[allow(non_snake_case)]
  pub fn get_desktop_dpi(&self) -> (FLOAT, FLOAT) {
    let mut lv1: FLOAT = unsafe {mem::uninitialized::<_>()};
    let mut lv2: FLOAT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).GetDesktopDpi(&mut lv1 as *mut _ as *mut _, &mut lv2 as *mut _ as *mut _) };
    (lv1, lv2)
  }
  
  //  Method CreateRectangleGeometry
  
  #[allow(non_snake_case)]
  pub fn create_rectangle_geometry(&self, rectangle: &D2D1_RECT_F) -> HResult<D2D1RectangleGeometry> {
    let mut lv1: *mut ID2D1RectangleGeometry = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateRectangleGeometry(rectangle, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1RectangleGeometry::new(lv1 as *mut _))
  }
  
  //  Method CreateRoundedRectangleGeometry
  
  #[allow(non_snake_case)]
  pub fn create_rounded_rectangle_geometry(&self, roundedRectangle: &D2D1_ROUNDED_RECT) -> HResult<D2D1RoundedRectangleGeometry> {
    let mut lv1: *mut ID2D1RoundedRectangleGeometry = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateRoundedRectangleGeometry(roundedRectangle, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1RoundedRectangleGeometry::new(lv1 as *mut _))
  }
  
  //  Method CreateEllipseGeometry
  
  #[allow(non_snake_case)]
  pub fn create_ellipse_geometry(&self, ellipse: &D2D1_ELLIPSE) -> HResult<D2D1EllipseGeometry> {
    let mut lv1: *mut ID2D1EllipseGeometry = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateEllipseGeometry(ellipse, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1EllipseGeometry::new(lv1 as *mut _))
  }
  
  //  Method CreateGeometryGroup
  
  #[allow(non_snake_case)]
  pub fn create_geometry_group<T: HasIID>(&self, fillMode: D2D1_FILL_MODE, geometries: &[&T]) -> HResult<D2D1GeometryGroup> {
    let mut lv1: Vec<*mut IUnknown> = geometries.iter().map(|o|o.iptr()).collect();
    let mut lv2: *mut ID2D1GeometryGroup = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateGeometryGroup(fillMode, lv1.as_mut_ptr() as *mut *mut _ as *mut *mut _, geometries.len() as UINT32, &mut lv2 as *mut *mut _) };
    hr2ret(_hr,D2D1GeometryGroup::new(lv2 as *mut _))
  }
  
  //  Method CreateTransformedGeometry
  
  #[allow(non_snake_case)]
  pub fn create_transformed_geometry<T: HasIID>(&self, sourceGeometry: &T, transform: Option<&D2D1_MATRIX_3X2_F>) -> HResult<D2D1TransformedGeometry> {
    let mut lv1: *mut ID2D1TransformedGeometry = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateTransformedGeometry(sourceGeometry.iptr() as *mut _ as *mut _ , transform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1TransformedGeometry::new(lv1 as *mut _))
  }
  
  //  Method CreatePathGeometry
  
  #[allow(non_snake_case)]
  pub fn create_path_geometry(&self) -> HResult<D2D1PathGeometry> {
    let mut lv1: *mut ID2D1PathGeometry = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreatePathGeometry(&mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1PathGeometry::new(lv1 as *mut _))
  }
  
  //  Method CreateStrokeStyle
  
  #[allow(non_snake_case)]
  pub fn create_stroke_style(&self, strokeStyleProperties: &D2D1_STROKE_STYLE_PROPERTIES, dashes: Option<&[FLOAT]>) -> HResult<D2D1StrokeStyle> {
    let mut lv1: *mut ID2D1StrokeStyle = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateStrokeStyle(strokeStyleProperties, opt_arr_as_ptr(&dashes) as *const _, dashes.as_ref().map(|a|a.len()).unwrap_or(0) as UINT32, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1StrokeStyle::new(lv1 as *mut _))
  }
  
  //  Method CreateDrawingStateBlock
  
  #[allow(non_snake_case)]
  pub fn create_drawing_state_block(&self, drawingStateDescription: Option<&D2D1_DRAWING_STATE_DESCRIPTION>, textRenderingParams: Option<&DWriteRenderingParams>) -> HResult<D2D1DrawingStateBlock> {
    let mut lv1: *mut ID2D1DrawingStateBlock = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateDrawingStateBlock(drawingStateDescription.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), textRenderingParams.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1DrawingStateBlock::new(lv1 as *mut _))
  }
  
  //  Method CreateWicBitmapRenderTarget
  
  #[allow(non_snake_case)]
  pub fn create_wic_bitmap_render_target<T: HasIID>(&self, target: &T, renderTargetProperties: Option<&D2D1_RENDER_TARGET_PROPERTIES>) -> HResult<D2D1RenderTarget> {
    let mut lv1: *mut ID2D1RenderTarget = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateWicBitmapRenderTarget(target.iptr() as *mut _ as *mut _ , renderTargetProperties.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1RenderTarget::new(lv1 as *mut _))
  }
  
  //  Method CreateHwndRenderTarget
  
  #[allow(non_snake_case)]
  pub fn create_hwnd_render_target(&self, renderTargetProperties: &D2D1_RENDER_TARGET_PROPERTIES, hwndRenderTargetProperties: &D2D1_HWND_RENDER_TARGET_PROPERTIES) -> HResult<D2D1HwndRenderTarget> {
    let mut lv1: *mut ID2D1HwndRenderTarget = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateHwndRenderTarget(renderTargetProperties, hwndRenderTargetProperties, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1HwndRenderTarget::new(lv1 as *mut _))
  }
  
  //  Method CreateDxgiSurfaceRenderTarget
  
  #[allow(non_snake_case)]
  pub fn create_dxgi_surface_render_target<T: HasIID>(&self, dxgiSurface: &T, renderTargetProperties: &D2D1_RENDER_TARGET_PROPERTIES) -> HResult<D2D1RenderTarget> {
    let mut lv1: *mut ID2D1RenderTarget = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateDxgiSurfaceRenderTarget(dxgiSurface.iptr() as *mut _ as *mut _ , renderTargetProperties, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1RenderTarget::new(lv1 as *mut _))
  }
  
  //  Method CreateDCRenderTarget
  
  #[allow(non_snake_case)]
  pub fn create_d_c_render_target(&self, renderTargetProperties: &D2D1_RENDER_TARGET_PROPERTIES) -> HResult<D2D1DCRenderTarget> {
    let mut lv1: *mut ID2D1DCRenderTarget = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory)).CreateDCRenderTarget(renderTargetProperties, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1DCRenderTarget::new(lv1 as *mut _))
  }
  
  //  Method CreateDevice
  
  #[allow(non_snake_case)]
  pub fn create_device<T: HasIID>(&self, dxgiDevice: &T) -> HResult<D2D1Device> {
    let mut lv1: *mut ID2D1Device = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory1)).CreateDevice(dxgiDevice.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Device::new(lv1 as *mut _))
  }
  
  //  Method CreateStrokeStyle
  //  Error: strokeStyle parameter: ANone annotation cannot be used with double indirection
  //  Method CreatePathGeometry
  //  Error: pathGeometry parameter: ANone annotation cannot be used with double indirection
  //  Method CreateDrawingStateBlock
  //  Error: drawingStateBlock parameter: ANone annotation cannot be used with double indirection
  //  Method CreateGdiMetafile
  //  Error: metafile parameter: ANone annotation cannot be used with double indirection
  //  Method RegisterEffectFromStream
  
  #[allow(non_snake_case)]
  pub fn register_effect_from_stream(&self, classId: &IID, propertyXml: &mut IStream, bindings: &D2D1_PROPERTY_BINDING, bindingsCount: UINT32, effectFactory: PD2D1_EFFECT_FACTORY) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory1)).RegisterEffectFromStream(classId, propertyXml, bindings, bindingsCount, effectFactory) };
    hr2ret(_hr,_hr)
  }
  
  //  Method RegisterEffectFromString
  
  #[allow(non_snake_case)]
  pub fn register_effect_from_string(&self, classId: &IID, propertyXml: PCWSTR, bindings: &D2D1_PROPERTY_BINDING, bindingsCount: UINT32, effectFactory: PD2D1_EFFECT_FACTORY) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory1)).RegisterEffectFromString(classId, propertyXml, bindings, bindingsCount, effectFactory) };
    hr2ret(_hr,_hr)
  }
  
  //  Method UnregisterEffect
  
  #[allow(non_snake_case)]
  pub fn unregister_effect(&self, classId: &IID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory1)).UnregisterEffect(classId) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetRegisteredEffects
  
  #[allow(non_snake_case)]
  pub fn get_registered_effects(&self, effects: &mut CLSID, effectsCount: UINT32, effectsReturned: &mut UINT32, effectsRegistered: &mut UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Factory1)).GetRegisteredEffects(effects, effectsCount, effectsReturned, effectsRegistered) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectProperties
  //  Error: properties parameter: ANone annotation cannot be used with double indirection
  
}

pub struct D2D1GdiMetafileSink(*mut ID2D1GdiMetafileSink);

impl HasIID for D2D1GdiMetafileSink {
  fn iid() -> REFGUID { &IID_ID2D1GdiMetafileSink }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1GdiMetafileSink(pp_vtbl as *mut _ as *mut ID2D1GdiMetafileSink) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1GdiMetafileSink {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1GdiMetafileSink {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1GdiMetafileSink {
  //  Method ProcessRecord
  //  Warning: recordData parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  pub fn process_record<T>(&self, recordType: DWORD, recordData: &[T], recordDataSize: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GdiMetafileSink)).ProcessRecord(recordType, recordData.as_ptr() as *const _, recordDataSize) };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1GdiMetafile(*mut ID2D1GdiMetafile);

impl HasIID for D2D1GdiMetafile {
  fn iid() -> REFGUID { &IID_ID2D1GdiMetafile }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1GdiMetafile(pp_vtbl as *mut _ as *mut ID2D1GdiMetafile) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1GdiMetafile {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1GdiMetafile {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1GdiMetafile {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method Stream
  
  #[allow(non_snake_case)]
  pub fn stream(&self, sink: &mut ID2D1GdiMetafileSink) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GdiMetafile)).Stream(sink) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetBounds
  
  #[allow(non_snake_case)]
  pub fn get_bounds(&self, bounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GdiMetafile)).GetBounds(bounds) };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1GradientStopCollection1(*mut ID2D1GradientStopCollection1);

impl HasIID for D2D1GradientStopCollection1 {
  fn iid() -> REFGUID { &IID_ID2D1GradientStopCollection1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1GradientStopCollection1(pp_vtbl as *mut _ as *mut ID2D1GradientStopCollection1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1GradientStopCollection1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1GradientStopCollection1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1GradientStopCollection1 {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method GetGradientStopCount
  
  #[allow(non_snake_case)]
  pub fn get_gradient_stop_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection)).GetGradientStopCount() };
    _hr
  }
  
  //  Method GetGradientStops
  
  #[allow(non_snake_case)]
  pub fn get_gradient_stops(&self, gradientStops: &mut [D2D1_GRADIENT_STOP]) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection)).GetGradientStops(slice_as_mut_ptr(gradientStops), gradientStops.len() as UINT32) };
    ()
  }
  
  //  Method GetColorInterpolationGamma
  
  #[allow(non_snake_case)]
  pub fn get_color_interpolation_gamma(&self) -> D2D1_GAMMA {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection)).GetColorInterpolationGamma() };
    _hr
  }
  
  //  Method GetExtendMode
  
  #[allow(non_snake_case)]
  pub fn get_extend_mode(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection)).GetExtendMode() };
    _hr
  }
  
  //  Method GetGradientStops1
  
  #[allow(non_snake_case)]
  pub fn get_gradient_stops1(&self, gradientStops: &mut D2D1_GRADIENT_STOP, gradientStopsCount: UINT32) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection1)).GetGradientStops1(gradientStops, gradientStopsCount) };
    ()
  }
  
  //  Method GetPreInterpolationSpace
  
  #[allow(non_snake_case)]
  pub fn get_pre_interpolation_space(&self) -> D2D1_COLOR_SPACE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection1)).GetPreInterpolationSpace() };
    _hr
  }
  
  //  Method GetPostInterpolationSpace
  
  #[allow(non_snake_case)]
  pub fn get_post_interpolation_space(&self) -> D2D1_COLOR_SPACE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection1)).GetPostInterpolationSpace() };
    _hr
  }
  
  //  Method GetBufferPrecision
  
  #[allow(non_snake_case)]
  pub fn get_buffer_precision(&self) -> D2D1_BUFFER_PRECISION {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection1)).GetBufferPrecision() };
    _hr
  }
  
  //  Method GetColorInterpolationMode
  
  #[allow(non_snake_case)]
  pub fn get_color_interpolation_mode(&self) -> D2D1_COLOR_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1GradientStopCollection1)).GetColorInterpolationMode() };
    _hr
  }
  
  
}

pub struct D2D1ImageBrush(*mut ID2D1ImageBrush);

impl HasIID for D2D1ImageBrush {
  fn iid() -> REFGUID { &IID_ID2D1ImageBrush }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1ImageBrush(pp_vtbl as *mut _ as *mut ID2D1ImageBrush) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1ImageBrush {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1ImageBrush {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1ImageBrush {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method SetOpacity
  
  #[allow(non_snake_case)]
  pub fn set_opacity(&self, opacity: FLOAT) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).SetOpacity(opacity) };
    ()
  }
  
  //  Method SetTransform
  
  #[allow(non_snake_case)]
  pub fn set_transform(&self, transform: &D2D1_MATRIX_3X2_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).SetTransform(transform) };
    ()
  }
  
  //  Method GetOpacity
  
  #[allow(non_snake_case)]
  pub fn get_opacity(&self) -> FLOAT {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).GetOpacity() };
    _hr
  }
  
  //  Method GetTransform
  
  #[allow(non_snake_case)]
  pub fn get_transform(&self) -> D2D1_MATRIX_3X2_F {
    let mut lv1: D2D1_MATRIX_3X2_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Brush)).GetTransform(&mut lv1 as *mut _ as *mut _) };
    lv1
  }
  
  //  Method SetImage
  
  #[allow(non_snake_case)]
  pub fn set_image(&self, image: &mut ID2D1Image) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).SetImage(image) };
    ()
  }
  
  //  Method SetExtendModeX
  
  #[allow(non_snake_case)]
  pub fn set_extend_mode_x(&self, extendModeX: D2D1_EXTEND_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).SetExtendModeX(extendModeX) };
    ()
  }
  
  //  Method SetExtendModeY
  
  #[allow(non_snake_case)]
  pub fn set_extend_mode_y(&self, extendModeY: D2D1_EXTEND_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).SetExtendModeY(extendModeY) };
    ()
  }
  
  //  Method SetInterpolationMode
  
  #[allow(non_snake_case)]
  pub fn set_interpolation_mode(&self, interpolationMode: D2D1_INTERPOLATION_MODE) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).SetInterpolationMode(interpolationMode) };
    ()
  }
  
  //  Method SetSourceRectangle
  
  #[allow(non_snake_case)]
  pub fn set_source_rectangle(&self, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).SetSourceRectangle(sourceRectangle) };
    ()
  }
  
  //  Method GetImage
  //  Error: image parameter: ANone annotation cannot be used with double indirection
  //  Method GetExtendModeX
  
  #[allow(non_snake_case)]
  pub fn get_extend_mode_x(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).GetExtendModeX() };
    _hr
  }
  
  //  Method GetExtendModeY
  
  #[allow(non_snake_case)]
  pub fn get_extend_mode_y(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).GetExtendModeY() };
    _hr
  }
  
  //  Method GetInterpolationMode
  
  #[allow(non_snake_case)]
  pub fn get_interpolation_mode(&self) -> D2D1_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).GetInterpolationMode() };
    _hr
  }
  
  //  Method GetSourceRectangle
  
  #[allow(non_snake_case)]
  pub fn get_source_rectangle(&self, sourceRectangle: &mut D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1ImageBrush)).GetSourceRectangle(sourceRectangle) };
    ()
  }
  
  
}

pub struct D2D1Multithread(*mut ID2D1Multithread);

impl HasIID for D2D1Multithread {
  fn iid() -> REFGUID { &IID_ID2D1Multithread }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1Multithread(pp_vtbl as *mut _ as *mut ID2D1Multithread) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1Multithread {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1Multithread {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1Multithread {
  //  Method GetMultithreadProtected
  
  #[allow(non_snake_case)]
  pub fn get_multithread_protected(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Multithread)).GetMultithreadProtected() };
    _hr
  }
  
  //  Method Enter
  
  #[allow(non_snake_case)]
  pub fn enter(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Multithread)).Enter() };
    ()
  }
  
  //  Method Leave
  
  #[allow(non_snake_case)]
  pub fn leave(&self) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Multithread)).Leave() };
    ()
  }
  
  
}

pub struct D2D1PathGeometry1(*mut ID2D1PathGeometry1);

impl HasIID for D2D1PathGeometry1 {
  fn iid() -> REFGUID { &IID_ID2D1PathGeometry1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1PathGeometry1(pp_vtbl as *mut _ as *mut ID2D1PathGeometry1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1PathGeometry1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1PathGeometry1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1PathGeometry1 {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method GetBounds
  
  #[allow(non_snake_case)]
  pub fn get_bounds(&self, worldTransform: Option<&D2D1_MATRIX_3X2_F>) -> HResult<D2D1_RECT_F> {
    let mut lv1: D2D1_RECT_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).GetBounds(worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetWidenedBounds
  
  #[allow(non_snake_case)]
  pub fn get_widened_bounds(&self, strokeWidth: FLOAT, strokeStyle: Option<&D2D1StrokeStyle>, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<D2D1_RECT_F> {
    let mut lv1: D2D1_RECT_F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).GetWidenedBounds(strokeWidth, strokeStyle.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method StrokeContainsPoint
  
  #[allow(non_snake_case)]
  pub fn stroke_contains_point(&self, point: D2D1_POINT_2F, strokeWidth: FLOAT, strokeStyle: Option<&D2D1StrokeStyle>, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<BOOL> {
    let mut lv1: BOOL = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).StrokeContainsPoint(point, strokeWidth, strokeStyle.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method FillContainsPoint
  
  #[allow(non_snake_case)]
  pub fn fill_contains_point(&self, point: D2D1_POINT_2F, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<BOOL> {
    let mut lv1: BOOL = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).FillContainsPoint(point, worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method CompareWithGeometry
  
  #[allow(non_snake_case)]
  pub fn compare_with_geometry<T: HasIID>(&self, inputGeometry: &T, inputGeometryTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<D2D1_GEOMETRY_RELATION> {
    let mut lv1: D2D1_GEOMETRY_RELATION = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).CompareWithGeometry(inputGeometry.iptr() as *mut _ as *mut _ , inputGeometryTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method Simplify
  
  #[allow(non_snake_case)]
  pub fn simplify<T: HasIID>(&self, simplificationOption: D2D1_GEOMETRY_SIMPLIFICATION_OPTION, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT, geometrySink: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).Simplify(simplificationOption, worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, geometrySink.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Tessellate
  
  #[allow(non_snake_case)]
  pub fn tessellate<T: HasIID>(&self, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT, tessellationSink: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).Tessellate(worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, tessellationSink.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method CombineWithGeometry
  
  #[allow(non_snake_case)]
  pub fn combine_with_geometry<T: HasIID, T1: HasIID>(&self, inputGeometry: &T, combineMode: D2D1_COMBINE_MODE, inputGeometryTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT, geometrySink: &T1) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).CombineWithGeometry(inputGeometry.iptr() as *mut _ as *mut _ , combineMode, inputGeometryTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, geometrySink.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Outline
  
  #[allow(non_snake_case)]
  pub fn outline<T: HasIID>(&self, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT, geometrySink: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).Outline(worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, geometrySink.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method ComputeArea
  
  #[allow(non_snake_case)]
  pub fn compute_area(&self, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<FLOAT> {
    let mut lv1: FLOAT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).ComputeArea(worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method ComputeLength
  
  #[allow(non_snake_case)]
  pub fn compute_length(&self, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<FLOAT> {
    let mut lv1: FLOAT = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).ComputeLength(worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method ComputePointAtLength
  
  #[allow(non_snake_case)]
  pub fn compute_point_at_length(&self, length: FLOAT, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT) -> HResult<(D2D1_POINT_2F, D2D1_POINT_2F)> {
    let mut lv1: D2D1_POINT_2F = unsafe {mem::uninitialized::<_>()};
    let mut lv2: D2D1_POINT_2F = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).ComputePointAtLength(length, worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, &mut lv1 as *mut _ as *mut _, &mut lv2 as *mut _ as *mut _) };
    hr2ret(_hr,(lv1, lv2))
  }
  
  //  Method Widen
  
  #[allow(non_snake_case)]
  pub fn widen<T: HasIID>(&self, strokeWidth: FLOAT, strokeStyle: Option<&D2D1StrokeStyle>, worldTransform: Option<&D2D1_MATRIX_3X2_F>, flatteningTolerance: FLOAT, geometrySink: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Geometry)).Widen(strokeWidth, strokeStyle.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _, worldTransform.as_ref().map(|p|*p as *const _ as *const _).unwrap_or(ptr::null()), flatteningTolerance, geometrySink.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Open
  
  #[allow(non_snake_case)]
  pub fn open(&self) -> HResult<D2D1GeometrySink> {
    let mut lv1: *mut ID2D1GeometrySink = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1PathGeometry)).Open(&mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1GeometrySink::new(lv1 as *mut _))
  }
  
  //  Method Stream
  
  #[allow(non_snake_case)]
  pub fn stream<T: HasIID>(&self, geometrySink: &T) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1PathGeometry)).Stream(geometrySink.iptr() as *mut _ as *mut _ ) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetSegmentCount
  
  #[allow(non_snake_case)]
  pub fn get_segment_count(&self) -> HResult<UINT32> {
    let mut lv1: UINT32 = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1PathGeometry)).GetSegmentCount(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method GetFigureCount
  
  #[allow(non_snake_case)]
  pub fn get_figure_count(&self) -> HResult<UINT32> {
    let mut lv1: UINT32 = unsafe {mem::uninitialized::<_>()};
    let _hr=unsafe { (*(self.0 as *mut ID2D1PathGeometry)).GetFigureCount(&mut lv1 as *mut _ as *mut _) };
    hr2ret(_hr,lv1)
  }
  
  //  Method ComputePointAndSegmentAtLength
  
  #[allow(non_snake_case)]
  pub fn compute_point_and_segment_at_length(&self, length: FLOAT, startSegment: UINT32, worldTransform: &D2D1_MATRIX_3X2_F, flatteningTolerance: FLOAT, pointDescription: &mut D2D1_POINT_DESCRIPTION) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1PathGeometry1)).ComputePointAndSegmentAtLength(length, startSegment, worldTransform, flatteningTolerance, pointDescription) };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1PrintControl(*mut ID2D1PrintControl);

impl HasIID for D2D1PrintControl {
  fn iid() -> REFGUID { &IID_ID2D1PrintControl }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1PrintControl(pp_vtbl as *mut _ as *mut ID2D1PrintControl) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1PrintControl {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1PrintControl {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1PrintControl {
  //  Method AddPage
  
  #[allow(non_snake_case)]
  pub fn add_page(&self, commandList: &mut ID2D1CommandList, pageSize: D2D_SIZE_F, pagePrintTicketStream: &mut IStream, tag1: &mut D2D1_TAG, tag2: &mut D2D1_TAG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1PrintControl)).AddPage(commandList, pageSize, pagePrintTicketStream, tag1, tag2) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Close
  
  #[allow(non_snake_case)]
  pub fn close(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1PrintControl)).Close() };
    hr2ret(_hr,_hr)
  }
  
  
}

pub struct D2D1Properties(*mut ID2D1Properties);

impl HasIID for D2D1Properties {
  fn iid() -> REFGUID { &IID_ID2D1Properties }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1Properties(pp_vtbl as *mut _ as *mut ID2D1Properties) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1Properties {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1Properties {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1Properties {
  //  Method GetPropertyCount
  
  #[allow(non_snake_case)]
  pub fn get_property_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyCount() };
    _hr
  }
  
  //  Method GetPropertyName
  
  #[allow(non_snake_case)]
  pub fn get_property_name(&self, index: UINT32, name: PWSTR, nameCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyName(index, name, nameCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPropertyNameLength
  
  #[allow(non_snake_case)]
  pub fn get_property_name_length(&self, index: UINT32) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyNameLength(index) };
    _hr
  }
  
  //  Method GetType
  
  #[allow(non_snake_case)]
  pub fn get_type(&self, index: UINT32) -> D2D1_PROPERTY_TYPE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetType(index) };
    _hr
  }
  
  //  Method GetPropertyIndex
  
  #[allow(non_snake_case)]
  pub fn get_property_index(&self, name: PCWSTR) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetPropertyIndex(name) };
    _hr
  }
  
  //  Method SetValueByName
  
  #[allow(non_snake_case)]
  pub fn set_value_by_name(&self, name: PCWSTR, type_: D2D1_PROPERTY_TYPE, data: &BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).SetValueByName(name, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetValue
  
  #[allow(non_snake_case)]
  pub fn set_value(&self, index: UINT32, type_: D2D1_PROPERTY_TYPE, data: &BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).SetValue(index, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValueByName
  
  #[allow(non_snake_case)]
  pub fn get_value_by_name(&self, name: PCWSTR, type_: D2D1_PROPERTY_TYPE, data: &mut BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetValueByName(name, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValue
  
  #[allow(non_snake_case)]
  pub fn get_value(&self, index: UINT32, type_: D2D1_PROPERTY_TYPE, data: &mut BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetValue(index, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValueSize
  
  #[allow(non_snake_case)]
  pub fn get_value_size(&self, index: UINT32) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1Properties)).GetValueSize(index) };
    _hr
  }
  
  //  Method GetSubProperties
  //  Error: subProperties parameter: ANone annotation cannot be used with double indirection
  
}

pub struct D2D1StrokeStyle1(*mut ID2D1StrokeStyle1);

impl HasIID for D2D1StrokeStyle1 {
  fn iid() -> REFGUID { &IID_ID2D1StrokeStyle1 }
  fn new(pp_vtbl : *mut IUnknown) -> Self { D2D1StrokeStyle1(pp_vtbl as *mut _ as *mut ID2D1StrokeStyle1) }
  fn iptr(&self) -> *mut IUnknown { self.0 as *mut _ as  *mut IUnknown}
}
impl Drop for D2D1StrokeStyle1 {
  fn drop(&mut self) {
    release_com_ptr(self)
  }
}

impl Clone for D2D1StrokeStyle1 {
  fn clone(&self) -> Self {
    clone_com_ptr(self)
  }
}



impl D2D1StrokeStyle1 {
  //  Method GetFactory
  
  #[allow(non_snake_case)]
  pub fn get_factory(&self) -> D2D1Factory {
    let mut lv1: *mut ID2D1Factory = ptr::null_mut();
    let _hr=unsafe { (*(self.0 as *mut ID2D1Resource)).GetFactory(&mut lv1 as *mut *mut _) };
    D2D1Factory::new(lv1 as *mut _)
  }
  
  //  Method GetStartCap
  
  #[allow(non_snake_case)]
  pub fn get_start_cap(&self) -> D2D1_CAP_STYLE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetStartCap() };
    _hr
  }
  
  //  Method GetEndCap
  
  #[allow(non_snake_case)]
  pub fn get_end_cap(&self) -> D2D1_CAP_STYLE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetEndCap() };
    _hr
  }
  
  //  Method GetDashCap
  
  #[allow(non_snake_case)]
  pub fn get_dash_cap(&self) -> D2D1_CAP_STYLE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetDashCap() };
    _hr
  }
  
  //  Method GetMiterLimit
  
  #[allow(non_snake_case)]
  pub fn get_miter_limit(&self) -> FLOAT {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetMiterLimit() };
    _hr
  }
  
  //  Method GetLineJoin
  
  #[allow(non_snake_case)]
  pub fn get_line_join(&self) -> D2D1_LINE_JOIN {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetLineJoin() };
    _hr
  }
  
  //  Method GetDashOffset
  
  #[allow(non_snake_case)]
  pub fn get_dash_offset(&self) -> FLOAT {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetDashOffset() };
    _hr
  }
  
  //  Method GetDashStyle
  
  #[allow(non_snake_case)]
  pub fn get_dash_style(&self) -> D2D1_DASH_STYLE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetDashStyle() };
    _hr
  }
  
  //  Method GetDashesCount
  
  #[allow(non_snake_case)]
  pub fn get_dashes_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetDashesCount() };
    _hr
  }
  
  //  Method GetDashes
  
  #[allow(non_snake_case)]
  pub fn get_dashes(&self, dashes: &mut FLOAT, dashesCount: UINT32) -> () {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle)).GetDashes(dashes, dashesCount) };
    ()
  }
  
  //  Method GetStrokeTransformType
  
  #[allow(non_snake_case)]
  pub fn get_stroke_transform_type(&self) -> D2D1_STROKE_TRANSFORM_TYPE {
  
    let _hr=unsafe { (*(self.0 as *mut ID2D1StrokeStyle1)).GetStrokeTransformType() };
    _hr
  }
  
  
}
