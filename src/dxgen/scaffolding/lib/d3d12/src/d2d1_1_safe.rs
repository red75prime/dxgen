// This file is autogenerated

use utils::*;

use d2d1_safe::*;
use dxgi_safe::*;
use dwrite_safe::*;
pub trait TD2D1Bitmap1: TD2D1Bitmap {
  //  Method GetColorContext
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method GetOptions
  
  #[allow(non_snake_case)]
  fn get_options(&self) -> D2D1_BITMAP_OPTIONS {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Bitmap1)).GetOptions() };
    _hr
  }
  
  //  Method GetSurface
  //  Error: dxgiSurface parameter: ANone annotation cannot be used with double indirection
  //  Method Map
  
  #[allow(non_snake_case)]
  fn map(&self, options: D2D1_MAP_OPTIONS, mappedRect: &mut D2D1_MAPPED_RECT) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Bitmap1)).Map(options, mappedRect) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Unmap
  
  #[allow(non_snake_case)]
  fn unmap(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Bitmap1)).Unmap() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1Bitmap1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Bitmap1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Bitmap1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Bitmap1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1Bitmap1 {}
impl TD2D1Image for D2D1Bitmap1 {}
impl TD2D1Bitmap for D2D1Bitmap1 {}
impl TD2D1Bitmap1 for D2D1Bitmap1 {}

pub struct D2D1Bitmap1(*mut ID2D1Bitmap1);

impl HasIID for D2D1Bitmap1 {
  fn iid() -> REFGUID { &IID_ID2D1Bitmap1 }
}

pub trait TD2D1BitmapBrush1: TD2D1BitmapBrush {
  //  Method SetInterpolationMode1
  
  #[allow(non_snake_case)]
  fn set_interpolation_mode1(&self, interpolationMode: D2D1_INTERPOLATION_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1BitmapBrush1)).SetInterpolationMode1(interpolationMode) };
    ()
  }
  
  //  Method GetInterpolationMode1
  
  #[allow(non_snake_case)]
  fn get_interpolation_mode1(&self) -> D2D1_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1BitmapBrush1)).GetInterpolationMode1() };
    _hr
  }
  
  
}

impl TUnknown for D2D1BitmapBrush1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1BitmapBrush1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1BitmapBrush1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1BitmapBrush1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1BitmapBrush1 {}
impl TD2D1Brush for D2D1BitmapBrush1 {}
impl TD2D1BitmapBrush for D2D1BitmapBrush1 {}
impl TD2D1BitmapBrush1 for D2D1BitmapBrush1 {}

pub struct D2D1BitmapBrush1(*mut ID2D1BitmapBrush1);

impl HasIID for D2D1BitmapBrush1 {
  fn iid() -> REFGUID { &IID_ID2D1BitmapBrush1 }
}

pub trait TD2D1ColorContext: TD2D1Resource {
  //  Method GetColorSpace
  
  #[allow(non_snake_case)]
  fn get_color_space(&self) -> D2D1_COLOR_SPACE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ColorContext)).GetColorSpace() };
    _hr
  }
  
  //  Method GetProfileSize
  
  #[allow(non_snake_case)]
  fn get_profile_size(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ColorContext)).GetProfileSize() };
    _hr
  }
  
  //  Method GetProfile
  
  #[allow(non_snake_case)]
  fn get_profile(&self, profile: &mut BYTE, profileSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ColorContext)).GetProfile(profile, profileSize) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1ColorContext {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1ColorContext(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1ColorContext {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1ColorContext {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1ColorContext {}
impl TD2D1ColorContext for D2D1ColorContext {}

pub struct D2D1ColorContext(*mut ID2D1ColorContext);

impl HasIID for D2D1ColorContext {
  fn iid() -> REFGUID { &IID_ID2D1ColorContext }
}

pub trait TD2D1CommandList: TD2D1Image {
  //  Method Stream
  
  #[allow(non_snake_case)]
  fn stream(&self, sink: &mut ID2D1CommandSink) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandList)).Stream(sink) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Close
  
  #[allow(non_snake_case)]
  fn close(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandList)).Close() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1CommandList {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1CommandList(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1CommandList {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1CommandList {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1CommandList {}
impl TD2D1Image for D2D1CommandList {}
impl TD2D1CommandList for D2D1CommandList {}

pub struct D2D1CommandList(*mut ID2D1CommandList);

impl HasIID for D2D1CommandList {
  fn iid() -> REFGUID { &IID_ID2D1CommandList }
}

pub trait TD2D1CommandSink: TUnknown {
  //  Method BeginDraw
  
  #[allow(non_snake_case)]
  fn begin_draw(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).BeginDraw() };
    hr2ret(_hr,_hr)
  }
  
  //  Method EndDraw
  
  #[allow(non_snake_case)]
  fn end_draw(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).EndDraw() };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetAntialiasMode
  
  #[allow(non_snake_case)]
  fn set_antialias_mode(&self, antialiasMode: D2D1_ANTIALIAS_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetAntialiasMode(antialiasMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTags
  
  #[allow(non_snake_case)]
  fn set_tags(&self, tag1: D2D1_TAG, tag2: D2D1_TAG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetTags(tag1, tag2) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTextAntialiasMode
  
  #[allow(non_snake_case)]
  fn set_text_antialias_mode(&self, textAntialiasMode: D2D1_TEXT_ANTIALIAS_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetTextAntialiasMode(textAntialiasMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTextRenderingParams
  
  #[allow(non_snake_case)]
  fn set_text_rendering_params(&self, textRenderingParams: &mut IDWriteRenderingParams) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetTextRenderingParams(textRenderingParams) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetTransform
  
  #[allow(non_snake_case)]
  fn set_transform(&self, transform: &D2D1_MATRIX_3X2_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetTransform(transform) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetPrimitiveBlend
  
  #[allow(non_snake_case)]
  fn set_primitive_blend(&self, primitiveBlend: D2D1_PRIMITIVE_BLEND) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetPrimitiveBlend(primitiveBlend) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetUnitMode
  
  #[allow(non_snake_case)]
  fn set_unit_mode(&self, unitMode: D2D1_UNIT_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).SetUnitMode(unitMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Clear
  
  #[allow(non_snake_case)]
  fn clear(&self, color: &D2D1_COLOR_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).Clear(color) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawGlyphRun
  
  #[allow(non_snake_case)]
  fn draw_glyph_run(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, glyphRunDescription: &DWRITE_GLYPH_RUN_DESCRIPTION, foregroundBrush: &mut ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawGlyphRun(baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawLine
  
  #[allow(non_snake_case)]
  fn draw_line(&self, point0: D2D1_POINT_2F, point1: D2D1_POINT_2F, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawLine(point0, point1, brush, strokeWidth, strokeStyle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawGeometry
  
  #[allow(non_snake_case)]
  fn draw_geometry(&self, geometry: &mut ID2D1Geometry, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawGeometry(geometry, brush, strokeWidth, strokeStyle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawRectangle
  
  #[allow(non_snake_case)]
  fn draw_rectangle(&self, rect: &D2D1_RECT_F, brush: &mut ID2D1Brush, strokeWidth: FLOAT, strokeStyle: &mut ID2D1StrokeStyle) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawRectangle(rect, brush, strokeWidth, strokeStyle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawBitmap
  
  #[allow(non_snake_case)]
  fn draw_bitmap(&self, bitmap: &mut ID2D1Bitmap, destinationRectangle: &D2D1_RECT_F, opacity: FLOAT, interpolationMode: D2D1_INTERPOLATION_MODE, sourceRectangle: &D2D1_RECT_F, perspectiveTransform: &D2D1_MATRIX_4X4_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawBitmap(bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawImage
  
  #[allow(non_snake_case)]
  fn draw_image(&self, image: &mut ID2D1Image, targetOffset: &D2D1_POINT_2F, imageRectangle: &D2D1_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE, compositeMode: D2D1_COMPOSITE_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawImage(image, targetOffset, imageRectangle, interpolationMode, compositeMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method DrawGdiMetafile
  
  #[allow(non_snake_case)]
  fn draw_gdi_metafile(&self, gdiMetafile: &mut ID2D1GdiMetafile, targetOffset: &D2D1_POINT_2F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).DrawGdiMetafile(gdiMetafile, targetOffset) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillMesh
  
  #[allow(non_snake_case)]
  fn fill_mesh(&self, mesh: &mut ID2D1Mesh, brush: &mut ID2D1Brush) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).FillMesh(mesh, brush) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillOpacityMask
  
  #[allow(non_snake_case)]
  fn fill_opacity_mask(&self, opacityMask: &mut ID2D1Bitmap, brush: &mut ID2D1Brush, destinationRectangle: &D2D1_RECT_F, sourceRectangle: &D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).FillOpacityMask(opacityMask, brush, destinationRectangle, sourceRectangle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillGeometry
  
  #[allow(non_snake_case)]
  fn fill_geometry(&self, geometry: &mut ID2D1Geometry, brush: &mut ID2D1Brush, opacityBrush: &mut ID2D1Brush) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).FillGeometry(geometry, brush, opacityBrush) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillRectangle
  
  #[allow(non_snake_case)]
  fn fill_rectangle(&self, rect: &D2D1_RECT_F, brush: &mut ID2D1Brush) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).FillRectangle(rect, brush) };
    hr2ret(_hr,_hr)
  }
  
  //  Method PushAxisAlignedClip
  
  #[allow(non_snake_case)]
  fn push_axis_aligned_clip(&self, clipRect: &D2D1_RECT_F, antialiasMode: D2D1_ANTIALIAS_MODE) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).PushAxisAlignedClip(clipRect, antialiasMode) };
    hr2ret(_hr,_hr)
  }
  
  //  Method PushLayer
  
  #[allow(non_snake_case)]
  fn push_layer(&self, layerParameters1: &D2D1_LAYER_PARAMETERS1, layer: &mut ID2D1Layer) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).PushLayer(layerParameters1, layer) };
    hr2ret(_hr,_hr)
  }
  
  //  Method PopAxisAlignedClip
  
  #[allow(non_snake_case)]
  fn pop_axis_aligned_clip(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).PopAxisAlignedClip() };
    hr2ret(_hr,_hr)
  }
  
  //  Method PopLayer
  
  #[allow(non_snake_case)]
  fn pop_layer(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1CommandSink)).PopLayer() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1CommandSink {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1CommandSink(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1CommandSink {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1CommandSink {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1CommandSink for D2D1CommandSink {}

pub struct D2D1CommandSink(*mut ID2D1CommandSink);

impl HasIID for D2D1CommandSink {
  fn iid() -> REFGUID { &IID_ID2D1CommandSink }
}

pub trait TD2D1DeviceContext: TD2D1RenderTarget {
  //  Method CreateBitmap
  //  Error: bitmap parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorContext
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method CreateColorContextFromFilename
  //  Error: colorContext parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapFromDxgiSurface
  
  #[allow(non_snake_case)]
  fn create_bitmap_from_dxgi_surface<T: TDXGISurface>(&self, surface: &T, bitmapProperties: &D2D1_BITMAP_PROPERTIES1) -> HResult<D2D1Bitmap1> {
    let mut lv1: *mut ID2D1Bitmap1 = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).CreateBitmapFromDxgiSurface(surface.iptr() as *mut _ as *mut _ , bitmapProperties, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Bitmap1::new(lv1 as *mut _))
  }
  
  //  Method CreateEffect
  //  Error: effect parameter: ANone annotation cannot be used with double indirection
  //  Method CreateGradientStopCollection
  //  Error: gradientStopCollection1 parameter: ANone annotation cannot be used with double indirection
  //  Method CreateImageBrush
  //  Error: imageBrush parameter: ANone annotation cannot be used with double indirection
  //  Method CreateBitmapBrush
  //  Error: bitmapBrush parameter: ANone annotation cannot be used with double indirection
  //  Method CreateCommandList
  //  Error: commandList parameter: ANone annotation cannot be used with double indirection
  //  Method IsDxgiFormatSupported
  
  #[allow(non_snake_case)]
  fn is_dxgi_format_supported(&self, format: DXGI_FORMAT) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).IsDxgiFormatSupported(format) };
    _hr
  }
  
  //  Method IsBufferPrecisionSupported
  
  #[allow(non_snake_case)]
  fn is_buffer_precision_supported(&self, bufferPrecision: D2D1_BUFFER_PRECISION) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).IsBufferPrecisionSupported(bufferPrecision) };
    _hr
  }
  
  //  Method GetImageLocalBounds
  
  #[allow(non_snake_case)]
  fn get_image_local_bounds(&self, image: &mut ID2D1Image, localBounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetImageLocalBounds(image, localBounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetImageWorldBounds
  
  #[allow(non_snake_case)]
  fn get_image_world_bounds(&self, image: &mut ID2D1Image, worldBounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetImageWorldBounds(image, worldBounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetGlyphRunWorldBounds
  
  #[allow(non_snake_case)]
  fn get_glyph_run_world_bounds(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, measuringMode: DWRITE_MEASURING_MODE, bounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetGlyphRunWorldBounds(baselineOrigin, glyphRun, measuringMode, bounds) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetDevice
  //  Error: device parameter: ANone annotation cannot be used with double indirection
  //  Method SetTarget
  
  #[allow(non_snake_case)]
  fn set_target(&self, image: Option<&D2D1Image>) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).SetTarget(image.map(|i|i.iptr()).unwrap_or(ptr::null_mut()) as *mut _ as *mut _) };
    ()
  }
  
  //  Method GetTarget
  //  Error: image parameter: ANone annotation cannot be used with double indirection
  //  Method SetRenderingControls
  
  #[allow(non_snake_case)]
  fn set_rendering_controls(&self, renderingControls: &D2D1_RENDERING_CONTROLS) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).SetRenderingControls(renderingControls) };
    ()
  }
  
  //  Method GetRenderingControls
  
  #[allow(non_snake_case)]
  fn get_rendering_controls(&self, renderingControls: &mut D2D1_RENDERING_CONTROLS) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetRenderingControls(renderingControls) };
    ()
  }
  
  //  Method SetPrimitiveBlend
  
  #[allow(non_snake_case)]
  fn set_primitive_blend(&self, primitiveBlend: D2D1_PRIMITIVE_BLEND) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).SetPrimitiveBlend(primitiveBlend) };
    ()
  }
  
  //  Method GetPrimitiveBlend
  
  #[allow(non_snake_case)]
  fn get_primitive_blend(&self) -> D2D1_PRIMITIVE_BLEND {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetPrimitiveBlend() };
    _hr
  }
  
  //  Method SetUnitMode
  
  #[allow(non_snake_case)]
  fn set_unit_mode(&self, unitMode: D2D1_UNIT_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).SetUnitMode(unitMode) };
    ()
  }
  
  //  Method GetUnitMode
  
  #[allow(non_snake_case)]
  fn get_unit_mode(&self) -> D2D1_UNIT_MODE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetUnitMode() };
    _hr
  }
  
  //  Method DrawGlyphRun
  
  #[allow(non_snake_case)]
  fn draw_glyph_run_dc(&self, baselineOrigin: D2D1_POINT_2F, glyphRun: &DWRITE_GLYPH_RUN, glyphRunDescription: &DWRITE_GLYPH_RUN_DESCRIPTION, foregroundBrush: &mut ID2D1Brush, measuringMode: DWRITE_MEASURING_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).DrawGlyphRun(baselineOrigin, glyphRun, glyphRunDescription, foregroundBrush, measuringMode) };
    ()
  }
  
  //  Method DrawImage
  
  #[allow(non_snake_case)]
  fn draw_image(&self, image: &mut ID2D1Image, targetOffset: &D2D1_POINT_2F, imageRectangle: &D2D1_RECT_F, interpolationMode: D2D1_INTERPOLATION_MODE, compositeMode: D2D1_COMPOSITE_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).DrawImage(image, targetOffset, imageRectangle, interpolationMode, compositeMode) };
    ()
  }
  
  //  Method DrawGdiMetafile
  
  #[allow(non_snake_case)]
  fn draw_gdi_metafile(&self, gdiMetafile: &mut ID2D1GdiMetafile, targetOffset: &D2D1_POINT_2F) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).DrawGdiMetafile(gdiMetafile, targetOffset) };
    ()
  }
  
  //  Method DrawBitmap
  
  #[allow(non_snake_case)]
  fn draw_bitmap_dc(&self, bitmap: &mut ID2D1Bitmap, destinationRectangle: &D2D1_RECT_F, opacity: FLOAT, interpolationMode: D2D1_INTERPOLATION_MODE, sourceRectangle: &D2D1_RECT_F, perspectiveTransform: &D2D1_MATRIX_4X4_F) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).DrawBitmap(bitmap, destinationRectangle, opacity, interpolationMode, sourceRectangle, perspectiveTransform) };
    ()
  }
  
  //  Method PushLayer
  
  #[allow(non_snake_case)]
  fn push_layer_dc(&self, layerParameters: &D2D1_LAYER_PARAMETERS1, layer: &mut ID2D1Layer) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).PushLayer(layerParameters, layer) };
    ()
  }
  
  //  Method InvalidateEffectInputRectangle
  
  #[allow(non_snake_case)]
  fn invalidate_effect_input_rectangle(&self, effect: &mut ID2D1Effect, input: UINT32, inputRectangle: &D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).InvalidateEffectInputRectangle(effect, input, inputRectangle) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectInvalidRectangleCount
  
  #[allow(non_snake_case)]
  fn get_effect_invalid_rectangle_count(&self, effect: &mut ID2D1Effect, rectangleCount: &mut UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetEffectInvalidRectangleCount(effect, rectangleCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectInvalidRectangles
  
  #[allow(non_snake_case)]
  fn get_effect_invalid_rectangles(&self, effect: &mut ID2D1Effect, rectangles: &mut D2D1_RECT_F, rectanglesCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetEffectInvalidRectangles(effect, rectangles, rectanglesCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectRequiredInputRectangles
  
  #[allow(non_snake_case)]
  fn get_effect_required_input_rectangles(&self, renderEffect: &mut ID2D1Effect, renderImageRectangle: &D2D1_RECT_F, inputDescriptions: &D2D1_EFFECT_INPUT_DESCRIPTION, requiredInputRects: &mut D2D1_RECT_F, inputCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).GetEffectRequiredInputRectangles(renderEffect, renderImageRectangle, inputDescriptions, requiredInputRects, inputCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method FillOpacityMask
  
  #[allow(non_snake_case)]
  fn fill_opacity_mask_dc(&self, opacityMask: &mut ID2D1Bitmap, brush: &mut ID2D1Brush, destinationRectangle: &D2D1_RECT_F, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DeviceContext)).FillOpacityMask(opacityMask, brush, destinationRectangle, sourceRectangle) };
    ()
  }
  
  
}

impl TUnknown for D2D1DeviceContext {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1DeviceContext(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1DeviceContext {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1DeviceContext {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1DeviceContext {}
impl TD2D1RenderTarget for D2D1DeviceContext {}
impl TD2D1DeviceContext for D2D1DeviceContext {}

pub struct D2D1DeviceContext(*mut ID2D1DeviceContext);

impl HasIID for D2D1DeviceContext {
  fn iid() -> REFGUID { &IID_ID2D1DeviceContext }
}

pub trait TD2D1Device: TD2D1Resource {
  //  Method CreateDeviceContext
  
  #[allow(non_snake_case)]
  fn create_device_context(&self, options: D2D1_DEVICE_CONTEXT_OPTIONS) -> HResult<D2D1DeviceContext> {
    let mut lv1: *mut ID2D1DeviceContext = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Device)).CreateDeviceContext(options, &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1DeviceContext::new(lv1 as *mut _))
  }
  
  //  Method SetMaximumTextureMemory
  
  #[allow(non_snake_case)]
  fn set_maximum_texture_memory(&self, maximumInBytes: UINT64) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Device)).SetMaximumTextureMemory(maximumInBytes) };
    ()
  }
  
  //  Method GetMaximumTextureMemory
  
  #[allow(non_snake_case)]
  fn get_maximum_texture_memory(&self) -> UINT64 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Device)).GetMaximumTextureMemory() };
    _hr
  }
  
  //  Method ClearResources
  
  #[allow(non_snake_case)]
  fn clear_resources(&self, millisecondsSinceUse: UINT32) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Device)).ClearResources(millisecondsSinceUse) };
    ()
  }
  
  
}

impl TUnknown for D2D1Device {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Device(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Device {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Device {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1Device {}
impl TD2D1Device for D2D1Device {}

pub struct D2D1Device(*mut ID2D1Device);

impl HasIID for D2D1Device {
  fn iid() -> REFGUID { &IID_ID2D1Device }
}

pub trait TD2D1DrawingStateBlock1: TD2D1DrawingStateBlock {
  //  Method GetDescription
  
  #[allow(non_snake_case)]
  fn get_description1(&self, stateDescription: &mut D2D1_DRAWING_STATE_DESCRIPTION1) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DrawingStateBlock1)).GetDescription(stateDescription) };
    ()
  }
  
  //  Method SetDescription
  
  #[allow(non_snake_case)]
  fn set_description1(&self, stateDescription: &D2D1_DRAWING_STATE_DESCRIPTION1) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1DrawingStateBlock1)).SetDescription(stateDescription) };
    ()
  }
  
  
}

impl TUnknown for D2D1DrawingStateBlock1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1DrawingStateBlock1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1DrawingStateBlock1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1DrawingStateBlock1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1DrawingStateBlock1 {}
impl TD2D1DrawingStateBlock for D2D1DrawingStateBlock1 {}
impl TD2D1DrawingStateBlock1 for D2D1DrawingStateBlock1 {}

pub struct D2D1DrawingStateBlock1(*mut ID2D1DrawingStateBlock1);

impl HasIID for D2D1DrawingStateBlock1 {
  fn iid() -> REFGUID { &IID_ID2D1DrawingStateBlock1 }
}

pub trait TD2D1Effect: TD2D1Properties {
  //  Method SetInput
  
  #[allow(non_snake_case)]
  fn set_input(&self, index: UINT32, input: &mut ID2D1Image, invalidate: BOOL) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Effect)).SetInput(index, input, invalidate) };
    ()
  }
  
  //  Method SetInputCount
  
  #[allow(non_snake_case)]
  fn set_input_count(&self, inputCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Effect)).SetInputCount(inputCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetInput
  //  Error: input parameter: ANone annotation cannot be used with double indirection
  //  Method GetInputCount
  
  #[allow(non_snake_case)]
  fn get_input_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Effect)).GetInputCount() };
    _hr
  }
  
  //  Method GetOutput
  //  Error: outputImage parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for D2D1Effect {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Effect(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Effect {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Effect {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Properties for D2D1Effect {}
impl TD2D1Effect for D2D1Effect {}

pub struct D2D1Effect(*mut ID2D1Effect);

impl HasIID for D2D1Effect {
  fn iid() -> REFGUID { &IID_ID2D1Effect }
}

pub trait TD2D1Factory1: TD2D1Factory {
  //  Method CreateDevice
  
  #[allow(non_snake_case)]
  fn create_device<T: TDXGIDevice>(&self, dxgiDevice: &T) -> HResult<D2D1Device> {
    let mut lv1: *mut ID2D1Device = ptr::null_mut();
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Factory1)).CreateDevice(dxgiDevice.iptr() as *mut _ as *mut _ , &mut lv1 as *mut *mut _) };
    hr2ret(_hr,D2D1Device::new(lv1 as *mut _))
  }
  
  //  Method CreateStrokeStyle
  //  Error: strokeStyle parameter: ANone annotation cannot be used with double indirection
  //  Method CreatePathGeometry
  //  Error: pathGeometry parameter: ANone annotation cannot be used with double indirection
  //  Method CreateDrawingStateBlock
  //  Error: drawingStateBlock parameter: ANone annotation cannot be used with double indirection
  //  Method CreateGdiMetafile
  //  Error: metafile parameter: ANone annotation cannot be used with double indirection
  //  Method RegisterEffectFromStream
  
  #[allow(non_snake_case)]
  fn register_effect_from_stream(&self, classId: &IID, propertyXml: &mut IStream, bindings: &D2D1_PROPERTY_BINDING, bindingsCount: UINT32, effectFactory: PD2D1_EFFECT_FACTORY) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Factory1)).RegisterEffectFromStream(classId, propertyXml, bindings, bindingsCount, effectFactory) };
    hr2ret(_hr,_hr)
  }
  
  //  Method RegisterEffectFromString
  
  #[allow(non_snake_case)]
  fn register_effect_from_string(&self, classId: &IID, propertyXml: PCWSTR, bindings: &D2D1_PROPERTY_BINDING, bindingsCount: UINT32, effectFactory: PD2D1_EFFECT_FACTORY) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Factory1)).RegisterEffectFromString(classId, propertyXml, bindings, bindingsCount, effectFactory) };
    hr2ret(_hr,_hr)
  }
  
  //  Method UnregisterEffect
  
  #[allow(non_snake_case)]
  fn unregister_effect(&self, classId: &IID) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Factory1)).UnregisterEffect(classId) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetRegisteredEffects
  
  #[allow(non_snake_case)]
  fn get_registered_effects(&self, effects: &mut CLSID, effectsCount: UINT32, effectsReturned: &mut UINT32, effectsRegistered: &mut UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Factory1)).GetRegisteredEffects(effects, effectsCount, effectsReturned, effectsRegistered) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetEffectProperties
  //  Error: properties parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for D2D1Factory1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Factory1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Factory1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Factory1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Factory for D2D1Factory1 {}
impl TD2D1Factory1 for D2D1Factory1 {}

pub struct D2D1Factory1(*mut ID2D1Factory1);

impl HasIID for D2D1Factory1 {
  fn iid() -> REFGUID { &IID_ID2D1Factory1 }
}

pub trait TD2D1GdiMetafileSink: TUnknown {
  //  Method ProcessRecord
  //  Warning: recordData parameter: ANone annotation applied to void pointer and method isn't marked as unsafe
  
  #[allow(non_snake_case)]
  fn process_record<T>(&self, recordType: DWORD, recordData: &[T], recordDataSize: DWORD) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GdiMetafileSink)).ProcessRecord(recordType, recordData.as_ptr() as *const _, recordDataSize) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1GdiMetafileSink {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1GdiMetafileSink(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1GdiMetafileSink {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1GdiMetafileSink {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1GdiMetafileSink for D2D1GdiMetafileSink {}

pub struct D2D1GdiMetafileSink(*mut ID2D1GdiMetafileSink);

impl HasIID for D2D1GdiMetafileSink {
  fn iid() -> REFGUID { &IID_ID2D1GdiMetafileSink }
}

pub trait TD2D1GdiMetafile: TD2D1Resource {
  //  Method Stream
  
  #[allow(non_snake_case)]
  fn stream(&self, sink: &mut ID2D1GdiMetafileSink) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GdiMetafile)).Stream(sink) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetBounds
  
  #[allow(non_snake_case)]
  fn get_bounds(&self, bounds: &mut D2D1_RECT_F) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GdiMetafile)).GetBounds(bounds) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1GdiMetafile {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1GdiMetafile(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1GdiMetafile {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1GdiMetafile {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1GdiMetafile {}
impl TD2D1GdiMetafile for D2D1GdiMetafile {}

pub struct D2D1GdiMetafile(*mut ID2D1GdiMetafile);

impl HasIID for D2D1GdiMetafile {
  fn iid() -> REFGUID { &IID_ID2D1GdiMetafile }
}

pub trait TD2D1GradientStopCollection1: TD2D1GradientStopCollection {
  //  Method GetGradientStops1
  
  #[allow(non_snake_case)]
  fn get_gradient_stops1(&self, gradientStops: &mut D2D1_GRADIENT_STOP, gradientStopsCount: UINT32) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GradientStopCollection1)).GetGradientStops1(gradientStops, gradientStopsCount) };
    ()
  }
  
  //  Method GetPreInterpolationSpace
  
  #[allow(non_snake_case)]
  fn get_pre_interpolation_space(&self) -> D2D1_COLOR_SPACE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GradientStopCollection1)).GetPreInterpolationSpace() };
    _hr
  }
  
  //  Method GetPostInterpolationSpace
  
  #[allow(non_snake_case)]
  fn get_post_interpolation_space(&self) -> D2D1_COLOR_SPACE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GradientStopCollection1)).GetPostInterpolationSpace() };
    _hr
  }
  
  //  Method GetBufferPrecision
  
  #[allow(non_snake_case)]
  fn get_buffer_precision(&self) -> D2D1_BUFFER_PRECISION {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GradientStopCollection1)).GetBufferPrecision() };
    _hr
  }
  
  //  Method GetColorInterpolationMode
  
  #[allow(non_snake_case)]
  fn get_color_interpolation_mode(&self) -> D2D1_COLOR_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1GradientStopCollection1)).GetColorInterpolationMode() };
    _hr
  }
  
  
}

impl TUnknown for D2D1GradientStopCollection1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1GradientStopCollection1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1GradientStopCollection1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1GradientStopCollection1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1GradientStopCollection1 {}
impl TD2D1GradientStopCollection for D2D1GradientStopCollection1 {}
impl TD2D1GradientStopCollection1 for D2D1GradientStopCollection1 {}

pub struct D2D1GradientStopCollection1(*mut ID2D1GradientStopCollection1);

impl HasIID for D2D1GradientStopCollection1 {
  fn iid() -> REFGUID { &IID_ID2D1GradientStopCollection1 }
}

pub trait TD2D1ImageBrush: TD2D1Brush {
  //  Method SetImage
  
  #[allow(non_snake_case)]
  fn set_image(&self, image: &mut ID2D1Image) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).SetImage(image) };
    ()
  }
  
  //  Method SetExtendModeX
  
  #[allow(non_snake_case)]
  fn set_extend_mode_x(&self, extendModeX: D2D1_EXTEND_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).SetExtendModeX(extendModeX) };
    ()
  }
  
  //  Method SetExtendModeY
  
  #[allow(non_snake_case)]
  fn set_extend_mode_y(&self, extendModeY: D2D1_EXTEND_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).SetExtendModeY(extendModeY) };
    ()
  }
  
  //  Method SetInterpolationMode
  
  #[allow(non_snake_case)]
  fn set_interpolation_mode(&self, interpolationMode: D2D1_INTERPOLATION_MODE) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).SetInterpolationMode(interpolationMode) };
    ()
  }
  
  //  Method SetSourceRectangle
  
  #[allow(non_snake_case)]
  fn set_source_rectangle(&self, sourceRectangle: &D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).SetSourceRectangle(sourceRectangle) };
    ()
  }
  
  //  Method GetImage
  //  Error: image parameter: ANone annotation cannot be used with double indirection
  //  Method GetExtendModeX
  
  #[allow(non_snake_case)]
  fn get_extend_mode_x(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).GetExtendModeX() };
    _hr
  }
  
  //  Method GetExtendModeY
  
  #[allow(non_snake_case)]
  fn get_extend_mode_y(&self) -> D2D1_EXTEND_MODE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).GetExtendModeY() };
    _hr
  }
  
  //  Method GetInterpolationMode
  
  #[allow(non_snake_case)]
  fn get_interpolation_mode(&self) -> D2D1_INTERPOLATION_MODE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).GetInterpolationMode() };
    _hr
  }
  
  //  Method GetSourceRectangle
  
  #[allow(non_snake_case)]
  fn get_source_rectangle(&self, sourceRectangle: &mut D2D1_RECT_F) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1ImageBrush)).GetSourceRectangle(sourceRectangle) };
    ()
  }
  
  
}

impl TUnknown for D2D1ImageBrush {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1ImageBrush(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1ImageBrush {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1ImageBrush {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1ImageBrush {}
impl TD2D1Brush for D2D1ImageBrush {}
impl TD2D1ImageBrush for D2D1ImageBrush {}

pub struct D2D1ImageBrush(*mut ID2D1ImageBrush);

impl HasIID for D2D1ImageBrush {
  fn iid() -> REFGUID { &IID_ID2D1ImageBrush }
}

pub trait TD2D1Multithread: TUnknown {
  //  Method GetMultithreadProtected
  
  #[allow(non_snake_case)]
  fn get_multithread_protected(&self) -> BOOL {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Multithread)).GetMultithreadProtected() };
    _hr
  }
  
  //  Method Enter
  
  #[allow(non_snake_case)]
  fn enter(&self) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Multithread)).Enter() };
    ()
  }
  
  //  Method Leave
  
  #[allow(non_snake_case)]
  fn leave(&self) -> () {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Multithread)).Leave() };
    ()
  }
  
  
}

impl TUnknown for D2D1Multithread {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Multithread(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Multithread {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Multithread {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Multithread for D2D1Multithread {}

pub struct D2D1Multithread(*mut ID2D1Multithread);

impl HasIID for D2D1Multithread {
  fn iid() -> REFGUID { &IID_ID2D1Multithread }
}

pub trait TD2D1PathGeometry1: TD2D1PathGeometry {
  //  Method ComputePointAndSegmentAtLength
  
  #[allow(non_snake_case)]
  fn compute_point_and_segment_at_length(&self, length: FLOAT, startSegment: UINT32, worldTransform: &D2D1_MATRIX_3X2_F, flatteningTolerance: FLOAT, pointDescription: &mut D2D1_POINT_DESCRIPTION) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1PathGeometry1)).ComputePointAndSegmentAtLength(length, startSegment, worldTransform, flatteningTolerance, pointDescription) };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1PathGeometry1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1PathGeometry1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1PathGeometry1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1PathGeometry1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1PathGeometry1 {}
impl TD2D1Geometry for D2D1PathGeometry1 {}
impl TD2D1PathGeometry for D2D1PathGeometry1 {}
impl TD2D1PathGeometry1 for D2D1PathGeometry1 {}

pub struct D2D1PathGeometry1(*mut ID2D1PathGeometry1);

impl HasIID for D2D1PathGeometry1 {
  fn iid() -> REFGUID { &IID_ID2D1PathGeometry1 }
}

pub trait TD2D1PrintControl: TUnknown {
  //  Method AddPage
  
  #[allow(non_snake_case)]
  fn add_page(&self, commandList: &mut ID2D1CommandList, pageSize: D2D_SIZE_F, pagePrintTicketStream: &mut IStream, tag1: &mut D2D1_TAG, tag2: &mut D2D1_TAG) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1PrintControl)).AddPage(commandList, pageSize, pagePrintTicketStream, tag1, tag2) };
    hr2ret(_hr,_hr)
  }
  
  //  Method Close
  
  #[allow(non_snake_case)]
  fn close(&self) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1PrintControl)).Close() };
    hr2ret(_hr,_hr)
  }
  
  
}

impl TUnknown for D2D1PrintControl {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1PrintControl(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1PrintControl {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1PrintControl {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1PrintControl for D2D1PrintControl {}

pub struct D2D1PrintControl(*mut ID2D1PrintControl);

impl HasIID for D2D1PrintControl {
  fn iid() -> REFGUID { &IID_ID2D1PrintControl }
}

pub trait TD2D1Properties: TUnknown {
  //  Method GetPropertyCount
  
  #[allow(non_snake_case)]
  fn get_property_count(&self) -> UINT32 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetPropertyCount() };
    _hr
  }
  
  //  Method GetPropertyName
  
  #[allow(non_snake_case)]
  fn get_property_name(&self, index: UINT32, name: PWSTR, nameCount: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetPropertyName(index, name, nameCount) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetPropertyNameLength
  
  #[allow(non_snake_case)]
  fn get_property_name_length(&self, index: UINT32) -> UINT32 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetPropertyNameLength(index) };
    _hr
  }
  
  //  Method GetType
  
  #[allow(non_snake_case)]
  fn get_type(&self, index: UINT32) -> D2D1_PROPERTY_TYPE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetType(index) };
    _hr
  }
  
  //  Method GetPropertyIndex
  
  #[allow(non_snake_case)]
  fn get_property_index(&self, name: PCWSTR) -> UINT32 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetPropertyIndex(name) };
    _hr
  }
  
  //  Method SetValueByName
  
  #[allow(non_snake_case)]
  fn set_value_by_name(&self, name: PCWSTR, type_: D2D1_PROPERTY_TYPE, data: &BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).SetValueByName(name, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method SetValue
  
  #[allow(non_snake_case)]
  fn set_value(&self, index: UINT32, type_: D2D1_PROPERTY_TYPE, data: &BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).SetValue(index, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValueByName
  
  #[allow(non_snake_case)]
  fn get_value_by_name(&self, name: PCWSTR, type_: D2D1_PROPERTY_TYPE, data: &mut BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetValueByName(name, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValue
  
  #[allow(non_snake_case)]
  fn get_value(&self, index: UINT32, type_: D2D1_PROPERTY_TYPE, data: &mut BYTE, dataSize: UINT32) -> HResult<HRESULT> {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetValue(index, type_, data, dataSize) };
    hr2ret(_hr,_hr)
  }
  
  //  Method GetValueSize
  
  #[allow(non_snake_case)]
  fn get_value_size(&self, index: UINT32) -> UINT32 {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1Properties)).GetValueSize(index) };
    _hr
  }
  
  //  Method GetSubProperties
  //  Error: subProperties parameter: ANone annotation cannot be used with double indirection
  
}

impl TUnknown for D2D1Properties {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1Properties(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1Properties {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1Properties {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Properties for D2D1Properties {}

pub struct D2D1Properties(*mut ID2D1Properties);

impl HasIID for D2D1Properties {
  fn iid() -> REFGUID { &IID_ID2D1Properties }
}

pub trait TD2D1StrokeStyle1: TD2D1StrokeStyle {
  //  Method GetStrokeTransformType
  
  #[allow(non_snake_case)]
  fn get_stroke_transform_type(&self) -> D2D1_STROKE_TRANSFORM_TYPE {
  
    let _hr=unsafe { (*(self.iptr() as *mut ID2D1StrokeStyle1)).GetStrokeTransformType() };
    _hr
  }
  
  
}

impl TUnknown for D2D1StrokeStyle1 {
  fn new(ptr: *mut IUnknown) -> Self {
    D2D1StrokeStyle1(ptr as *mut _)
  }
  fn iptr(&self) -> *mut IUnknown {
    self.0 as *mut _
  }
}
impl Drop for D2D1StrokeStyle1 {
  fn drop(&mut self) { drop_unknown(self) }
}
impl Clone for D2D1StrokeStyle1 {
  fn clone(&self) -> Self { clone_unknown(self) }
}
impl TD2D1Resource for D2D1StrokeStyle1 {}
impl TD2D1StrokeStyle for D2D1StrokeStyle1 {}
impl TD2D1StrokeStyle1 for D2D1StrokeStyle1 {}

pub struct D2D1StrokeStyle1(*mut ID2D1StrokeStyle1);

impl HasIID for D2D1StrokeStyle1 {
  fn iid() -> REFGUID { &IID_ID2D1StrokeStyle1 }
}

